{
  "version": 3,
  "sources": ["../../thirdweb/node_modules/abitype/src/version.ts", "../../thirdweb/node_modules/abitype/src/errors.ts", "../../thirdweb/node_modules/abitype/src/regex.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiParameter.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiParameters.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiItem.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbi.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/signatures.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/abiItem.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/abiParameter.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/signature.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/struct.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/splitParameters.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/cache.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/utils.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/structs.ts", "../../thirdweb/node_modules/abitype/src/human-readable/parseAbi.ts", "../../thirdweb/node_modules/abitype/src/human-readable/parseAbiItem.ts", "../../viem/utils/formatters/transaction.ts", "../../viem/utils/formatters/block.ts", "../../viem/utils/blob/blobsToCommitments.ts", "../../viem/utils/blob/blobsToProofs.ts", "../../viem/utils/hash/sha256.ts", "../../viem/utils/blob/commitmentToVersionedHash.ts", "../../viem/utils/blob/commitmentsToVersionedHashes.ts", "../../viem/constants/blob.ts", "../../viem/constants/kzg.ts", "../../viem/errors/blob.ts", "../../viem/utils/blob/toBlobs.ts", "../../viem/utils/blob/toBlobSidecars.ts", "../../viem/utils/transaction/getTransactionType.ts", "../../viem/utils/formatters/log.ts", "../../viem/utils/rpc/id.ts", "../../viem/utils/encoding/toRlp.ts", "../../viem/utils/formatters/transactionReceipt.ts", "../../viem/node_modules/@noble/hashes/src/ripemd160.ts", "../../viem/utils/transaction/assertTransaction.ts", "../../viem/utils/transaction/serializeAccessList.ts", "../../viem/utils/transaction/serializeTransaction.ts", "../../viem/constants/number.ts", "../../thirdweb/src/transaction/utils.ts", "../../thirdweb/src/rpc/actions/eth_call.ts", "../../thirdweb/src/utils/encoding/to-bytes.ts", "../../thirdweb/src/utils/hashing/keccak256.ts", "../../thirdweb/src/utils/address.ts", "../../thirdweb/src/utils/abi/encodeAbiParameters.ts", "../../thirdweb/src/utils/abi/prepare-method.ts", "../../thirdweb/src/transaction/read-contract.ts"],
  "sourcesContent": ["export const version = '1.0.0'\n", "import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n        ? args.cause.message\n        : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n", "// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<T>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as T | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param TAbiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  TAbiParameter extends AbiParameter | AbiEventParameter,\n> = TAbiParameter extends {\n  name?: infer Name extends string\n  type: `tuple${infer Array}`\n  components: infer Components extends readonly AbiParameter[]\n  indexed?: infer Indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [K in keyof Components]: FormatAbiParameter<\n              {\n                type: Components[K]['type']\n              } & (IsNarrowable<Components[K]['name'], string> extends true\n                ? { name: Components[K]['name'] }\n                : unknown) &\n                (Components[K] extends { components: readonly AbiParameter[] }\n                  ? { components: Components[K]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${Array}`\n      } & (IsNarrowable<Name, string> extends true ? { name: Name } : unknown) &\n        (IsNarrowable<Indexed, boolean> extends true\n          ? { indexed: Indexed }\n          : unknown)\n    >\n  : `${TAbiParameter['type']}${TAbiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${TAbiParameter['name'] extends infer Name extends string\n      ? Name extends ''\n        ? ''\n        : ` ${AssertName<Name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const TAbiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: TAbiParameter): FormatAbiParameter<TAbiParameter> {\n  type Result = FormatAbiParameter<TAbiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param TAbiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  TAbiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [K in keyof TAbiParameters]: FormatAbiParameter<TAbiParameters[K]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const TAbiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: TAbiParameters): FormatAbiParameters<TAbiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<TAbiParameters>\n}\n", "import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param TAbiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<TAbiItem extends Abi[number]> =\n  Abi[number] extends TAbiItem\n    ? string\n    :\n        | (TAbiItem extends AbiFunction\n            ? AbiFunction extends TAbiItem\n              ? string\n              : `function ${AssertName<TAbiItem['name']>}(${FormatAbiParameters<\n                  TAbiItem['inputs']\n                >})${TAbiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${TAbiItem['stateMutability']}`\n                  : ''}${TAbiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<TAbiItem['outputs']>})`}`\n            : never)\n        | (TAbiItem extends AbiEvent\n            ? AbiEvent extends TAbiItem\n              ? string\n              : `event ${AssertName<TAbiItem['name']>}(${FormatAbiParameters<\n                  TAbiItem['inputs']\n                >})`\n            : never)\n        | (TAbiItem extends AbiError\n            ? AbiError extends TAbiItem\n              ? string\n              : `error ${AssertName<TAbiItem['name']>}(${FormatAbiParameters<\n                  TAbiItem['inputs']\n                >})`\n            : never)\n        | (TAbiItem extends AbiConstructor\n            ? AbiConstructor extends TAbiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  TAbiItem['inputs']\n                >})${TAbiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (TAbiItem extends AbiFallback\n            ? AbiFallback extends TAbiItem\n              ? string\n              : 'fallback()'\n            : never)\n        | (TAbiItem extends AbiReceive\n            ? AbiReceive extends TAbiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  TAbiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = TAbiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      TAbiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? TAbiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const TAbiItem extends Abi[number]>(\n  abiItem: TAbiItem,\n): FormatAbiItem<TAbiItem> {\n  type Result = FormatAbiItem<TAbiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  else if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  else if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  else if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  else if (abiItem.type === 'fallback') return 'fallback()' as Result\n  return 'receive() external payable' as Result\n}\n", "import type { Abi } from '../abi.js'\nimport { type FormatAbiItem, formatAbiItem } from './formatAbiItem.js'\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param TAbi - ABI\n * @returns Human-readable ABI\n */\nexport type FormatAbi<TAbi extends Abi | readonly unknown[]> = Abi extends TAbi\n  ? readonly string[]\n  : TAbi extends readonly []\n  ? never\n  : TAbi extends Abi\n  ? {\n      [K in keyof TAbi]: FormatAbiItem<TAbi[K]>\n    }\n  : readonly string[]\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport function formatAbi<const TAbi extends Abi | readonly unknown[]>(\n  abi: TAbi,\n): FormatAbi<TAbi> {\n  const signatures = []\n  const length = abi.length\n  for (let i = 0; i < length; i++) {\n    const abiItem = abi[i]!\n    const signature = formatAbiItem(abiItem as Abi[number])\n    signatures.push(signature)\n  }\n  return signatures as unknown as FormatAbi<TAbi>\n}\n", "import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/78u18\nconst fallbackSignatureRegex = /^fallback\\(\\)$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n", "import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n", "import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n", "import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n", "import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n) {\n  if (type) return `${type}:${param}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n", "import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n    const inputParams = splitParameters(match.parameters)\n    const inputs = []\n    const inputLength = inputParams.length\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n\n    const outputs = []\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns)\n      const outputLength = outputParams.length\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i]!, {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n          }),\n        )\n      }\n    }\n\n    return {\n      name: match.name,\n      type: 'function',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs,\n      outputs,\n    }\n  }\n\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, {\n          modifiers: eventModifiers,\n          structs,\n          type: 'event',\n        }),\n      )\n    }\n    return { name: match.name, type: 'event', inputs: abiParameters }\n  }\n\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'error' }),\n      )\n    }\n    return { name: match.name, type: 'error', inputs: abiParameters }\n  }\n\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature)\n    if (!match)\n      throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n      )\n    }\n    return {\n      type: 'constructor',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs: abiParameters,\n    }\n  }\n\n  if (isFallbackSignature(signature)) return { type: 'fallback' }\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(param, options?.type)\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n", "import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n", "import type { Abi } from '../abi.js'\nimport type { Error, Filter } from '../types.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param TSignatures - Human-readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * type Result = ParseAbi<\n *   // ^? type Result = readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   [\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'event Transfer(address indexed from, address indexed to, uint256 amount)',\n *   ]\n * >\n */\nexport type ParseAbi<TSignatures extends readonly string[]> =\n  string[] extends TSignatures\n    ? Abi // If `T` was not able to be inferred (e.g. just `string[]`), return `Abi`\n    : TSignatures extends readonly string[]\n    ? TSignatures extends Signatures<TSignatures> // Validate signatures\n      ? ParseStructs<TSignatures> extends infer Structs\n        ? {\n            [K in keyof TSignatures]: TSignatures[K] extends string\n              ? ParseSignature<TSignatures[K], Structs>\n              : never\n          } extends infer Mapped extends readonly unknown[]\n          ? Filter<Mapped, never> extends infer Result\n            ? Result extends readonly []\n              ? never\n              : Result\n            : never\n          : never\n        : never\n      : never\n    : never\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi<const TSignatures extends readonly string[]>(\n  signatures: TSignatures['length'] extends 0\n    ? Error<'At least one signature required'>\n    : Signatures<TSignatures> extends TSignatures\n    ? TSignatures\n    : Signatures<TSignatures>,\n): ParseAbi<TSignatures> {\n  const structs = parseStructs(signatures as readonly string[])\n  const abi = []\n  const length = signatures.length as number\n  for (let i = 0; i < length; i++) {\n    const signature = (signatures as readonly string[])[i]!\n    if (isStructSignature(signature)) continue\n    abi.push(parseSignature(signature, structs))\n  }\n  return abi as unknown as ParseAbi<TSignatures>\n}\n", "import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param TSignature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  TSignature extends string | readonly string[] | readonly unknown[],\n> =\n  | (TSignature extends string\n      ? string extends TSignature\n        ? Abi[number]\n        : TSignature extends Signature<TSignature> // Validate signature\n        ? ParseSignature<TSignature>\n        : never\n      : never)\n  | (TSignature extends readonly string[]\n      ? string[] extends TSignature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : TSignature extends Signatures<TSignature> // Validate signature\n        ? ParseStructs<TSignature> extends infer Structs\n          ? {\n              [K in keyof TSignature]: ParseSignature<\n                TSignature[K] extends string ? TSignature[K] : never,\n                Structs\n              >\n            } extends infer Mapped extends readonly unknown[]\n            ? // Filter out `never` since those are structs\n              Filter<Mapped, never>[0] extends infer Result\n              ? Result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                ? never\n                : Result\n              : never\n            : never\n          : never\n        : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  TSignature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<TSignature> &\n    (\n      | (TSignature extends string\n          ? string extends TSignature\n            ? unknown\n            : Signature<TSignature>\n          : never)\n      | (TSignature extends readonly string[]\n          ? TSignature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends TSignature\n            ? unknown\n            : Signatures<TSignature>\n          : never)\n    ),\n): ParseAbiItem<TSignature> {\n  let abiItem\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<TSignature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs)\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<TSignature>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransaction } from '../../types/rpc.js'\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\ntype TransactionPendingDependencies =\n  | 'blockHash'\n  | 'blockNumber'\n  | 'transactionIndex'\n\nexport type FormattedTransaction<\n  TChain extends Chain | undefined = undefined,\n  TBlockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    TChain,\n    'transaction',\n    Transaction\n  >,\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\n    ExtractChainFormatterExclude<TChain, 'transaction'>,\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\n  [_K in _ExcludedPendingDependencies]: never\n} & Pick<\n    Transaction<bigint, number, TBlockTag extends 'pending' ? true : false>,\n    TransactionPendingDependencies\n  >\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n} as const satisfies Record<Hex, TransactionType>\n\nexport type FormatTransactionErrorType = ErrorType\n\nexport function formatTransaction(transaction: ExactPartial<RpcTransaction>) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\n      ? BigInt(transaction.maxFeePerBlobGas)\n      : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type\n      ? (transactionType as any)[transaction.type]\n      : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  } as Transaction\n\n  transaction_.yParity = (() => {\n    // If `yParity` is provided, we will use it.\n    if (transaction.yParity) return Number(transaction.yParity)\n\n    // If no `yParity` provided, try derive from `v`.\n    if (typeof transaction_.v === 'bigint') {\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\n    }\n\n    return undefined\n  })()\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_.accessList\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n    delete transaction_.yParity\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n  }\n  if (transaction_.type === 'eip1559') {\n    delete transaction_.maxFeePerBlobGas\n  }\n  return transaction_\n}\n\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\n  'transaction',\n  formatTransaction,\n)\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\n\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\n\nexport type FormattedBlock<\n  TChain extends Chain | undefined = undefined,\n  TIncludeTransactions extends boolean = boolean,\n  TBlockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    TChain,\n    'block',\n    Block<bigint, TIncludeTransactions>\n  >,\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\n    ExtractChainFormatterExclude<TChain, 'block'>,\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\n    [_key in _ExcludedPendingDependencies]: never\n  } & Pick<\n      Block<bigint, TIncludeTransactions, TBlockTag>,\n      BlockPendingDependencies\n    >,\n  _Transactions = TIncludeTransactions extends true\n    ? Prettify<FormattedTransaction<TChain, TBlockTag>>[]\n    : Hash[],\n> = Omit<_Formatted, 'transactions'> & {\n  transactions: _Transactions\n}\n\nexport type FormatBlockErrorType = ErrorType\n\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\n  const transactions = block.transactions?.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n", "import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo | undefined,\n): Sha256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<TTo>\n  return toHex(bytes) as Sha256Hash<TTo>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nexport const blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** The number of bytes in a KZG commitment. */\nexport const bytesPerCommitment = 48\n\n/** The number of bytes in a KZG proof. */\nexport const bytesPerProof = 48\n\nexport const versionedHashVersionKzg = 1\n", "import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  override name = 'BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  override name = 'EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  override name = 'InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  override name = 'InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n", "import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n", "import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport type {\n  Assign,\n  ExactPartial,\n  IsNever,\n  OneOf,\n  Opaque,\n} from '../../types/utils.js'\n\ntype BaseProperties = {\n  accessList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesLegacy> & {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends\n        | Opaque<TransactionSerializableLegacy, transaction>\n        | Opaque<TransactionRequestLegacy, transaction>\n        | LegacyProperties\n        ? 'legacy'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP1559, transaction>\n        | Opaque<TransactionRequestEIP1559, transaction>\n        | EIP1559Properties\n        ? 'eip1559'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP2930, transaction>\n        | Opaque<TransactionRequestEIP2930, transaction>\n        | EIP2930Properties\n        ? 'eip2930'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP4844, transaction>\n        | Opaque<TransactionRequestEIP4844, transaction>\n        | EIP4844Properties\n        ? 'eip4844'\n        : never)\n    | (transaction['type'] extends string ? transaction['type'] : never),\n> = IsNever<result> extends false ? result : string\n\nexport type GetTransationTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n", "export function createIdStore() {\n  return {\n    current: 0,\n    take() {\n      return this.current++\n    },\n    reset() {\n      this.current = 0\n    },\n  }\n}\n\nexport const idCache = /*#__PURE__*/ createIdStore()\n", "import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  TChain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  TChain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n", "import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));\n\nconst shifts = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word: number, shift: number) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  else if (group === 1) return (x & y) | (~x & z);\n  else if (group === 2) return (x | ~y) ^ z;\n  else if (group === 3) return (x & z) | (y & ~z);\n  else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean() {\n    BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n", "import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    accessList,\n  } = transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n  if (accessList)\n    throw new BaseError(\n      '`accessList` is not a valid Legacy Transaction attribute.',\n    )\n}\n", "import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n", "import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransationTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransationTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      signature.r,\n      signature.s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature?: Signature | undefined,\n) {\n  const { r, s, v, yParity } = signature ?? transaction\n  if (typeof r === 'undefined') return []\n  if (typeof s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n  return [yParity_, trim(r), trim(s)]\n}\n", "export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n", "import type { AbiFunction } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n", "import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          code: override.code,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n", "import { cachedTextEncoder } from \"../text-encoder.js\";\nimport { assertSize } from \"./helpers/assert-size.js\";\nimport { charCodeToBase16 } from \"./helpers/charcode-to-base-16.js\";\nimport { type Hex, isHex } from \"./helpers/is-hex.js\";\nimport { type NumberToHexOpts, numberToHex, padHex } from \"./hex.js\";\n\ntype PadOptions = {\n  dir?: \"left\" | \"right\";\n  size?: number | null;\n};\n\nfunction padBytes(bytes: Uint8Array, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) {\n    return bytes;\n  }\n  if (bytes.length > size) {\n    throw new Error(`Size overflow: ${bytes.length} > ${size}`);\n  }\n  const paddedBytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === \"right\";\n    paddedBytes[padEnd ? i : size - i - 1] =\n      // biome-ignore lint/style/noNonNullAssertion: we know its there\n      bytes[padEnd ? i : bytes.length - i - 1]!;\n  }\n  return paddedBytes;\n}\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number;\n};\n\n/**\n * Converts a value to an array of bytes.\n * @param value - The value to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The array of bytes representing the value.\n * @example\n * ```ts\n * import { toBytes } from \"thirdweb/utils\";\n * const bytes = toBytes(\"0x1a4\");\n * console.log(bytes); // Uint8Array(2) [ 1, 164 ]\n * ```\n * @utils\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): Uint8Array {\n  switch (typeof value) {\n    case \"number\":\n    case \"bigint\":\n      return numberToBytes(value, opts);\n    case \"boolean\":\n      return boolToBytes(value, opts);\n    default:\n      if (isHex(value)) {\n        return hexToBytes(value, opts);\n      }\n      return stringToBytes(value, opts);\n  }\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number;\n};\n\n/**\n * Converts a boolean value to a Uint8Array of bytes.\n * @param value - The boolean value to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The Uint8Array of bytes representing the boolean value.\n * @example\n * ```ts\n * import { boolToBytes } from \"thirdweb/utils\";\n * const bytes = boolToBytes(true);\n * console.log(bytes); // Uint8Array(1) [ 1 ]\n * ```\n * @utils\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === \"number\") {\n    assertSize(bytes, { size: opts.size });\n    return padBytes(bytes, { size: opts.size });\n  }\n  return bytes;\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number;\n};\n\n/**\n * Converts a hexadecimal string to a Uint8Array of bytes.\n * @param hex_ The hexadecimal string to convert.\n * @param opts Options for converting the hexadecimal string.\n * @returns The Uint8Array of bytes.\n * @throws Error if the byte sequence is invalid.\n * @example\n * ```ts\n * import { hexToBytes } from \"thirdweb/utils\";\n * const bytes = hexToBytes(\"0x1a4\");\n * console.log(bytes); // Uint8Array(2) [ 1, 164 ]\n * ```\n * @utils\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): Uint8Array {\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, { size: opts.size });\n    hex = padHex(hex, { dir: \"right\", size: opts.size });\n  }\n\n  let hexString = hex.slice(2) as string;\n  if (hexString.length % 2) {\n    hexString = `0${hexString}`;\n  }\n\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Error(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      );\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\n\n/**\n * Converts a number to bytes.\n * @param value - The number to convert.\n * @param opts - Options for converting the number to hex.\n * @returns The bytes representation of the number.\n * @example\n * ```ts\n * import { numberToBytes } from \"thirdweb/utils\";\n * const bytes = numberToBytes(420);\n * console.log(bytes); // Uint8Array(2) [ 1, 164 ]\n * ```\n * @utils\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts);\n  return hexToBytes(hex);\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number;\n};\n\n/**\n * Converts a string to an array of bytes.\n * @param value - The string to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The array of bytes representing the string.\n * @example\n * ```ts\n * import { stringToBytes } from \"thirdweb/utils\";\n * const bytes = stringToBytes(\"Hello, world!\");\n * console.log(bytes); // Uint8Array(13) [ 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33 ]\n * ```\n * @utils\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): Uint8Array {\n  const bytes = cachedTextEncoder().encode(value);\n  if (typeof opts.size === \"number\") {\n    assertSize(bytes, { size: opts.size });\n    return padBytes(bytes, { dir: \"right\", size: opts.size });\n  }\n  return bytes;\n}\n", "import { keccak_256 } from \"@noble/hashes/sha3\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the Keccak-256 hash of the given value.\n * @param value - The value to hash, either as a hexadecimal string or a Uint8Array.\n * @param to - The desired output format of the hash (optional). Defaults to 'hex'.\n * @returns The Keccak-256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { keccak256 } from \"thirdweb/utils\";\n * const hash = keccak256(\"0x1234\");\n * ```\n * @utils\n */\nexport function keccak256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Keccak256Hash<TTo> {\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Keccak256Hash<TTo>;\n  }\n  // default fall through to hex\n  return uint8ArrayToHex(bytes) as Keccak256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { keccak256 } from \"./hashing/keccak256.js\";\n\nexport type AddressInput = string;\nexport type Address = `0x${string}`;\n\nconst ADRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nconst IS_ADDRESS_CACHE = new LruMap<boolean>(4096);\n\n/**\n * Checks if a given string is a valid address.\n * @param address The address to check.\n * @returns True if the address is valid, false otherwise.\n * @example\n * ```ts\n * import { isAddress } from 'thirdweb/utils';\n *\n * isAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> true\n * ```\n * @utils\n */\nexport function isAddress(address: string): address is Address {\n  if (IS_ADDRESS_CACHE.has(address)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return IS_ADDRESS_CACHE.get(address)!;\n  }\n  const result = (() => {\n    if (!ADRESS_REGEX.test(address)) {\n      return false;\n    }\n    if (address.toLowerCase() === address) {\n      return true;\n    }\n\n    return checksumAddress(address) === address;\n  })();\n  IS_ADDRESS_CACHE.set(address, result);\n  return result;\n}\n\n/**\n * Calculates the checksum address for the given address.\n * @param address - The address to calculate the checksum for.\n * @returns The checksum address.\n * @example\n * ```ts\n * import { checksumAddress } from 'thirdweb/utils';\n *\n * checksumAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function checksumAddress(address: string): Address {\n  const hexAddress = address.substring(2).toLowerCase();\n  const hash = keccak256(stringToBytes(hexAddress), \"bytes\");\n\n  const address_ = hexAddress.split(\"\");\n  for (let i = 0; i < 40; i += 2) {\n    // biome-ignore lint/style/noNonNullAssertion: <explanation>\n    if (hash[i >> 1]! >> 4 >= 8 && address[i]) {\n      // biome-ignore lint/style/noNonNullAssertion: <explanation>\n      address_[i] = address_[i]!.toUpperCase();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: <explanation>\n    if ((hash[i >> 1]! & 0x0f) >= 8 && address[i + 1]) {\n      // biome-ignore lint/style/noNonNullAssertion: <explanation>\n      address_[i + 1] = address_[i + 1]!.toUpperCase();\n    }\n  }\n\n  return `0x${address_.join(\"\")}`;\n}\n\n/**\n * Retrieves the address after performing validation and checksumming.\n * @param address - The address to be validated and checksummed.\n * @returns The validated and checksummed address.\n * @throws Error if the address is invalid.\n * @example\n * ```ts\n * import { getAddress } from 'thirdweb/utils';\n *\n * getAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function getAddress(address: string): Address {\n  if (!isAddress(address)) {\n    throw new Error(`Invalid address: ${address}`);\n  }\n  return checksumAddress(address);\n}\n\n/**\n * Checksums and formats an address if valid. Note this function does not check if the provided address is an ENS.\n * @param address - The address to shorten.\n * @param length - The number of characters to keep from the start and end of the address.\n * @returns The shortened address.\n * @example\n * ```ts\n * import { shortenAddress } from 'thirdweb/utils';\n *\n * shortenAddress('0xa0cf798816d4b9b9866b5330eea46a18382f251e');\n * //=> '0xA0Cf...251e'\n * ```\n * @utils\n */\nexport function shortenAddress(address: string, length = 4) {\n  const _address = getAddress(address);\n  return `${_address.slice(0, length + 2)}...${_address.slice(-length)}`;\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from \"abitype\";\nimport { concat, slice } from \"viem/utils\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  type Hex,\n  boolToHex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"viem\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) {\n    throw new Error(\"Invalid address.\");\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length_, data]) : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(byteSize(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n", "import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n", "import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { type TransactionRequest, decodeAbiParameters } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\n\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Reads data from a smart contract.\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read transaction.\n * @transaction\n * @example\n * ```ts\n * import { readContract } from \"thirdweb\";\n * const result = await readContract({\n *  contract,\n *  method: \"totalSupply\",\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n"],
  "mappings": "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",
  "names": ["BaseError", "BaseError", "BaseError", "BaseError", "BaseError", "BaseError", "sha256", "isHex", "version", "sha256", "version", "size", "version", "size", "version", "blobs", "commitments", "proofs", "v", "padBytes", "size", "hexToBytes", "stringToBytes", "padBytes", "keccak256", "isAddress", "checksumAddress", "keccak256", "stringToBytes", "encodeAbiParameters", "isAddress", "readContract", "encodeAbiParameters"]
}
