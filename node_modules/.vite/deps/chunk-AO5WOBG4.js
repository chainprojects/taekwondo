import {
  getInjectedMagicEdenProvider
} from "./chunk-3SKRXWUN.js";
import {
  getInjectedXDEFIProvider
} from "./chunk-GGII2DOJ.js";
import {
  getInjectedPhantomProvider
} from "./chunk-BGCQ64CW.js";
import {
  getInjectedRainbowProvider
} from "./chunk-SQHU4NWU.js";
import {
  require_brorand,
  require_hmac_drbg,
  require_utils as require_utils2
} from "./chunk-EWUQFHIP.js";
import {
  AbstractWallet,
  ERC6551_REGISTRY,
  checkContractWalletSignature,
  getAnalyticsHeaders,
  isZkSyncChain,
  require_dist
} from "./chunk-GS6WAU5I.js";
import {
  getInjectedOKXProvider
} from "./chunk-SRRH4CRM.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-GQWRI7QN.js";
import {
  getInjectedOneKeyProvider
} from "./chunk-TFMZQD2J.js";
import {
  getInjectedCryptoDefiWalletProvider
} from "./chunk-7ZTRRMDX.js";
import {
  getInjectedRabbyProvider
} from "./chunk-M5HHJ5TL.js";
import {
  getInjectedCoin98Provider
} from "./chunk-H7BIURJ6.js";
import {
  WagmiAdapter
} from "./chunk-WPIQUFSE.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-R3IZTCGT.js";
import {
  walletIds
} from "./chunk-KOCNAQFC.js";
import {
  assertWindowEthereum
} from "./chunk-RKAC5DGX.js";
import {
  _defineProperty
} from "./chunk-34YZJOIR.js";
import {
  A,
  C,
  E,
  IEvents,
  Po,
  Qe,
  Qo,
  detect,
  esm_exports2 as esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  h,
  import_pino,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  k,
  parseConnectionError,
  payloadId,
  r,
  require_binary,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_wipe,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  sn,
  y
} from "./chunk-7VSIBYBO.js";
import {
  require_events
} from "./chunk-PTBKMDVE.js";
import {
  aesDecryptCompat,
  aesEncrypt,
  getChainProvider
} from "./chunk-IEERL7KR.js";
import {
  require_utils
} from "./chunk-OFYAKLRP.js";
import {
  concat,
  fromString,
  init_concat,
  init_from_string,
  init_to_string,
  toString
} from "./chunk-2GO4LQYH.js";
import {
  require_buffer as require_buffer2
} from "./chunk-FN5EYCZK.js";
import {
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-6F3W3FP6.js";
import {
  BigNumber,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress,
  require_hash,
  require_minimalistic_assert
} from "./chunk-ZNZUQJHA.js";
import {
  require_buffer,
  require_inherits_browser
} from "./chunk-LRNGUABD.js";
import {
  eventemitter3_default
} from "./chunk-4QUVL3P2.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-S2RS4OC4.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2E63JINA.js";

// node_modules/@walletconnect/utils/node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w5;
        var off = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w5 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w5 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j4 = 0;
        var w5;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w5 = parseHexByte(number, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w5 = parseHexByte(number, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c5 = str.charCodeAt(i4) - 48;
          r3 *= mul;
          if (c5 >= 49) {
            r3 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r3 += c5 - 17 + 10;
          } else {
            r3 += c5;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w5 = this.words[i4];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r3 = c5.modn(groupBase).toString(base);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b6, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b6 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b6;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b6 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b6;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t = w5;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi4 = this._countBits(w5);
        return (this.length - 1) * 26 + hi4;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b6 = this._zeroBits(this.words[i4]);
          r3 += b6;
          if (b6 !== 26)
            break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or5(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b6;
        if (this.length > num.length) {
          b6 = num;
        } else {
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b6.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a5;
        var b6;
        if (this.length > num.length) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = a5.words[i4] ^ b6.words[i4];
        }
        if (this !== a5) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a5, b6;
        if (this.length > num.length) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r3 = (a5.words[i4] | 0) + (b6.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i4 < a5.length; i4++) {
          r3 = (a5.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b6;
        if (cmp > 0) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r3 = (a5.words[i4] | 0) - (b6.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        for (; carry !== 0 && i4 < a5.length; i4++) {
          r3 = (a5.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        if (carry === 0 && i4 < a5.length && a5 !== this) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b6 = num.words[0] | 0;
        var r3 = a5 * b6;
        var lo3 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo3;
        for (var k4 = 1; k4 < len; k4++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j4 = Math.max(0, k4 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k4 - j4 | 0;
            a5 = self2.words[i4] | 0;
            b6 = num.words[j4] | 0;
            r3 = a5 * b6 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k4] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k4] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b6 = num.words;
        var o4 = out.words;
        var c5 = 0;
        var lo3;
        var mid;
        var hi4;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b6[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b6[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b6[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b6[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b6[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b6[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b6[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b7 = b6[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b6[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b6[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo3 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi4 = Math.imul(ah0, bh0);
        var w0 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo3 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi4 = Math.imul(ah1, bh0);
        lo3 = lo3 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi4 = hi4 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo3 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi4 = Math.imul(ah2, bh0);
        lo3 = lo3 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi4 = hi4 + Math.imul(ah1, bh1) | 0;
        lo3 = lo3 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi4 = hi4 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo3 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi4 = Math.imul(ah3, bh0);
        lo3 = lo3 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi4 = hi4 + Math.imul(ah2, bh1) | 0;
        lo3 = lo3 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi4 = hi4 + Math.imul(ah1, bh2) | 0;
        lo3 = lo3 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi4 = hi4 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo3 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi4 = Math.imul(ah4, bh0);
        lo3 = lo3 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi4 = hi4 + Math.imul(ah3, bh1) | 0;
        lo3 = lo3 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi4 = hi4 + Math.imul(ah2, bh2) | 0;
        lo3 = lo3 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi4 = hi4 + Math.imul(ah1, bh3) | 0;
        lo3 = lo3 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi4 = hi4 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo3 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi4 = Math.imul(ah5, bh0);
        lo3 = lo3 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi4 = hi4 + Math.imul(ah4, bh1) | 0;
        lo3 = lo3 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi4 = hi4 + Math.imul(ah3, bh2) | 0;
        lo3 = lo3 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi4 = hi4 + Math.imul(ah2, bh3) | 0;
        lo3 = lo3 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi4 = hi4 + Math.imul(ah1, bh4) | 0;
        lo3 = lo3 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi4 = hi4 + Math.imul(ah0, bh5) | 0;
        var w5 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo3 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi4 = Math.imul(ah6, bh0);
        lo3 = lo3 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi4 = hi4 + Math.imul(ah5, bh1) | 0;
        lo3 = lo3 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi4 = hi4 + Math.imul(ah4, bh2) | 0;
        lo3 = lo3 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi4 = hi4 + Math.imul(ah3, bh3) | 0;
        lo3 = lo3 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi4 = hi4 + Math.imul(ah2, bh4) | 0;
        lo3 = lo3 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi4 = hi4 + Math.imul(ah1, bh5) | 0;
        lo3 = lo3 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi4 = hi4 + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo3 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi4 = Math.imul(ah7, bh0);
        lo3 = lo3 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi4 = hi4 + Math.imul(ah6, bh1) | 0;
        lo3 = lo3 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi4 = hi4 + Math.imul(ah5, bh2) | 0;
        lo3 = lo3 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi4 = hi4 + Math.imul(ah4, bh3) | 0;
        lo3 = lo3 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi4 = hi4 + Math.imul(ah3, bh4) | 0;
        lo3 = lo3 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi4 = hi4 + Math.imul(ah2, bh5) | 0;
        lo3 = lo3 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi4 = hi4 + Math.imul(ah1, bh6) | 0;
        lo3 = lo3 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi4 = hi4 + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo3 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi4 = Math.imul(ah8, bh0);
        lo3 = lo3 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi4 = hi4 + Math.imul(ah7, bh1) | 0;
        lo3 = lo3 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi4 = hi4 + Math.imul(ah6, bh2) | 0;
        lo3 = lo3 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi4 = hi4 + Math.imul(ah5, bh3) | 0;
        lo3 = lo3 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi4 = hi4 + Math.imul(ah4, bh4) | 0;
        lo3 = lo3 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi4 = hi4 + Math.imul(ah3, bh5) | 0;
        lo3 = lo3 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi4 = hi4 + Math.imul(ah2, bh6) | 0;
        lo3 = lo3 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi4 = hi4 + Math.imul(ah1, bh7) | 0;
        lo3 = lo3 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi4 = hi4 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo3 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi4 = Math.imul(ah9, bh0);
        lo3 = lo3 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi4 = hi4 + Math.imul(ah8, bh1) | 0;
        lo3 = lo3 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi4 = hi4 + Math.imul(ah7, bh2) | 0;
        lo3 = lo3 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi4 = hi4 + Math.imul(ah6, bh3) | 0;
        lo3 = lo3 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi4 = hi4 + Math.imul(ah5, bh4) | 0;
        lo3 = lo3 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi4 = hi4 + Math.imul(ah4, bh5) | 0;
        lo3 = lo3 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi4 = hi4 + Math.imul(ah3, bh6) | 0;
        lo3 = lo3 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi4 = hi4 + Math.imul(ah2, bh7) | 0;
        lo3 = lo3 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi4 = hi4 + Math.imul(ah1, bh8) | 0;
        lo3 = lo3 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi4 = hi4 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo3 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi4 = Math.imul(ah9, bh1);
        lo3 = lo3 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi4 = hi4 + Math.imul(ah8, bh2) | 0;
        lo3 = lo3 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi4 = hi4 + Math.imul(ah7, bh3) | 0;
        lo3 = lo3 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi4 = hi4 + Math.imul(ah6, bh4) | 0;
        lo3 = lo3 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi4 = hi4 + Math.imul(ah5, bh5) | 0;
        lo3 = lo3 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi4 = hi4 + Math.imul(ah4, bh6) | 0;
        lo3 = lo3 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi4 = hi4 + Math.imul(ah3, bh7) | 0;
        lo3 = lo3 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi4 = hi4 + Math.imul(ah2, bh8) | 0;
        lo3 = lo3 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi4 = hi4 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo3 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi4 = Math.imul(ah9, bh2);
        lo3 = lo3 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi4 = hi4 + Math.imul(ah8, bh3) | 0;
        lo3 = lo3 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi4 = hi4 + Math.imul(ah7, bh4) | 0;
        lo3 = lo3 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi4 = hi4 + Math.imul(ah6, bh5) | 0;
        lo3 = lo3 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi4 = hi4 + Math.imul(ah5, bh6) | 0;
        lo3 = lo3 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi4 = hi4 + Math.imul(ah4, bh7) | 0;
        lo3 = lo3 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi4 = hi4 + Math.imul(ah3, bh8) | 0;
        lo3 = lo3 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi4 = hi4 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo3 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi4 = Math.imul(ah9, bh3);
        lo3 = lo3 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi4 = hi4 + Math.imul(ah8, bh4) | 0;
        lo3 = lo3 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi4 = hi4 + Math.imul(ah7, bh5) | 0;
        lo3 = lo3 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi4 = hi4 + Math.imul(ah6, bh6) | 0;
        lo3 = lo3 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi4 = hi4 + Math.imul(ah5, bh7) | 0;
        lo3 = lo3 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi4 = hi4 + Math.imul(ah4, bh8) | 0;
        lo3 = lo3 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi4 = hi4 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo3 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi4 = Math.imul(ah9, bh4);
        lo3 = lo3 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi4 = hi4 + Math.imul(ah8, bh5) | 0;
        lo3 = lo3 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi4 = hi4 + Math.imul(ah7, bh6) | 0;
        lo3 = lo3 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi4 = hi4 + Math.imul(ah6, bh7) | 0;
        lo3 = lo3 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi4 = hi4 + Math.imul(ah5, bh8) | 0;
        lo3 = lo3 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi4 = hi4 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo3 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi4 = Math.imul(ah9, bh5);
        lo3 = lo3 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi4 = hi4 + Math.imul(ah8, bh6) | 0;
        lo3 = lo3 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi4 = hi4 + Math.imul(ah7, bh7) | 0;
        lo3 = lo3 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi4 = hi4 + Math.imul(ah6, bh8) | 0;
        lo3 = lo3 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi4 = hi4 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo3 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi4 = Math.imul(ah9, bh6);
        lo3 = lo3 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi4 = hi4 + Math.imul(ah8, bh7) | 0;
        lo3 = lo3 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi4 = hi4 + Math.imul(ah7, bh8) | 0;
        lo3 = lo3 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi4 = hi4 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo3 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi4 = Math.imul(ah9, bh7);
        lo3 = lo3 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi4 = hi4 + Math.imul(ah8, bh8) | 0;
        lo3 = lo3 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi4 = hi4 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo3 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi4 = Math.imul(ah9, bh8);
        lo3 = lo3 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi4 = hi4 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo3 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi4 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c5 !== 0) {
          o4[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k4 = 0; k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j4 = Math.max(0, k4 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k4 - j4;
            var a5 = self2.words[i4] | 0;
            var b6 = num.words[j4] | 0;
            var r3 = a5 * b6;
            var lo3 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo3 = lo3 + rword | 0;
            rword = lo3 & 67108863;
            ncarry = ncarry + (lo3 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k4] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k4] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x9, y7) {
        this.x = x9;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t = new Array(N3);
        var l4 = BN.prototype._countBits(N3) - 1;
        for (var i4 = 0; i4 < N3; i4++) {
          t[i4] = this.revBin(i4, l4, N3);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x9, l4, N3) {
        if (x9 === 0 || x9 === N3 - 1)
          return x9;
        var rb = 0;
        for (var i4 = 0; i4 < l4; i4++) {
          rb |= (x9 & 1) << l4 - i4 - 1;
          x9 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i4 = 0; i4 < N3; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s2 = 1; s2 < N3; s2 <<= 1) {
          var l4 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l4);
          var itwdf = Math.sin(2 * Math.PI / l4);
          for (var p4 = 0; p4 < N3; p4 += l4) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s2; j4++) {
              var re5 = rtws[p4 + j4];
              var ie5 = itws[p4 + j4];
              var ro3 = rtws[p4 + j4 + s2];
              var io2 = itws[p4 + j4 + s2];
              var rx = rtwdf_ * ro3 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p4 + j4] = re5 + ro3;
              itws[p4 + j4] = ie5 + io2;
              rtws[p4 + j4 + s2] = re5 - ro3;
              itws[p4 + j4 + s2] = ie5 - io2;
              if (j4 !== l4) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m) {
        var N3 = Math.max(m, n4) | 1;
        var odd = N3 & 1;
        var i4 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var t = rws[i4];
          rws[i4] = rws[N3 - i4 - 1];
          rws[N3 - i4 - 1] = t;
          t = iws[i4];
          iws[i4] = -iws[N3 - i4 - 1];
          iws[N3 - i4 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var w5 = Math.round(ws3[2 * i4 + 1] / N3) * 8192 + Math.round(ws3[2 * i4] / N3) + carry;
          ws3[i4] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws3[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N3; ++i4) {
          rws[i4] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i4 = 0; i4 < N3; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x9, y7, out) {
        var N3 = 2 * this.guessLen13b(x9.length, y7.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x9.words, x9.length, rws, N3);
        this.convert13b(y7.words, y7.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i4 = 0; i4 < N3; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x9.negative ^ y7.negative;
        out.length = x9.length + y7.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w5 = (this.words[i4] | 0) * num;
          var lo3 = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo3 >>> 26;
          this.words[i4] = lo3 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN(1);
        var res = this;
        for (var i4 = 0; i4 < w5.length; i4++, res = res.sqr()) {
          if (w5[i4] !== 0)
            break;
        }
        if (++i4 < w5.length) {
          for (var q5 = res.sqr(); i4 < w5.length; i4++, q5 = q5.sqr()) {
            if (w5[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i4;
        if (r3 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c5 = (this.words[i4] | 0) - newCarry << r3;
            this.words[i4] = c5 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h6 -= s2;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h6); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q5 = 1 << r3;
        if (this.length <= s2)
          return false;
        var w5 = this.words[s2];
        return !!(w5 & q5);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w5 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w5 = -(this.words[i4] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b6 = num;
        var bhi = b6.words[b6.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b6 = b6.ushln(shift);
          a5.iushln(shift);
          bhi = b6.words[b6.length - 1] | 0;
        }
        var m = a5.length - b6.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN(null);
          q5.length = m + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b6, 1, m);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m] = 1;
          }
        }
        for (var j4 = m - 1; j4 >= 0; j4--) {
          var qj = (a5.words[b6.length + j4] | 0) * 67108864 + (a5.words[b6.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b6, qj, j4);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b6, 1, j4);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p4 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p4 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w5 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var x9 = this;
        var y7 = p4.clone();
        if (x9.negative !== 0) {
          x9 = x9.umod(p4);
        } else {
          x9 = x9.clone();
        }
        var A5 = new BN(1);
        var B6 = new BN(0);
        var C7 = new BN(0);
        var D4 = new BN(1);
        var g6 = 0;
        while (x9.isEven() && y7.isEven()) {
          x9.iushrn(1);
          y7.iushrn(1);
          ++g6;
        }
        var yp = y7.clone();
        var xp = x9.clone();
        while (!x9.isZero()) {
          for (var i4 = 0, im = 1; (x9.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x9.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B6.isOdd()) {
                A5.iadd(yp);
                B6.isub(xp);
              }
              A5.iushrn(1);
              B6.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y7.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y7.iushrn(j4);
            while (j4-- > 0) {
              if (C7.isOdd() || D4.isOdd()) {
                C7.iadd(yp);
                D4.isub(xp);
              }
              C7.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x9.cmp(y7) >= 0) {
            x9.isub(y7);
            A5.isub(C7);
            B6.isub(D4);
          } else {
            y7.isub(x9);
            C7.isub(A5);
            D4.isub(B6);
          }
        }
        return {
          a: C7,
          b: D4,
          gcd: y7.iushln(g6)
        };
      };
      BN.prototype._invmp = function _invmp(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var a5 = this;
        var b6 = p4.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p4);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b6.clone();
        while (a5.cmpn(1) > 0 && b6.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a5.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b6.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b6.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b6) >= 0) {
            a5.isub(b6);
            x1.isub(x22);
          } else {
            b6.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p4);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b6 = num.clone();
        a5.negative = 0;
        b6.negative = 0;
        for (var shift = 0; a5.isEven() && b6.isEven(); shift++) {
          a5.iushrn(1);
          b6.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b6.isEven()) {
            b6.iushrn(1);
          }
          var r3 = a5.cmp(b6);
          if (r3 < 0) {
            var t = a5;
            a5 = b6;
            b6 = t;
          } else if (r3 === 0 || b6.cmpn(1) === 0) {
            break;
          }
          a5.isub(b6);
        } while (true);
        return b6.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q5 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w5 = this.words[i4] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i4] = w5;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a5 = this.words[i4] | 0;
          var b6 = num.words[i4] | 0;
          if (a5 === b6)
            continue;
          if (a5 < b6) {
            res = -1;
          } else if (a5 > b6) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt7(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt5(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p4) {
        this.name = name;
        this.p = new BN(p4, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo3 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w5 = num.words[i4] | 0;
          lo3 += w5 * 977;
          num.words[i4] = lo3 & 67108863;
          lo3 = w5 * 64 + (lo3 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi4 = (num.words[i4] | 0) * 19 + carry;
          var lo3 = hi4 & 67108863;
          hi4 >>>= 26;
          num.words[i4] = lo3;
          carry = hi4;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert(a5.negative === 0, "red works only with positives");
        assert(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b6) {
        assert((a5.negative | b6.negative) === 0, "red works only with positives");
        assert(
          a5.red && a5.red === b6.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.add(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.iadd(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.sub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.isub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b6) {
        this._verify2(a5, b6);
        return this.imod(a5.imul(b6));
      };
      Red.prototype.mul = function mul(a5, b6) {
        this._verify2(a5, b6);
        return this.imod(a5.mul(b6));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s2 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s2++;
          q5.iushrn(1);
        }
        assert(!q5.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z8 = this.m.bitLength();
        z8 = new BN(2 * z8 * z8).toRed(this);
        while (this.pow(z8, lpow).cmp(nOne) !== 0) {
          z8.redIAdd(nOne);
        }
        var c5 = this.pow(z8, q5);
        var r3 = this.pow(a5, q5.addn(1).iushrn(1));
        var t = this.pow(a5, q5);
        var m = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert(i4 < m);
          var b6 = this.pow(c5, new BN(1).iushln(m - i4 - 1));
          r3 = r3.redMul(b6);
          c5 = b6.redSqr();
          t = t.redMul(c5);
          m = i4;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a5;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a5, b6) {
        if (a5.isZero() || b6.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t = a5.imul(b6);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b6) {
        if (a5.isZero() || b6.isZero())
          return new BN(0)._forceRed(this);
        var t = a5.mul(b6);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w5, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i4;
      for (i4 = 0; i4 < naf.length; i4 += 1) {
        naf[i4] = 0;
      }
      var ws3 = 1 << w5 + 1;
      var k4 = num.clone();
      for (i4 = 0; i4 < naf.length; i4++) {
        var z8;
        var mod = k4.andln(ws3 - 1);
        if (k4.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z8 = (ws3 >> 1) - mod;
          else
            z8 = mod;
          k4.isubn(z8);
        } else {
          z8 = 0;
        }
        naf[i4] = z8;
        k4.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p4, k4) {
      assert(p4.precomputed);
      var doubles = p4._getDoubles();
      var naf = getNAF(k4, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j4;
      var nafW;
      for (j4 = 0; j4 < naf.length; j4 += doubles.step) {
        nafW = 0;
        for (var l4 = j4 + doubles.step - 1; l4 >= j4; l4--)
          nafW = (nafW << 1) + naf[l4];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b6 = this.jpoint(null, null, null);
      for (var i4 = I5; i4 > 0; i4--) {
        for (j4 = 0; j4 < repr.length; j4++) {
          nafW = repr[j4];
          if (nafW === i4)
            b6 = b6.mixedAdd(doubles.points[j4]);
          else if (nafW === -i4)
            b6 = b6.mixedAdd(doubles.points[j4].neg());
        }
        a5 = a5.add(b6);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p4, k4) {
      var w5 = 4;
      var nafPoints = p4._getNAFPoints(w5);
      w5 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k4, w5, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i4 = naf.length - 1; i4 >= 0; i4--) {
        for (var l4 = 0; i4 >= 0 && naf[i4] === 0; i4--)
          l4++;
        if (i4 >= 0)
          l4++;
        acc = acc.dblp(l4);
        if (i4 < 0)
          break;
        var z8 = naf[i4];
        assert(z8 !== 0);
        if (p4.type === "affine") {
          if (z8 > 0)
            acc = acc.mixedAdd(wnd[z8 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z8 - 1 >> 1].neg());
        } else {
          if (z8 > 0)
            acc = acc.add(wnd[z8 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z8 - 1 >> 1].neg());
        }
      }
      return p4.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i4;
      var j4;
      var p4;
      for (i4 = 0; i4 < len; i4++) {
        p4 = points[i4];
        var nafPoints = p4._getNAFPoints(defW);
        wndWidth[i4] = nafPoints.wnd;
        wnd[i4] = nafPoints.points;
      }
      for (i4 = len - 1; i4 >= 1; i4 -= 2) {
        var a5 = i4 - 1;
        var b6 = i4;
        if (wndWidth[a5] !== 1 || wndWidth[b6] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b6] = getNAF(coeffs[b6], wndWidth[b6], this._bitLength);
          max = Math.max(naf[a5].length, max);
          max = Math.max(naf[b6].length, max);
          continue;
        }
        var comb = [
          points[a5],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b6]
          /* 7 */
        ];
        if (points[a5].y.cmp(points[b6].y) === 0) {
          comb[1] = points[a5].add(points[b6]);
          comb[2] = points[a5].toJ().mixedAdd(points[b6].neg());
        } else if (points[a5].y.cmp(points[b6].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b6]);
          comb[2] = points[a5].add(points[b6].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b6]);
          comb[2] = points[a5].toJ().mixedAdd(points[b6].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b6]);
        max = Math.max(jsf[0].length, max);
        naf[a5] = new Array(max);
        naf[b6] = new Array(max);
        for (j4 = 0; j4 < max; j4++) {
          var ja = jsf[0][j4] | 0;
          var jb = jsf[1][j4] | 0;
          naf[a5][j4] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b6][j4] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i4 = max; i4 >= 0; i4--) {
        var k4 = 0;
        while (i4 >= 0) {
          var zero = true;
          for (j4 = 0; j4 < len; j4++) {
            tmp[j4] = naf[j4][i4] | 0;
            if (tmp[j4] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k4++;
          i4--;
        }
        if (i4 >= 0)
          k4++;
        acc = acc.dblp(k4);
        if (i4 < 0)
          break;
        for (j4 = 0; j4 < len; j4++) {
          var z8 = tmp[j4];
          p4;
          if (z8 === 0)
            continue;
          else if (z8 > 0)
            p4 = wnd[j4][z8 - 1 >> 1];
          else if (z8 < 0)
            p4 = wnd[j4][-z8 - 1 >> 1].neg();
          if (p4.type === "affine")
            acc = acc.mixedAdd(p4);
          else
            acc = acc.add(p4);
        }
      }
      for (i4 = 0; i4 < len; i4++)
        wnd[i4] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x9 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x9);
      return [4].concat(x9, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k4) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k4.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i4 = 0; i4 < power; i4 += step) {
        for (var j4 = 0; j4 < step; j4++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i4 = 1; i4 < max; i4++)
        res[i4] = res[i4 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k4) {
      var r3 = this;
      for (var i4 = 0; i4 < k4; i4++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v8 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i4 = 0;
      var r3;
      var x9;
      while (u4.cmpn(0) !== 0) {
        var q5 = v8.div(u4);
        r3 = v8.sub(q5.mul(u4));
        x9 = x22.sub(q5.mul(x1));
        var y7 = y22.sub(q5.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x9;
        } else if (a1 && ++i4 === 2) {
          break;
        }
        prevR = r3;
        v8 = u4;
        u4 = r3;
        x22 = x1;
        x1 = x9;
        y22 = y1;
        y1 = y7;
      }
      a22 = r3.neg();
      b22 = x9;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k4) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k4).divRound(this.n);
      var c22 = v1.b.neg().mul(k4).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k4.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x9, odd) {
      x9 = new BN(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var y22 = x9.redSqr().redMul(x9).redIAdd(x9.redMul(this.a)).redIAdd(this.b);
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x9 = point.x;
      var y7 = point.y;
      var ax = this.a.redMul(x9);
      var rhs = x9.redSqr().redMul(x9).redIAdd(ax).redIAdd(this.b);
      return y7.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i4 = 0; i4 < points.length; i4++) {
        var split = this._endoSplit(coeffs[i4]);
        var p4 = points[i4];
        var beta = p4._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p4 = p4.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i4 * 2] = p4;
        npoints[i4 * 2 + 1] = beta;
        ncoeffs[i4 * 2] = split.k1;
        ncoeffs[i4 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
      for (var j4 = 0; j4 < i4 * 2; j4++) {
        npoints[j4] = null;
        ncoeffs[j4] = null;
      }
      return res;
    };
    function Point(curve, x9, y7, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x9 === null && y7 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x9, y7, isRed) {
      return new Point(this, x9, y7, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p4) {
          return curve.point(p4.x.redMul(curve.endo.beta), p4.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p4) {
      if (this.inf)
        return p4;
      if (p4.inf)
        return this;
      if (this.eq(p4))
        return this.dbl();
      if (this.neg().eq(p4))
        return this.curve.point(null, null);
      if (this.x.cmp(p4.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p4.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p4.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p4.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k4) {
      k4 = new BN(k4, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k4]);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p4) {
      return this === p4 || this.inf === p4.inf && (this.inf || this.x.cmp(p4.x) === 0 && this.y.cmp(p4.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p4) {
          return p4.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x9, y7, z8) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x9 === null && y7 === null && z8 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        this.z = new BN(z8, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x9, y7, z8) {
      return new JPoint(this, x9, y7, z8);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      var pz2 = p4.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p4.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p4.z));
      var s2 = p4.y.redMul(z22.redMul(this.z));
      var h6 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h6.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v8 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r3.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p4.z).redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p4) {
      if (this.isInfinity())
        return p4.toJ();
      if (p4.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p4.x.redMul(z22);
      var s1 = this.y;
      var s2 = p4.y.redMul(z22).redMul(this.z);
      var h6 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h6.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v8 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r3.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i4 = 0; i4 < pow; i4++)
          r3 = r3.dbl();
        return r3;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i4 = 0; i4 < pow; i4++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c5.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i4 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b6 = this.y.redSqr();
        var c5 = b6.redSqr();
        var d5 = this.x.redAdd(b6).redSqr().redISub(a5).redISub(c5);
        d5 = d5.redIAdd(d5);
        var e = a5.redAdd(a5).redIAdd(a5);
        var f5 = e.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d5).redISub(d5);
        ny = e.redMul(d5.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee6 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u4 = m.redIAdd(e).redSqr().redISub(mm).redISub(ee6).redISub(t);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee6).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t.redISub(u4)).redISub(e.redMul(ee6)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k4, kbase) {
      k4 = new BN(k4, kbase);
      return this.curve._wnafMul(this, k4);
    };
    JPoint.prototype.eq = function eq(p4) {
      if (p4.type === "affine")
        return this.eq(p4.toJ());
      if (this === p4)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p4.z.redSqr();
      if (this.x.redMul(pz2).redISub(p4.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p4.z);
      return this.y.redMul(pz3).redISub(p4.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x9) {
      var zs4 = this.z.redSqr();
      var rx = x9.toRed(this.curve.red).redMul(zs4);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t = this.curve.redN.redMul(zs4);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x9 = point.normalize().x;
      var x22 = x9.redSqr();
      var rhs = x22.redMul(x9).redAdd(x22.redMul(this.a)).redAdd(x9);
      var y7 = rhs.redSqrt();
      return y7.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x9, z8) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && z8 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x9, 16);
        this.z = new BN(z8, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x9, z8) {
      return new Point(this, x9, z8);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b6 = this.x.redSub(this.z);
      var bb = b6.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p4, diff) {
      var a5 = this.x.redAdd(this.z);
      var b6 = this.x.redSub(this.z);
      var c5 = p4.x.redAdd(p4.z);
      var d5 = p4.x.redSub(p4.z);
      var da = d5.redMul(a5);
      var cb = c5.redMul(b6);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k4) {
      var t = k4.clone();
      var a5 = this;
      var b6 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i4 = bits.length - 1; i4 >= 0; i4--) {
        if (bits[i4] === 0) {
          a5 = a5.diffAdd(b6, c5);
          b6 = b6.dbl();
        } else {
          b6 = a5.diffAdd(b6, c5);
          a5 = a5.dbl();
        }
      }
      return b6;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x9, y7, z8, t) {
      return this.point(x9, y7, z8, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x9, odd) {
      x9 = new BN(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var x22 = x9.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y7, odd) {
      y7 = new BN(y7, 16);
      if (!y7.red)
        y7 = y7.toRed(this.red);
      var y22 = y7.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y7);
      }
      var x9 = x22.redSqrt();
      if (x9.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x9.fromRed().isOdd() !== odd)
        x9 = x9.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x9, y7, z8, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && y7 === null && z8 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        this.z = z8 ? new BN(z8, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x9, y7, z8, t) {
      return new Point(this, x9, y7, z8, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b6 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d5 = this.curve._mulA(a5);
      var e = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b6);
      var g6 = d5.redAdd(b6);
      var f5 = g6.redSub(c5);
      var h6 = d5.redSub(b6);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h6);
      var nt5 = e.redMul(h6);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b6 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d5 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h6;
      var j4;
      if (this.curve.twisted) {
        e = this.curve._mulA(c5);
        var f5 = e.redAdd(d5);
        if (this.zOne) {
          nx = b6.redSub(c5).redSub(d5).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e.redSub(d5));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h6 = this.z.redSqr();
          j4 = f5.redSub(h6).redISub(h6);
          nx = b6.redSub(c5).redISub(d5).redMul(j4);
          ny = f5.redMul(e.redSub(d5));
          nz = f5.redMul(j4);
        }
      } else {
        e = c5.redAdd(d5);
        h6 = this.curve._mulC(this.z).redSqr();
        j4 = e.redSub(h6).redSub(h6);
        nx = this.curve._mulC(b6.redISub(e)).redMul(j4);
        ny = this.curve._mulC(e).redMul(c5.redISub(d5));
        nz = e.redMul(j4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p4) {
      var a5 = this.y.redSub(this.x).redMul(p4.y.redSub(p4.x));
      var b6 = this.y.redAdd(this.x).redMul(p4.y.redAdd(p4.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p4.t);
      var d5 = this.z.redMul(p4.z.redAdd(p4.z));
      var e = b6.redSub(a5);
      var f5 = d5.redSub(c5);
      var g6 = d5.redAdd(c5);
      var h6 = b6.redAdd(a5);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h6);
      var nt5 = e.redMul(h6);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projAdd = function _projAdd(p4) {
      var a5 = this.z.redMul(p4.z);
      var b6 = a5.redSqr();
      var c5 = this.x.redMul(p4.x);
      var d5 = this.y.redMul(p4.y);
      var e = this.curve.d.redMul(c5).redMul(d5);
      var f5 = b6.redSub(e);
      var g6 = b6.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p4.x.redAdd(p4.y)).redISub(c5).redISub(d5);
      var nx = a5.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g6).redMul(d5.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g6);
      } else {
        ny = a5.redMul(g6).redMul(d5.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p4);
      else
        return this._projAdd(p4);
    };
    Point.prototype.mul = function mul(k4) {
      if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x9) {
      var rx = x9.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p4) {
      var initial = buf[p4.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p4.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i4 = 0, off = p4.place; i4 < octetLen; i4++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p4.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i4 = 0;
      var len = buf.length - 1;
      while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
        i4++;
      }
      if (i4 === 0) {
        return buf;
      }
      return buf.slice(i4);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p4 = new Position();
      if (data[p4.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p4);
      if (len === false) {
        return false;
      }
      if (len + p4.place !== data.length) {
        return false;
      }
      if (data[p4.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p4);
      if (rlen === false) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p4.place, rlen + p4.place);
      p4.place += rlen;
      if (data[p4.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p4);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p4.place) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p4.place, slen + p4.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert(msg.length >>> 0 === msg.length);
        for (var i4 = 0; i4 < msg.length; i4++)
          assert((msg[i4] & 255) === msg[i4]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k4 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k4 = this._truncateToN(k4, true);
        if (k4.cmpn(1) <= 0 || k4.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k4);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k4.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p4;
      if (!this.curve._maxwellTrick) {
        p4 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p4.isInfinity())
          return false;
        return p4.getX().umod(this.n).cmp(r3) === 0;
      }
      p4 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p4.isInfinity())
        return false;
      return p4.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j4, enc) {
      assert((3 & j4) === j4, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j4 & 1;
      var isSecondKey = j4 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i4 = 0; i4 < 4; i4++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i4);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i4;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S7() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R5() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R5 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R5);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S7 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R5, S: S7, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h6 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h6));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i4 = 0; i4 < arguments.length; i4++)
        hash2.update(arguments[i4]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y7 = utils.intFromLE(normed);
      return this.curve.pointFromY(y7, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i4 = left + 1; i4 < padLength - 8; i4++) {
              this._buffer[i4] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i4 = 0; i4 < this.digestLength / 8; i4++) {
            binary_1.writeUint32BE(this._stateHi[i4], out, i4 * 8);
            binary_1.writeUint32BE(this._stateLo[i4], out, i4 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K5 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h6, l4;
      var th, tl;
      var a5, b6, c5, d5;
      while (len >= 128) {
        for (var i4 = 0; i4 < 16; i4++) {
          var j4 = 8 * i4 + pos;
          wh[i4] = binary_1.readUint32BE(m, j4);
          wl[i4] = binary_1.readUint32BE(m, j4 + 4);
        }
        for (var i4 = 0; i4 < 80; i4++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h6 = ah7;
          l4 = al7;
          a5 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d5 = h6 >>> 16;
          h6 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l4 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          h6 = ah4 & ah5 ^ ~ah4 & ah6;
          l4 = al4 & al5 ^ ~al4 & al6;
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          h6 = K5[i4 * 2];
          l4 = K5[i4 * 2 + 1];
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          h6 = wh[i4 % 16];
          l4 = wl[i4 % 16];
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          b6 += a5 >>> 16;
          c5 += b6 >>> 16;
          d5 += c5 >>> 16;
          th = c5 & 65535 | d5 << 16;
          tl = a5 & 65535 | b6 << 16;
          h6 = th;
          l4 = tl;
          a5 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d5 = h6 >>> 16;
          h6 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l4 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          h6 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l4 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          b6 += a5 >>> 16;
          c5 += b6 >>> 16;
          d5 += c5 >>> 16;
          bh7 = c5 & 65535 | d5 << 16;
          bl7 = a5 & 65535 | b6 << 16;
          h6 = bh3;
          l4 = bl3;
          a5 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d5 = h6 >>> 16;
          h6 = th;
          l4 = tl;
          a5 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d5 += h6 >>> 16;
          b6 += a5 >>> 16;
          c5 += b6 >>> 16;
          d5 += c5 >>> 16;
          bh3 = c5 & 65535 | d5 << 16;
          bl3 = a5 & 65535 | b6 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i4 % 16 === 15) {
            for (var j4 = 0; j4 < 16; j4++) {
              h6 = wh[j4];
              l4 = wl[j4];
              a5 = l4 & 65535;
              b6 = l4 >>> 16;
              c5 = h6 & 65535;
              d5 = h6 >>> 16;
              h6 = wh[(j4 + 9) % 16];
              l4 = wl[(j4 + 9) % 16];
              a5 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d5 += h6 >>> 16;
              th = wh[(j4 + 1) % 16];
              tl = wl[(j4 + 1) % 16];
              h6 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l4 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a5 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d5 += h6 >>> 16;
              th = wh[(j4 + 14) % 16];
              tl = wl[(j4 + 14) % 16];
              h6 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l4 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a5 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d5 += h6 >>> 16;
              b6 += a5 >>> 16;
              c5 += b6 >>> 16;
              d5 += c5 >>> 16;
              wh[j4] = c5 & 65535 | d5 << 16;
              wl[j4] = a5 & 65535 | b6 << 16;
            }
          }
        }
        h6 = ah0;
        l4 = al0;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[0];
        l4 = hl[0];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[0] = ah0 = c5 & 65535 | d5 << 16;
        hl[0] = al0 = a5 & 65535 | b6 << 16;
        h6 = ah1;
        l4 = al1;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[1];
        l4 = hl[1];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[1] = ah1 = c5 & 65535 | d5 << 16;
        hl[1] = al1 = a5 & 65535 | b6 << 16;
        h6 = ah2;
        l4 = al2;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[2];
        l4 = hl[2];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[2] = ah2 = c5 & 65535 | d5 << 16;
        hl[2] = al2 = a5 & 65535 | b6 << 16;
        h6 = ah3;
        l4 = al3;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[3];
        l4 = hl[3];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[3] = ah3 = c5 & 65535 | d5 << 16;
        hl[3] = al3 = a5 & 65535 | b6 << 16;
        h6 = ah4;
        l4 = al4;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[4];
        l4 = hl[4];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[4] = ah4 = c5 & 65535 | d5 << 16;
        hl[4] = al4 = a5 & 65535 | b6 << 16;
        h6 = ah5;
        l4 = al5;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[5];
        l4 = hl[5];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[5] = ah5 = c5 & 65535 | d5 << 16;
        hl[5] = al5 = a5 & 65535 | b6 << 16;
        h6 = ah6;
        l4 = al6;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[6];
        l4 = hl[6];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[6] = ah6 = c5 & 65535 | d5 << 16;
        hl[6] = al6 = a5 & 65535 | b6 << 16;
        h6 = ah7;
        l4 = al7;
        a5 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d5 = h6 >>> 16;
        h6 = hh[7];
        l4 = hl[7];
        a5 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d5 += h6 >>> 16;
        b6 += a5 >>> 16;
        c5 += b6 >>> 16;
        d5 += c5 >>> 16;
        hh[7] = ah7 = c5 & 65535 | d5 << 16;
        hl[7] = al7 = a5 & 65535 | b6 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h6 = new SHA512();
      h6.update(data);
      var digest = h6.digest();
      h6.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r3 = new Float64Array(16);
      if (init) {
        for (let i4 = 0; i4 < init.length; i4++) {
          r3[i4] = init[i4];
        }
      }
      return r3;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D4 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X4 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y4 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I5 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r3, a5) {
      for (let i4 = 0; i4 < 16; i4++) {
        r3[i4] = a5[i4] | 0;
      }
    }
    function car25519(o4) {
      let c5 = 1;
      for (let i4 = 0; i4 < 16; i4++) {
        let v8 = o4[i4] + c5 + 65535;
        c5 = Math.floor(v8 / 65536);
        o4[i4] = v8 - c5 * 65536;
      }
      o4[0] += c5 - 1 + 37 * (c5 - 1);
    }
    function sel25519(p4, q5, b6) {
      const c5 = ~(b6 - 1);
      for (let i4 = 0; i4 < 16; i4++) {
        const t = c5 & (p4[i4] ^ q5[i4]);
        p4[i4] ^= t;
        q5[i4] ^= t;
      }
    }
    function pack25519(o4, n4) {
      const m = gf();
      const t = gf();
      for (let i4 = 0; i4 < 16; i4++) {
        t[i4] = n4[i4];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j4 = 0; j4 < 2; j4++) {
        m[0] = t[0] - 65517;
        for (let i4 = 1; i4 < 15; i4++) {
          m[i4] = t[i4] - 65535 - (m[i4 - 1] >> 16 & 1);
          m[i4 - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        const b6 = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b6);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o4[2 * i4] = t[i4] & 255;
        o4[2 * i4 + 1] = t[i4] >> 8;
      }
    }
    function verify32(x9, y7) {
      let d5 = 0;
      for (let i4 = 0; i4 < 32; i4++) {
        d5 |= x9[i4] ^ y7[i4];
      }
      return (1 & d5 - 1 >>> 8) - 1;
    }
    function neq25519(a5, b6) {
      const c5 = new Uint8Array(32);
      const d5 = new Uint8Array(32);
      pack25519(c5, a5);
      pack25519(d5, b6);
      return verify32(c5, d5);
    }
    function par25519(a5) {
      const d5 = new Uint8Array(32);
      pack25519(d5, a5);
      return d5[0] & 1;
    }
    function unpack25519(o4, n4) {
      for (let i4 = 0; i4 < 16; i4++) {
        o4[i4] = n4[2 * i4] + (n4[2 * i4 + 1] << 8);
      }
      o4[15] &= 32767;
    }
    function add(o4, a5, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o4[i4] = a5[i4] + b6[i4];
      }
    }
    function sub(o4, a5, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o4[i4] = a5[i4] - b6[i4];
      }
    }
    function mul(o4, a5, b6) {
      let v8, c5, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b6[0], b1 = b6[1], b22 = b6[2], b32 = b6[3], b42 = b6[4], b52 = b6[5], b62 = b6[6], b7 = b6[7], b8 = b6[8], b9 = b6[9], b10 = b6[10], b11 = b6[11], b12 = b6[12], b13 = b6[13], b14 = b6[14], b15 = b6[15];
      v8 = a5[0];
      t0 += v8 * b0;
      t1 += v8 * b1;
      t2 += v8 * b22;
      t3 += v8 * b32;
      t4 += v8 * b42;
      t5 += v8 * b52;
      t6 += v8 * b62;
      t7 += v8 * b7;
      t8 += v8 * b8;
      t9 += v8 * b9;
      t10 += v8 * b10;
      t11 += v8 * b11;
      t12 += v8 * b12;
      t13 += v8 * b13;
      t14 += v8 * b14;
      t15 += v8 * b15;
      v8 = a5[1];
      t1 += v8 * b0;
      t2 += v8 * b1;
      t3 += v8 * b22;
      t4 += v8 * b32;
      t5 += v8 * b42;
      t6 += v8 * b52;
      t7 += v8 * b62;
      t8 += v8 * b7;
      t9 += v8 * b8;
      t10 += v8 * b9;
      t11 += v8 * b10;
      t12 += v8 * b11;
      t13 += v8 * b12;
      t14 += v8 * b13;
      t15 += v8 * b14;
      t16 += v8 * b15;
      v8 = a5[2];
      t2 += v8 * b0;
      t3 += v8 * b1;
      t4 += v8 * b22;
      t5 += v8 * b32;
      t6 += v8 * b42;
      t7 += v8 * b52;
      t8 += v8 * b62;
      t9 += v8 * b7;
      t10 += v8 * b8;
      t11 += v8 * b9;
      t12 += v8 * b10;
      t13 += v8 * b11;
      t14 += v8 * b12;
      t15 += v8 * b13;
      t16 += v8 * b14;
      t17 += v8 * b15;
      v8 = a5[3];
      t3 += v8 * b0;
      t4 += v8 * b1;
      t5 += v8 * b22;
      t6 += v8 * b32;
      t7 += v8 * b42;
      t8 += v8 * b52;
      t9 += v8 * b62;
      t10 += v8 * b7;
      t11 += v8 * b8;
      t12 += v8 * b9;
      t13 += v8 * b10;
      t14 += v8 * b11;
      t15 += v8 * b12;
      t16 += v8 * b13;
      t17 += v8 * b14;
      t18 += v8 * b15;
      v8 = a5[4];
      t4 += v8 * b0;
      t5 += v8 * b1;
      t6 += v8 * b22;
      t7 += v8 * b32;
      t8 += v8 * b42;
      t9 += v8 * b52;
      t10 += v8 * b62;
      t11 += v8 * b7;
      t12 += v8 * b8;
      t13 += v8 * b9;
      t14 += v8 * b10;
      t15 += v8 * b11;
      t16 += v8 * b12;
      t17 += v8 * b13;
      t18 += v8 * b14;
      t19 += v8 * b15;
      v8 = a5[5];
      t5 += v8 * b0;
      t6 += v8 * b1;
      t7 += v8 * b22;
      t8 += v8 * b32;
      t9 += v8 * b42;
      t10 += v8 * b52;
      t11 += v8 * b62;
      t12 += v8 * b7;
      t13 += v8 * b8;
      t14 += v8 * b9;
      t15 += v8 * b10;
      t16 += v8 * b11;
      t17 += v8 * b12;
      t18 += v8 * b13;
      t19 += v8 * b14;
      t20 += v8 * b15;
      v8 = a5[6];
      t6 += v8 * b0;
      t7 += v8 * b1;
      t8 += v8 * b22;
      t9 += v8 * b32;
      t10 += v8 * b42;
      t11 += v8 * b52;
      t12 += v8 * b62;
      t13 += v8 * b7;
      t14 += v8 * b8;
      t15 += v8 * b9;
      t16 += v8 * b10;
      t17 += v8 * b11;
      t18 += v8 * b12;
      t19 += v8 * b13;
      t20 += v8 * b14;
      t21 += v8 * b15;
      v8 = a5[7];
      t7 += v8 * b0;
      t8 += v8 * b1;
      t9 += v8 * b22;
      t10 += v8 * b32;
      t11 += v8 * b42;
      t12 += v8 * b52;
      t13 += v8 * b62;
      t14 += v8 * b7;
      t15 += v8 * b8;
      t16 += v8 * b9;
      t17 += v8 * b10;
      t18 += v8 * b11;
      t19 += v8 * b12;
      t20 += v8 * b13;
      t21 += v8 * b14;
      t22 += v8 * b15;
      v8 = a5[8];
      t8 += v8 * b0;
      t9 += v8 * b1;
      t10 += v8 * b22;
      t11 += v8 * b32;
      t12 += v8 * b42;
      t13 += v8 * b52;
      t14 += v8 * b62;
      t15 += v8 * b7;
      t16 += v8 * b8;
      t17 += v8 * b9;
      t18 += v8 * b10;
      t19 += v8 * b11;
      t20 += v8 * b12;
      t21 += v8 * b13;
      t22 += v8 * b14;
      t23 += v8 * b15;
      v8 = a5[9];
      t9 += v8 * b0;
      t10 += v8 * b1;
      t11 += v8 * b22;
      t12 += v8 * b32;
      t13 += v8 * b42;
      t14 += v8 * b52;
      t15 += v8 * b62;
      t16 += v8 * b7;
      t17 += v8 * b8;
      t18 += v8 * b9;
      t19 += v8 * b10;
      t20 += v8 * b11;
      t21 += v8 * b12;
      t22 += v8 * b13;
      t23 += v8 * b14;
      t24 += v8 * b15;
      v8 = a5[10];
      t10 += v8 * b0;
      t11 += v8 * b1;
      t12 += v8 * b22;
      t13 += v8 * b32;
      t14 += v8 * b42;
      t15 += v8 * b52;
      t16 += v8 * b62;
      t17 += v8 * b7;
      t18 += v8 * b8;
      t19 += v8 * b9;
      t20 += v8 * b10;
      t21 += v8 * b11;
      t22 += v8 * b12;
      t23 += v8 * b13;
      t24 += v8 * b14;
      t25 += v8 * b15;
      v8 = a5[11];
      t11 += v8 * b0;
      t12 += v8 * b1;
      t13 += v8 * b22;
      t14 += v8 * b32;
      t15 += v8 * b42;
      t16 += v8 * b52;
      t17 += v8 * b62;
      t18 += v8 * b7;
      t19 += v8 * b8;
      t20 += v8 * b9;
      t21 += v8 * b10;
      t22 += v8 * b11;
      t23 += v8 * b12;
      t24 += v8 * b13;
      t25 += v8 * b14;
      t26 += v8 * b15;
      v8 = a5[12];
      t12 += v8 * b0;
      t13 += v8 * b1;
      t14 += v8 * b22;
      t15 += v8 * b32;
      t16 += v8 * b42;
      t17 += v8 * b52;
      t18 += v8 * b62;
      t19 += v8 * b7;
      t20 += v8 * b8;
      t21 += v8 * b9;
      t22 += v8 * b10;
      t23 += v8 * b11;
      t24 += v8 * b12;
      t25 += v8 * b13;
      t26 += v8 * b14;
      t27 += v8 * b15;
      v8 = a5[13];
      t13 += v8 * b0;
      t14 += v8 * b1;
      t15 += v8 * b22;
      t16 += v8 * b32;
      t17 += v8 * b42;
      t18 += v8 * b52;
      t19 += v8 * b62;
      t20 += v8 * b7;
      t21 += v8 * b8;
      t22 += v8 * b9;
      t23 += v8 * b10;
      t24 += v8 * b11;
      t25 += v8 * b12;
      t26 += v8 * b13;
      t27 += v8 * b14;
      t28 += v8 * b15;
      v8 = a5[14];
      t14 += v8 * b0;
      t15 += v8 * b1;
      t16 += v8 * b22;
      t17 += v8 * b32;
      t18 += v8 * b42;
      t19 += v8 * b52;
      t20 += v8 * b62;
      t21 += v8 * b7;
      t22 += v8 * b8;
      t23 += v8 * b9;
      t24 += v8 * b10;
      t25 += v8 * b11;
      t26 += v8 * b12;
      t27 += v8 * b13;
      t28 += v8 * b14;
      t29 += v8 * b15;
      v8 = a5[15];
      t15 += v8 * b0;
      t16 += v8 * b1;
      t17 += v8 * b22;
      t18 += v8 * b32;
      t19 += v8 * b42;
      t20 += v8 * b52;
      t21 += v8 * b62;
      t22 += v8 * b7;
      t23 += v8 * b8;
      t24 += v8 * b9;
      t25 += v8 * b10;
      t26 += v8 * b11;
      t27 += v8 * b12;
      t28 += v8 * b13;
      t29 += v8 * b14;
      t30 += v8 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c5 = 1;
      v8 = t0 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t0 = v8 - c5 * 65536;
      v8 = t1 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t1 = v8 - c5 * 65536;
      v8 = t2 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t2 = v8 - c5 * 65536;
      v8 = t3 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t3 = v8 - c5 * 65536;
      v8 = t4 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t4 = v8 - c5 * 65536;
      v8 = t5 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t5 = v8 - c5 * 65536;
      v8 = t6 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t6 = v8 - c5 * 65536;
      v8 = t7 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t7 = v8 - c5 * 65536;
      v8 = t8 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t8 = v8 - c5 * 65536;
      v8 = t9 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t9 = v8 - c5 * 65536;
      v8 = t10 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t10 = v8 - c5 * 65536;
      v8 = t11 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t11 = v8 - c5 * 65536;
      v8 = t12 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t12 = v8 - c5 * 65536;
      v8 = t13 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t13 = v8 - c5 * 65536;
      v8 = t14 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t14 = v8 - c5 * 65536;
      v8 = t15 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t15 = v8 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      c5 = 1;
      v8 = t0 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t0 = v8 - c5 * 65536;
      v8 = t1 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t1 = v8 - c5 * 65536;
      v8 = t2 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t2 = v8 - c5 * 65536;
      v8 = t3 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t3 = v8 - c5 * 65536;
      v8 = t4 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t4 = v8 - c5 * 65536;
      v8 = t5 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t5 = v8 - c5 * 65536;
      v8 = t6 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t6 = v8 - c5 * 65536;
      v8 = t7 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t7 = v8 - c5 * 65536;
      v8 = t8 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t8 = v8 - c5 * 65536;
      v8 = t9 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t9 = v8 - c5 * 65536;
      v8 = t10 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t10 = v8 - c5 * 65536;
      v8 = t11 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t11 = v8 - c5 * 65536;
      v8 = t12 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t12 = v8 - c5 * 65536;
      v8 = t13 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t13 = v8 - c5 * 65536;
      v8 = t14 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t14 = v8 - c5 * 65536;
      v8 = t15 + c5 + 65535;
      c5 = Math.floor(v8 / 65536);
      t15 = v8 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      o4[0] = t0;
      o4[1] = t1;
      o4[2] = t2;
      o4[3] = t3;
      o4[4] = t4;
      o4[5] = t5;
      o4[6] = t6;
      o4[7] = t7;
      o4[8] = t8;
      o4[9] = t9;
      o4[10] = t10;
      o4[11] = t11;
      o4[12] = t12;
      o4[13] = t13;
      o4[14] = t14;
      o4[15] = t15;
    }
    function square(o4, a5) {
      mul(o4, a5, a5);
    }
    function inv25519(o4, i4) {
      const c5 = gf();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c5[a5] = i4[a5];
      }
      for (a5 = 253; a5 >= 0; a5--) {
        square(c5, c5);
        if (a5 !== 2 && a5 !== 4) {
          mul(c5, c5, i4);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c5[a5];
      }
    }
    function pow2523(o4, i4) {
      const c5 = gf();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c5[a5] = i4[a5];
      }
      for (a5 = 250; a5 >= 0; a5--) {
        square(c5, c5);
        if (a5 !== 1) {
          mul(c5, c5, i4);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c5[a5];
      }
    }
    function edadd(p4, q5) {
      const a5 = gf(), b6 = gf(), c5 = gf(), d5 = gf(), e = gf(), f5 = gf(), g6 = gf(), h6 = gf(), t = gf();
      sub(a5, p4[1], p4[0]);
      sub(t, q5[1], q5[0]);
      mul(a5, a5, t);
      add(b6, p4[0], p4[1]);
      add(t, q5[0], q5[1]);
      mul(b6, b6, t);
      mul(c5, p4[3], q5[3]);
      mul(c5, c5, D22);
      mul(d5, p4[2], q5[2]);
      add(d5, d5, d5);
      sub(e, b6, a5);
      sub(f5, d5, c5);
      add(g6, d5, c5);
      add(h6, b6, a5);
      mul(p4[0], e, f5);
      mul(p4[1], h6, g6);
      mul(p4[2], g6, f5);
      mul(p4[3], e, h6);
    }
    function cswap(p4, q5, b6) {
      for (let i4 = 0; i4 < 4; i4++) {
        sel25519(p4[i4], q5[i4], b6);
      }
    }
    function pack(r3, p4) {
      const tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p4[2]);
      mul(tx, p4[0], zi2);
      mul(ty, p4[1], zi2);
      pack25519(r3, ty);
      r3[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p4, q5, s2) {
      set25519(p4[0], gf0);
      set25519(p4[1], gf1);
      set25519(p4[2], gf1);
      set25519(p4[3], gf0);
      for (let i4 = 255; i4 >= 0; --i4) {
        const b6 = s2[i4 / 8 | 0] >> (i4 & 7) & 1;
        cswap(p4, q5, b6);
        edadd(q5, p4);
        edadd(p4, p4);
        cswap(p4, q5, b6);
      }
    }
    function scalarbase(p4, s2) {
      const q5 = [gf(), gf(), gf(), gf()];
      set25519(q5[0], X4);
      set25519(q5[1], Y4);
      set25519(q5[2], gf1);
      mul(q5[3], X4, Y4);
      scalarmult(p4, q5, s2);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d5 = (0, sha512_1.hash)(seed);
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p4 = [gf(), gf(), gf(), gf()];
      scalarbase(p4, d5);
      pack(publicKey, p4);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L4 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r3, x9) {
      let carry;
      let i4;
      let j4;
      let k4;
      for (i4 = 63; i4 >= 32; --i4) {
        carry = 0;
        for (j4 = i4 - 32, k4 = i4 - 12; j4 < k4; ++j4) {
          x9[j4] += carry - 16 * x9[i4] * L4[j4 - (i4 - 32)];
          carry = Math.floor((x9[j4] + 128) / 256);
          x9[j4] -= carry * 256;
        }
        x9[j4] += carry;
        x9[i4] = 0;
      }
      carry = 0;
      for (j4 = 0; j4 < 32; j4++) {
        x9[j4] += carry - (x9[31] >> 4) * L4[j4];
        carry = x9[j4] >> 8;
        x9[j4] &= 255;
      }
      for (j4 = 0; j4 < 32; j4++) {
        x9[j4] -= carry * L4[j4];
      }
      for (i4 = 0; i4 < 32; i4++) {
        x9[i4 + 1] += x9[i4] >> 8;
        r3[i4] = x9[i4] & 255;
      }
    }
    function reduce(r3) {
      const x9 = new Float64Array(64);
      for (let i4 = 0; i4 < 64; i4++) {
        x9[i4] = r3[i4];
      }
      for (let i4 = 0; i4 < 64; i4++) {
        r3[i4] = 0;
      }
      modL(r3, x9);
    }
    function sign2(secretKey, message) {
      const x9 = new Float64Array(64);
      const p4 = [gf(), gf(), gf(), gf()];
      const d5 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d5.subarray(32), 32);
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(32));
      hs2.update(message);
      const r3 = hs2.digest();
      hs2.clean();
      reduce(r3);
      scalarbase(p4, r3);
      pack(signature, p4);
      hs2.reset();
      hs2.update(signature.subarray(0, 32));
      hs2.update(secretKey.subarray(32));
      hs2.update(message);
      const h6 = hs2.digest();
      reduce(h6);
      for (let i4 = 0; i4 < 32; i4++) {
        x9[i4] = r3[i4];
      }
      for (let i4 = 0; i4 < 32; i4++) {
        for (let j4 = 0; j4 < 32; j4++) {
          x9[i4 + j4] += h6[i4] * d5[j4];
        }
      }
      modL(signature.subarray(32), x9);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r3, p4) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r3[2], gf1);
      unpack25519(r3[1], p4);
      square(num, r3[1]);
      mul(den, num, D4);
      sub(num, num, r3[2]);
      add(den, r3[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r3[0], t, den);
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r3[0], r3[0], I5);
      }
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r3[0]) === p4[31] >> 7) {
        sub(r3[0], gf0, r3[0]);
      }
      mul(r3[3], r3[0], r3[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p4 = [gf(), gf(), gf(), gf()];
      const q5 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q5, publicKey)) {
        return false;
      }
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(0, 32));
      hs2.update(publicKey);
      hs2.update(message);
      const h6 = hs2.digest();
      reduce(h6);
      scalarmult(p4, q5, h6);
      scalarbase(q5, signature.subarray(32));
      edadd(p4, q5);
      pack(t, p4);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q5 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q5, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a5 = gf();
      let b6 = gf();
      let y7 = q5[1];
      add(a5, gf1, y7);
      sub(b6, gf1, y7);
      inv25519(b6, b6);
      mul(a5, a5, b6);
      let z8 = new Uint8Array(32);
      pack25519(z8, a5);
      return z8;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d5 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d5[0] &= 248;
      d5[31] &= 127;
      d5[31] |= 64;
      const o4 = new Uint8Array(d5.subarray(0, 32));
      (0, wipe_1.wipe)(d5);
      return o4;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json
var require_package2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.7",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w5;
        var off = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w5 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w5 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j4 = 0;
        var w5;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w5 = parseHexByte(number, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w5 = parseHexByte(number, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c5 = str.charCodeAt(i4) - 48;
          r3 *= mul;
          if (c5 >= 49) {
            r3 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r3 += c5 - 17 + 10;
          } else {
            r3 += c5;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w5 = this.words[i4];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r3 = c5.modn(groupBase).toString(base);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b6, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b6 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b6;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b6 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b6;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t = w5;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi4 = this._countBits(w5);
        return (this.length - 1) * 26 + hi4;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b6 = this._zeroBits(this.words[i4]);
          r3 += b6;
          if (b6 !== 26)
            break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or5(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b6;
        if (this.length > num.length) {
          b6 = num;
        } else {
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b6.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a5;
        var b6;
        if (this.length > num.length) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = a5.words[i4] ^ b6.words[i4];
        }
        if (this !== a5) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a5, b6;
        if (this.length > num.length) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r3 = (a5.words[i4] | 0) + (b6.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i4 < a5.length; i4++) {
          r3 = (a5.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b6;
        if (cmp > 0) {
          a5 = this;
          b6 = num;
        } else {
          a5 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r3 = (a5.words[i4] | 0) - (b6.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        for (; carry !== 0 && i4 < a5.length; i4++) {
          r3 = (a5.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        if (carry === 0 && i4 < a5.length && a5 !== this) {
          for (; i4 < a5.length; i4++) {
            this.words[i4] = a5.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b6 = num.words[0] | 0;
        var r3 = a5 * b6;
        var lo3 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo3;
        for (var k4 = 1; k4 < len; k4++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j4 = Math.max(0, k4 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k4 - j4 | 0;
            a5 = self2.words[i4] | 0;
            b6 = num.words[j4] | 0;
            r3 = a5 * b6 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k4] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k4] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b6 = num.words;
        var o4 = out.words;
        var c5 = 0;
        var lo3;
        var mid;
        var hi4;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b6[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b6[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b6[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b6[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b6[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b6[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b6[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b7 = b6[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b6[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b6[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo3 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi4 = Math.imul(ah0, bh0);
        var w0 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo3 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi4 = Math.imul(ah1, bh0);
        lo3 = lo3 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi4 = hi4 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo3 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi4 = Math.imul(ah2, bh0);
        lo3 = lo3 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi4 = hi4 + Math.imul(ah1, bh1) | 0;
        lo3 = lo3 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi4 = hi4 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo3 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi4 = Math.imul(ah3, bh0);
        lo3 = lo3 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi4 = hi4 + Math.imul(ah2, bh1) | 0;
        lo3 = lo3 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi4 = hi4 + Math.imul(ah1, bh2) | 0;
        lo3 = lo3 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi4 = hi4 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo3 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi4 = Math.imul(ah4, bh0);
        lo3 = lo3 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi4 = hi4 + Math.imul(ah3, bh1) | 0;
        lo3 = lo3 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi4 = hi4 + Math.imul(ah2, bh2) | 0;
        lo3 = lo3 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi4 = hi4 + Math.imul(ah1, bh3) | 0;
        lo3 = lo3 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi4 = hi4 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo3 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi4 = Math.imul(ah5, bh0);
        lo3 = lo3 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi4 = hi4 + Math.imul(ah4, bh1) | 0;
        lo3 = lo3 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi4 = hi4 + Math.imul(ah3, bh2) | 0;
        lo3 = lo3 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi4 = hi4 + Math.imul(ah2, bh3) | 0;
        lo3 = lo3 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi4 = hi4 + Math.imul(ah1, bh4) | 0;
        lo3 = lo3 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi4 = hi4 + Math.imul(ah0, bh5) | 0;
        var w5 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo3 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi4 = Math.imul(ah6, bh0);
        lo3 = lo3 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi4 = hi4 + Math.imul(ah5, bh1) | 0;
        lo3 = lo3 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi4 = hi4 + Math.imul(ah4, bh2) | 0;
        lo3 = lo3 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi4 = hi4 + Math.imul(ah3, bh3) | 0;
        lo3 = lo3 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi4 = hi4 + Math.imul(ah2, bh4) | 0;
        lo3 = lo3 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi4 = hi4 + Math.imul(ah1, bh5) | 0;
        lo3 = lo3 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi4 = hi4 + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo3 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi4 = Math.imul(ah7, bh0);
        lo3 = lo3 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi4 = hi4 + Math.imul(ah6, bh1) | 0;
        lo3 = lo3 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi4 = hi4 + Math.imul(ah5, bh2) | 0;
        lo3 = lo3 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi4 = hi4 + Math.imul(ah4, bh3) | 0;
        lo3 = lo3 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi4 = hi4 + Math.imul(ah3, bh4) | 0;
        lo3 = lo3 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi4 = hi4 + Math.imul(ah2, bh5) | 0;
        lo3 = lo3 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi4 = hi4 + Math.imul(ah1, bh6) | 0;
        lo3 = lo3 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi4 = hi4 + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo3 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi4 = Math.imul(ah8, bh0);
        lo3 = lo3 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi4 = hi4 + Math.imul(ah7, bh1) | 0;
        lo3 = lo3 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi4 = hi4 + Math.imul(ah6, bh2) | 0;
        lo3 = lo3 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi4 = hi4 + Math.imul(ah5, bh3) | 0;
        lo3 = lo3 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi4 = hi4 + Math.imul(ah4, bh4) | 0;
        lo3 = lo3 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi4 = hi4 + Math.imul(ah3, bh5) | 0;
        lo3 = lo3 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi4 = hi4 + Math.imul(ah2, bh6) | 0;
        lo3 = lo3 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi4 = hi4 + Math.imul(ah1, bh7) | 0;
        lo3 = lo3 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi4 = hi4 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo3 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi4 = Math.imul(ah9, bh0);
        lo3 = lo3 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi4 = hi4 + Math.imul(ah8, bh1) | 0;
        lo3 = lo3 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi4 = hi4 + Math.imul(ah7, bh2) | 0;
        lo3 = lo3 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi4 = hi4 + Math.imul(ah6, bh3) | 0;
        lo3 = lo3 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi4 = hi4 + Math.imul(ah5, bh4) | 0;
        lo3 = lo3 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi4 = hi4 + Math.imul(ah4, bh5) | 0;
        lo3 = lo3 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi4 = hi4 + Math.imul(ah3, bh6) | 0;
        lo3 = lo3 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi4 = hi4 + Math.imul(ah2, bh7) | 0;
        lo3 = lo3 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi4 = hi4 + Math.imul(ah1, bh8) | 0;
        lo3 = lo3 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi4 = hi4 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo3 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi4 = Math.imul(ah9, bh1);
        lo3 = lo3 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi4 = hi4 + Math.imul(ah8, bh2) | 0;
        lo3 = lo3 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi4 = hi4 + Math.imul(ah7, bh3) | 0;
        lo3 = lo3 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi4 = hi4 + Math.imul(ah6, bh4) | 0;
        lo3 = lo3 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi4 = hi4 + Math.imul(ah5, bh5) | 0;
        lo3 = lo3 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi4 = hi4 + Math.imul(ah4, bh6) | 0;
        lo3 = lo3 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi4 = hi4 + Math.imul(ah3, bh7) | 0;
        lo3 = lo3 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi4 = hi4 + Math.imul(ah2, bh8) | 0;
        lo3 = lo3 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi4 = hi4 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo3 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi4 = Math.imul(ah9, bh2);
        lo3 = lo3 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi4 = hi4 + Math.imul(ah8, bh3) | 0;
        lo3 = lo3 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi4 = hi4 + Math.imul(ah7, bh4) | 0;
        lo3 = lo3 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi4 = hi4 + Math.imul(ah6, bh5) | 0;
        lo3 = lo3 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi4 = hi4 + Math.imul(ah5, bh6) | 0;
        lo3 = lo3 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi4 = hi4 + Math.imul(ah4, bh7) | 0;
        lo3 = lo3 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi4 = hi4 + Math.imul(ah3, bh8) | 0;
        lo3 = lo3 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi4 = hi4 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo3 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi4 = Math.imul(ah9, bh3);
        lo3 = lo3 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi4 = hi4 + Math.imul(ah8, bh4) | 0;
        lo3 = lo3 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi4 = hi4 + Math.imul(ah7, bh5) | 0;
        lo3 = lo3 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi4 = hi4 + Math.imul(ah6, bh6) | 0;
        lo3 = lo3 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi4 = hi4 + Math.imul(ah5, bh7) | 0;
        lo3 = lo3 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi4 = hi4 + Math.imul(ah4, bh8) | 0;
        lo3 = lo3 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi4 = hi4 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo3 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi4 = Math.imul(ah9, bh4);
        lo3 = lo3 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi4 = hi4 + Math.imul(ah8, bh5) | 0;
        lo3 = lo3 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi4 = hi4 + Math.imul(ah7, bh6) | 0;
        lo3 = lo3 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi4 = hi4 + Math.imul(ah6, bh7) | 0;
        lo3 = lo3 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi4 = hi4 + Math.imul(ah5, bh8) | 0;
        lo3 = lo3 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi4 = hi4 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo3 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi4 = Math.imul(ah9, bh5);
        lo3 = lo3 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi4 = hi4 + Math.imul(ah8, bh6) | 0;
        lo3 = lo3 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi4 = hi4 + Math.imul(ah7, bh7) | 0;
        lo3 = lo3 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi4 = hi4 + Math.imul(ah6, bh8) | 0;
        lo3 = lo3 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi4 = hi4 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo3 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi4 = Math.imul(ah9, bh6);
        lo3 = lo3 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi4 = hi4 + Math.imul(ah8, bh7) | 0;
        lo3 = lo3 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi4 = hi4 + Math.imul(ah7, bh8) | 0;
        lo3 = lo3 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi4 = hi4 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo3 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi4 = Math.imul(ah9, bh7);
        lo3 = lo3 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi4 = hi4 + Math.imul(ah8, bh8) | 0;
        lo3 = lo3 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi4 = hi4 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo3 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi4 = Math.imul(ah9, bh8);
        lo3 = lo3 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi4 = hi4 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo3 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi4 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi4 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c5 !== 0) {
          o4[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k4 = 0; k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j4 = Math.max(0, k4 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k4 - j4;
            var a5 = self2.words[i4] | 0;
            var b6 = num.words[j4] | 0;
            var r3 = a5 * b6;
            var lo3 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo3 = lo3 + rword | 0;
            rword = lo3 & 67108863;
            ncarry = ncarry + (lo3 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k4] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k4] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x9, y7) {
        this.x = x9;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t = new Array(N3);
        var l4 = BN.prototype._countBits(N3) - 1;
        for (var i4 = 0; i4 < N3; i4++) {
          t[i4] = this.revBin(i4, l4, N3);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x9, l4, N3) {
        if (x9 === 0 || x9 === N3 - 1)
          return x9;
        var rb = 0;
        for (var i4 = 0; i4 < l4; i4++) {
          rb |= (x9 & 1) << l4 - i4 - 1;
          x9 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i4 = 0; i4 < N3; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s2 = 1; s2 < N3; s2 <<= 1) {
          var l4 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l4);
          var itwdf = Math.sin(2 * Math.PI / l4);
          for (var p4 = 0; p4 < N3; p4 += l4) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s2; j4++) {
              var re5 = rtws[p4 + j4];
              var ie5 = itws[p4 + j4];
              var ro3 = rtws[p4 + j4 + s2];
              var io2 = itws[p4 + j4 + s2];
              var rx = rtwdf_ * ro3 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p4 + j4] = re5 + ro3;
              itws[p4 + j4] = ie5 + io2;
              rtws[p4 + j4 + s2] = re5 - ro3;
              itws[p4 + j4 + s2] = ie5 - io2;
              if (j4 !== l4) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m) {
        var N3 = Math.max(m, n4) | 1;
        var odd = N3 & 1;
        var i4 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var t = rws[i4];
          rws[i4] = rws[N3 - i4 - 1];
          rws[N3 - i4 - 1] = t;
          t = iws[i4];
          iws[i4] = -iws[N3 - i4 - 1];
          iws[N3 - i4 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var w5 = Math.round(ws3[2 * i4 + 1] / N3) * 8192 + Math.round(ws3[2 * i4] / N3) + carry;
          ws3[i4] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws3[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N3; ++i4) {
          rws[i4] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i4 = 0; i4 < N3; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x9, y7, out) {
        var N3 = 2 * this.guessLen13b(x9.length, y7.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x9.words, x9.length, rws, N3);
        this.convert13b(y7.words, y7.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i4 = 0; i4 < N3; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x9.negative ^ y7.negative;
        out.length = x9.length + y7.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w5 = (this.words[i4] | 0) * num;
          var lo3 = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo3 >>> 26;
          this.words[i4] = lo3 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN(1);
        var res = this;
        for (var i4 = 0; i4 < w5.length; i4++, res = res.sqr()) {
          if (w5[i4] !== 0)
            break;
        }
        if (++i4 < w5.length) {
          for (var q5 = res.sqr(); i4 < w5.length; i4++, q5 = q5.sqr()) {
            if (w5[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i4;
        if (r3 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c5 = (this.words[i4] | 0) - newCarry << r3;
            this.words[i4] = c5 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h6 -= s2;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h6); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q5 = 1 << r3;
        if (this.length <= s2)
          return false;
        var w5 = this.words[s2];
        return !!(w5 & q5);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w5 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w5 = -(this.words[i4] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b6 = num;
        var bhi = b6.words[b6.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b6 = b6.ushln(shift);
          a5.iushln(shift);
          bhi = b6.words[b6.length - 1] | 0;
        }
        var m = a5.length - b6.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN(null);
          q5.length = m + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b6, 1, m);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m] = 1;
          }
        }
        for (var j4 = m - 1; j4 >= 0; j4--) {
          var qj = (a5.words[b6.length + j4] | 0) * 67108864 + (a5.words[b6.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b6, qj, j4);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b6, 1, j4);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p4 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p4 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w5 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var x9 = this;
        var y7 = p4.clone();
        if (x9.negative !== 0) {
          x9 = x9.umod(p4);
        } else {
          x9 = x9.clone();
        }
        var A5 = new BN(1);
        var B6 = new BN(0);
        var C7 = new BN(0);
        var D4 = new BN(1);
        var g6 = 0;
        while (x9.isEven() && y7.isEven()) {
          x9.iushrn(1);
          y7.iushrn(1);
          ++g6;
        }
        var yp = y7.clone();
        var xp = x9.clone();
        while (!x9.isZero()) {
          for (var i4 = 0, im = 1; (x9.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x9.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B6.isOdd()) {
                A5.iadd(yp);
                B6.isub(xp);
              }
              A5.iushrn(1);
              B6.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y7.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y7.iushrn(j4);
            while (j4-- > 0) {
              if (C7.isOdd() || D4.isOdd()) {
                C7.iadd(yp);
                D4.isub(xp);
              }
              C7.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x9.cmp(y7) >= 0) {
            x9.isub(y7);
            A5.isub(C7);
            B6.isub(D4);
          } else {
            y7.isub(x9);
            C7.isub(A5);
            D4.isub(B6);
          }
        }
        return {
          a: C7,
          b: D4,
          gcd: y7.iushln(g6)
        };
      };
      BN.prototype._invmp = function _invmp(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var a5 = this;
        var b6 = p4.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p4);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b6.clone();
        while (a5.cmpn(1) > 0 && b6.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a5.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b6.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b6.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b6) >= 0) {
            a5.isub(b6);
            x1.isub(x22);
          } else {
            b6.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p4);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b6 = num.clone();
        a5.negative = 0;
        b6.negative = 0;
        for (var shift = 0; a5.isEven() && b6.isEven(); shift++) {
          a5.iushrn(1);
          b6.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b6.isEven()) {
            b6.iushrn(1);
          }
          var r3 = a5.cmp(b6);
          if (r3 < 0) {
            var t = a5;
            a5 = b6;
            b6 = t;
          } else if (r3 === 0 || b6.cmpn(1) === 0) {
            break;
          }
          a5.isub(b6);
        } while (true);
        return b6.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q5 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w5 = this.words[i4] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i4] = w5;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a5 = this.words[i4] | 0;
          var b6 = num.words[i4] | 0;
          if (a5 === b6)
            continue;
          if (a5 < b6) {
            res = -1;
          } else if (a5 > b6) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt7(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt5(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p4) {
        this.name = name;
        this.p = new BN(p4, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo3 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w5 = num.words[i4] | 0;
          lo3 += w5 * 977;
          num.words[i4] = lo3 & 67108863;
          lo3 = w5 * 64 + (lo3 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi4 = (num.words[i4] | 0) * 19 + carry;
          var lo3 = hi4 & 67108863;
          hi4 >>>= 26;
          num.words[i4] = lo3;
          carry = hi4;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert(a5.negative === 0, "red works only with positives");
        assert(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b6) {
        assert((a5.negative | b6.negative) === 0, "red works only with positives");
        assert(
          a5.red && a5.red === b6.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.add(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.iadd(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.sub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b6) {
        this._verify2(a5, b6);
        var res = a5.isub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b6) {
        this._verify2(a5, b6);
        return this.imod(a5.imul(b6));
      };
      Red.prototype.mul = function mul(a5, b6) {
        this._verify2(a5, b6);
        return this.imod(a5.mul(b6));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s2 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s2++;
          q5.iushrn(1);
        }
        assert(!q5.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z8 = this.m.bitLength();
        z8 = new BN(2 * z8 * z8).toRed(this);
        while (this.pow(z8, lpow).cmp(nOne) !== 0) {
          z8.redIAdd(nOne);
        }
        var c5 = this.pow(z8, q5);
        var r3 = this.pow(a5, q5.addn(1).iushrn(1));
        var t = this.pow(a5, q5);
        var m = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert(i4 < m);
          var b6 = this.pow(c5, new BN(1).iushln(m - i4 - 1));
          r3 = r3.redMul(b6);
          c5 = b6.redSqr();
          t = t.redMul(c5);
          m = i4;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a5;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a5, b6) {
        if (a5.isZero() || b6.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t = a5.imul(b6);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b6) {
        if (a5.isZero() || b6.isZero())
          return new BN(0)._forceRed(this);
        var t = a5.mul(b6);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w5, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i4;
      for (i4 = 0; i4 < naf.length; i4 += 1) {
        naf[i4] = 0;
      }
      var ws3 = 1 << w5 + 1;
      var k4 = num.clone();
      for (i4 = 0; i4 < naf.length; i4++) {
        var z8;
        var mod = k4.andln(ws3 - 1);
        if (k4.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z8 = (ws3 >> 1) - mod;
          else
            z8 = mod;
          k4.isubn(z8);
        } else {
          z8 = 0;
        }
        naf[i4] = z8;
        k4.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p4, k4) {
      assert(p4.precomputed);
      var doubles = p4._getDoubles();
      var naf = getNAF(k4, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j4;
      var nafW;
      for (j4 = 0; j4 < naf.length; j4 += doubles.step) {
        nafW = 0;
        for (var l4 = j4 + doubles.step - 1; l4 >= j4; l4--)
          nafW = (nafW << 1) + naf[l4];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b6 = this.jpoint(null, null, null);
      for (var i4 = I5; i4 > 0; i4--) {
        for (j4 = 0; j4 < repr.length; j4++) {
          nafW = repr[j4];
          if (nafW === i4)
            b6 = b6.mixedAdd(doubles.points[j4]);
          else if (nafW === -i4)
            b6 = b6.mixedAdd(doubles.points[j4].neg());
        }
        a5 = a5.add(b6);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p4, k4) {
      var w5 = 4;
      var nafPoints = p4._getNAFPoints(w5);
      w5 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k4, w5, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i4 = naf.length - 1; i4 >= 0; i4--) {
        for (var l4 = 0; i4 >= 0 && naf[i4] === 0; i4--)
          l4++;
        if (i4 >= 0)
          l4++;
        acc = acc.dblp(l4);
        if (i4 < 0)
          break;
        var z8 = naf[i4];
        assert(z8 !== 0);
        if (p4.type === "affine") {
          if (z8 > 0)
            acc = acc.mixedAdd(wnd[z8 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z8 - 1 >> 1].neg());
        } else {
          if (z8 > 0)
            acc = acc.add(wnd[z8 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z8 - 1 >> 1].neg());
        }
      }
      return p4.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i4;
      var j4;
      var p4;
      for (i4 = 0; i4 < len; i4++) {
        p4 = points[i4];
        var nafPoints = p4._getNAFPoints(defW);
        wndWidth[i4] = nafPoints.wnd;
        wnd[i4] = nafPoints.points;
      }
      for (i4 = len - 1; i4 >= 1; i4 -= 2) {
        var a5 = i4 - 1;
        var b6 = i4;
        if (wndWidth[a5] !== 1 || wndWidth[b6] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b6] = getNAF(coeffs[b6], wndWidth[b6], this._bitLength);
          max = Math.max(naf[a5].length, max);
          max = Math.max(naf[b6].length, max);
          continue;
        }
        var comb = [
          points[a5],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b6]
          /* 7 */
        ];
        if (points[a5].y.cmp(points[b6].y) === 0) {
          comb[1] = points[a5].add(points[b6]);
          comb[2] = points[a5].toJ().mixedAdd(points[b6].neg());
        } else if (points[a5].y.cmp(points[b6].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b6]);
          comb[2] = points[a5].add(points[b6].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b6]);
          comb[2] = points[a5].toJ().mixedAdd(points[b6].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b6]);
        max = Math.max(jsf[0].length, max);
        naf[a5] = new Array(max);
        naf[b6] = new Array(max);
        for (j4 = 0; j4 < max; j4++) {
          var ja = jsf[0][j4] | 0;
          var jb = jsf[1][j4] | 0;
          naf[a5][j4] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b6][j4] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i4 = max; i4 >= 0; i4--) {
        var k4 = 0;
        while (i4 >= 0) {
          var zero = true;
          for (j4 = 0; j4 < len; j4++) {
            tmp[j4] = naf[j4][i4] | 0;
            if (tmp[j4] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k4++;
          i4--;
        }
        if (i4 >= 0)
          k4++;
        acc = acc.dblp(k4);
        if (i4 < 0)
          break;
        for (j4 = 0; j4 < len; j4++) {
          var z8 = tmp[j4];
          p4;
          if (z8 === 0)
            continue;
          else if (z8 > 0)
            p4 = wnd[j4][z8 - 1 >> 1];
          else if (z8 < 0)
            p4 = wnd[j4][-z8 - 1 >> 1].neg();
          if (p4.type === "affine")
            acc = acc.mixedAdd(p4);
          else
            acc = acc.add(p4);
        }
      }
      for (i4 = 0; i4 < len; i4++)
        wnd[i4] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x9 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x9);
      return [4].concat(x9, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k4) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k4.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i4 = 0; i4 < power; i4 += step) {
        for (var j4 = 0; j4 < step; j4++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i4 = 1; i4 < max; i4++)
        res[i4] = res[i4 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k4) {
      var r3 = this;
      for (var i4 = 0; i4 < k4; i4++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v8 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i4 = 0;
      var r3;
      var x9;
      while (u4.cmpn(0) !== 0) {
        var q5 = v8.div(u4);
        r3 = v8.sub(q5.mul(u4));
        x9 = x22.sub(q5.mul(x1));
        var y7 = y22.sub(q5.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x9;
        } else if (a1 && ++i4 === 2) {
          break;
        }
        prevR = r3;
        v8 = u4;
        u4 = r3;
        x22 = x1;
        x1 = x9;
        y22 = y1;
        y1 = y7;
      }
      a22 = r3.neg();
      b22 = x9;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k4) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k4).divRound(this.n);
      var c22 = v1.b.neg().mul(k4).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k4.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x9, odd) {
      x9 = new BN(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var y22 = x9.redSqr().redMul(x9).redIAdd(x9.redMul(this.a)).redIAdd(this.b);
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x9 = point.x;
      var y7 = point.y;
      var ax = this.a.redMul(x9);
      var rhs = x9.redSqr().redMul(x9).redIAdd(ax).redIAdd(this.b);
      return y7.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i4 = 0; i4 < points.length; i4++) {
        var split = this._endoSplit(coeffs[i4]);
        var p4 = points[i4];
        var beta = p4._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p4 = p4.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i4 * 2] = p4;
        npoints[i4 * 2 + 1] = beta;
        ncoeffs[i4 * 2] = split.k1;
        ncoeffs[i4 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
      for (var j4 = 0; j4 < i4 * 2; j4++) {
        npoints[j4] = null;
        ncoeffs[j4] = null;
      }
      return res;
    };
    function Point(curve, x9, y7, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x9 === null && y7 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x9, y7, isRed) {
      return new Point(this, x9, y7, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p4) {
          return curve.point(p4.x.redMul(curve.endo.beta), p4.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p4) {
      if (this.inf)
        return p4;
      if (p4.inf)
        return this;
      if (this.eq(p4))
        return this.dbl();
      if (this.neg().eq(p4))
        return this.curve.point(null, null);
      if (this.x.cmp(p4.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p4.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p4.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p4.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k4) {
      k4 = new BN(k4, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k4]);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p4) {
      return this === p4 || this.inf === p4.inf && (this.inf || this.x.cmp(p4.x) === 0 && this.y.cmp(p4.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p4) {
          return p4.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x9, y7, z8) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x9 === null && y7 === null && z8 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        this.z = new BN(z8, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x9, y7, z8) {
      return new JPoint(this, x9, y7, z8);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      var pz2 = p4.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p4.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p4.z));
      var s2 = p4.y.redMul(z22.redMul(this.z));
      var h6 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h6.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v8 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r3.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p4.z).redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p4) {
      if (this.isInfinity())
        return p4.toJ();
      if (p4.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p4.x.redMul(z22);
      var s1 = this.y;
      var s2 = p4.y.redMul(z22).redMul(this.z);
      var h6 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h6.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h6.redSqr();
      var h32 = h22.redMul(h6);
      var v8 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r3.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i4 = 0; i4 < pow; i4++)
          r3 = r3.dbl();
        return r3;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i4 = 0; i4 < pow; i4++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c5.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i4 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b6 = this.y.redSqr();
        var c5 = b6.redSqr();
        var d5 = this.x.redAdd(b6).redSqr().redISub(a5).redISub(c5);
        d5 = d5.redIAdd(d5);
        var e = a5.redAdd(a5).redIAdd(a5);
        var f5 = e.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d5).redISub(d5);
        ny = e.redMul(d5.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee6 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u4 = m.redIAdd(e).redSqr().redISub(mm).redISub(ee6).redISub(t);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee6).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t.redISub(u4)).redISub(e.redMul(ee6)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee6);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k4, kbase) {
      k4 = new BN(k4, kbase);
      return this.curve._wnafMul(this, k4);
    };
    JPoint.prototype.eq = function eq(p4) {
      if (p4.type === "affine")
        return this.eq(p4.toJ());
      if (this === p4)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p4.z.redSqr();
      if (this.x.redMul(pz2).redISub(p4.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p4.z);
      return this.y.redMul(pz3).redISub(p4.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x9) {
      var zs4 = this.z.redSqr();
      var rx = x9.toRed(this.curve.red).redMul(zs4);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t = this.curve.redN.redMul(zs4);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x9 = point.normalize().x;
      var x22 = x9.redSqr();
      var rhs = x22.redMul(x9).redAdd(x22.redMul(this.a)).redAdd(x9);
      var y7 = rhs.redSqrt();
      return y7.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x9, z8) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && z8 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x9, 16);
        this.z = new BN(z8, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x9, z8) {
      return new Point(this, x9, z8);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b6 = this.x.redSub(this.z);
      var bb = b6.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p4, diff) {
      var a5 = this.x.redAdd(this.z);
      var b6 = this.x.redSub(this.z);
      var c5 = p4.x.redAdd(p4.z);
      var d5 = p4.x.redSub(p4.z);
      var da = d5.redMul(a5);
      var cb = c5.redMul(b6);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k4) {
      var t = k4.clone();
      var a5 = this;
      var b6 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i4 = bits.length - 1; i4 >= 0; i4--) {
        if (bits[i4] === 0) {
          a5 = a5.diffAdd(b6, c5);
          b6 = b6.dbl();
        } else {
          b6 = a5.diffAdd(b6, c5);
          a5 = a5.dbl();
        }
      }
      return b6;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x9, y7, z8, t) {
      return this.point(x9, y7, z8, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x9, odd) {
      x9 = new BN(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var x22 = x9.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y7, odd) {
      y7 = new BN(y7, 16);
      if (!y7.red)
        y7 = y7.toRed(this.red);
      var y22 = y7.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y7);
      }
      var x9 = x22.redSqrt();
      if (x9.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x9.fromRed().isOdd() !== odd)
        x9 = x9.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x9, y7, z8, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && y7 === null && z8 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x9, 16);
        this.y = new BN(y7, 16);
        this.z = z8 ? new BN(z8, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x9, y7, z8, t) {
      return new Point(this, x9, y7, z8, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b6 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d5 = this.curve._mulA(a5);
      var e = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b6);
      var g6 = d5.redAdd(b6);
      var f5 = g6.redSub(c5);
      var h6 = d5.redSub(b6);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h6);
      var nt5 = e.redMul(h6);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b6 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d5 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h6;
      var j4;
      if (this.curve.twisted) {
        e = this.curve._mulA(c5);
        var f5 = e.redAdd(d5);
        if (this.zOne) {
          nx = b6.redSub(c5).redSub(d5).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e.redSub(d5));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h6 = this.z.redSqr();
          j4 = f5.redSub(h6).redISub(h6);
          nx = b6.redSub(c5).redISub(d5).redMul(j4);
          ny = f5.redMul(e.redSub(d5));
          nz = f5.redMul(j4);
        }
      } else {
        e = c5.redAdd(d5);
        h6 = this.curve._mulC(this.z).redSqr();
        j4 = e.redSub(h6).redSub(h6);
        nx = this.curve._mulC(b6.redISub(e)).redMul(j4);
        ny = this.curve._mulC(e).redMul(c5.redISub(d5));
        nz = e.redMul(j4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p4) {
      var a5 = this.y.redSub(this.x).redMul(p4.y.redSub(p4.x));
      var b6 = this.y.redAdd(this.x).redMul(p4.y.redAdd(p4.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p4.t);
      var d5 = this.z.redMul(p4.z.redAdd(p4.z));
      var e = b6.redSub(a5);
      var f5 = d5.redSub(c5);
      var g6 = d5.redAdd(c5);
      var h6 = b6.redAdd(a5);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h6);
      var nt5 = e.redMul(h6);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projAdd = function _projAdd(p4) {
      var a5 = this.z.redMul(p4.z);
      var b6 = a5.redSqr();
      var c5 = this.x.redMul(p4.x);
      var d5 = this.y.redMul(p4.y);
      var e = this.curve.d.redMul(c5).redMul(d5);
      var f5 = b6.redSub(e);
      var g6 = b6.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p4.x.redAdd(p4.y)).redISub(c5).redISub(d5);
      var nx = a5.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g6).redMul(d5.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g6);
      } else {
        ny = a5.redMul(g6).redMul(d5.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p4);
      else
        return this._projAdd(p4);
    };
    Point.prototype.mul = function mul(k4) {
      if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x9) {
      var rx = x9.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base2();
    curve.short = require_short2();
    curve.mont = require_mont2();
    curve.edwards = require_edwards2();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js
var require_curves2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve2();
    var utils = require_utils4();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k12();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p4) {
      var initial = buf[p4.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p4.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i4 = 0, off = p4.place; i4 < octetLen; i4++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p4.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i4 = 0;
      var len = buf.length - 1;
      while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
        i4++;
      }
      if (i4 === 0) {
        return buf;
      }
      return buf.slice(i4);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p4 = new Position();
      if (data[p4.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p4);
      if (len === false) {
        return false;
      }
      if (len + p4.place !== data.length) {
        return false;
      }
      if (data[p4.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p4);
      if (rlen === false) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p4.place, rlen + p4.place);
      p4.place += rlen;
      if (data[p4.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p4);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p4.place) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p4.place, slen + p4.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves2();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key3();
    var Signature = require_signature3();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k4 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k4 = this._truncateToN(k4, true);
        if (k4.cmpn(1) <= 0 || k4.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k4);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k4.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p4;
      if (!this.curve._maxwellTrick) {
        p4 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p4.isInfinity())
          return false;
        return p4.getX().umod(this.n).cmp(r3) === 0;
      }
      p4 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p4.isInfinity())
        return false;
      return p4.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j4, enc) {
      assert((3 & j4) === j4, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j4 & 1;
      var isSecondKey = j4 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i4 = 0; i4 < 4; i4++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i4);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i4;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S7() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R5() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves2();
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key4();
    var Signature = require_signature4();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R5 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R5);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S7 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R5, S: S7, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h6 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h6));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i4 = 0; i4 < arguments.length; i4++)
        hash2.update(arguments[i4]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y7 = utils.intFromLE(normed);
      return this.curve.pointFromY(y7, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package2().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve2();
    elliptic.curves = require_curves2();
    elliptic.ec = require_ec2();
    elliptic.eddsa = require_eddsa2();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_esm();
var n = class extends IEvents {
  constructor(e) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r2 = { pulse: "heartbeat_pulse" };
var i = class _i2 extends n {
  constructor(e) {
    super(e), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e == null ? void 0 : e.interval) || s;
  }
  static async init(e) {
    const t = new _i2(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r2.pulse);
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events4 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p = class {
  constructor(s2, t, e, f5) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y2 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C2 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
init_lib2();
var import_elliptic = __toESM(require_elliptic());
var Ft = "ReactNative";
var H = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Gt = "js";
function et() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ft;
}
function Wr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function zr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae() {
  return !et() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function ue() {
  return ne() ? H.reactNative : et() ? H.node : Ae() ? H.browser : H.unknown;
}
function Jr() {
  var e;
  try {
    return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt(e, t) {
  const n4 = new URLSearchParams(e);
  for (const r3 of Object.keys(t).sort())
    if (t.hasOwnProperty(r3)) {
      const o4 = t[r3];
      o4 !== void 0 && n4.set(r3, o4);
    }
  return n4.toString();
}
function Yr() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function zt() {
  if (ue() === H.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n4, Version: r3 } = global.Platform;
    return [n4, r3].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function Jt() {
  var e;
  const t = ue();
  return t === H.browser ? [t, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt(e, t, n4) {
  const r3 = zt(), o4 = Jt();
  return [[e, t].join("-"), [Gt, n4].join("-"), r3, o4].join("/");
}
function Zr({ protocol: e, version: t, relayUrl: n4, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i4, bundleId: c5, packageName: u4 }) {
  const a5 = n4.split("?"), l4 = Yt(e, t, r3), f5 = { auth: o4, ua: l4, projectId: s2, useOnCloseEvent: i4 || void 0, packageName: u4 || void 0, bundleId: c5 || void 0 }, d5 = Wt(a5[1] || "", f5);
  return a5[0] + "?" + d5;
}
function no(e) {
  return Object.fromEntries(e.entries());
}
function ro(e) {
  return new Map(Object.entries(e));
}
function co(e = import_time2.FIVE_MINUTES, t) {
  const n4 = (0, import_time2.toMiliseconds)(e || import_time2.FIVE_MINUTES);
  let r3, o4, s2, i4;
  return { resolve: (c5) => {
    s2 && r3 && (clearTimeout(s2), r3(c5), i4 = Promise.resolve(c5));
  }, reject: (c5) => {
    s2 && o4 && (clearTimeout(s2), o4(c5));
  }, done: () => new Promise((c5, u4) => {
    if (i4)
      return c5(i4);
    s2 = setTimeout(() => {
      const a5 = new Error(t);
      i4 = Promise.reject(a5), u4(a5);
    }, n4), r3 = c5, o4 = u4;
  }) };
}
function ao(e, t, n4) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(n4)), t);
    try {
      const i4 = await e;
      r3(i4);
    } catch (i4) {
      o4(i4);
    }
    clearTimeout(s2);
  });
}
function tt(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`))
    return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function uo(e) {
  return tt("topic", e);
}
function fo(e) {
  return tt("id", e);
}
function lo(e) {
  const [t, n4] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof n4 == "string")
    r3.topic = n4;
  else if (t === "id" && Number.isInteger(Number(n4)))
    r3.id = Number(n4);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n4}`);
  return r3;
}
function ho(e, t) {
  return (0, import_time2.fromMiliseconds)((t || Date.now()) + (0, import_time2.toMiliseconds)(e));
}
function po(e) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e);
}
function go(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
function wo() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Eo() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function rt(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
function vo(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Ne(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error("positive integer expected, got " + e);
}
function xo(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je(e, ...t) {
  if (!xo(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne(e.outputLen), Ne(e.blockLen);
}
function me(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function sn2(e, t) {
  je(e);
  const n4 = t.outputLen;
  if (e.length < n4)
    throw new Error("digestInto() expects output buffer of length at least " + n4);
}
var Ce = BigInt(2 ** 32 - 1);
var cn = BigInt(32);
function Oo(e, t = false) {
  return t ? { h: Number(e & Ce), l: Number(e >> cn & Ce) } : { h: Number(e >> cn & Ce) | 0, l: Number(e & Ce) | 0 };
}
function Io(e, t = false) {
  let n4 = new Uint32Array(e.length), r3 = new Uint32Array(e.length);
  for (let o4 = 0; o4 < e.length; o4++) {
    const { h: s2, l: i4 } = Oo(e[o4], t);
    [n4[o4], r3[o4]] = [s2, i4];
  }
  return [n4, r3];
}
var Ao = (e, t, n4) => e << n4 | t >>> 32 - n4;
var No = (e, t, n4) => t << n4 | e >>> 32 - n4;
var So = (e, t, n4) => t << n4 - 32 | e >>> 64 - n4;
var Uo = (e, t, n4) => e << n4 - 32 | t >>> 64 - n4;
var be = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J(e, t) {
  return e << 32 - t | e >>> t;
}
var an = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function To(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = To(e[t]);
}
function $o(e) {
  if (typeof e != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function we(e) {
  return typeof e == "string" && (e = $o(e)), je(e), e;
}
var it = class {
  clone() {
    return this._cloneInto();
  }
};
function fn(e) {
  const t = (r3) => e().update(we(r3)).digest(), n4 = e();
  return t.outputLen = n4.outputLen, t.blockLen = n4.blockLen, t.create = () => e(), t;
}
function Se(e = 32) {
  if (be && typeof be.getRandomValues == "function")
    return be.getRandomValues(new Uint8Array(e));
  if (be && typeof be.randomBytes == "function")
    return be.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln = [];
var dn = [];
var hn = [];
var Ro = BigInt(0);
var Ue = BigInt(1);
var Po2 = BigInt(2);
var Lo = BigInt(7);
var Bo = BigInt(256);
var jo = BigInt(113);
for (let e = 0, t = Ue, n4 = 1, r3 = 0; e < 24; e++) {
  [n4, r3] = [r3, (2 * n4 + 3 * r3) % 5], ln.push(2 * (5 * r3 + n4)), dn.push((e + 1) * (e + 2) / 2 % 64);
  let o4 = Ro;
  for (let s2 = 0; s2 < 7; s2++)
    t = (t << Ue ^ (t >> Lo) * jo) % Bo, t & Po2 && (o4 ^= Ue << (Ue << BigInt(s2)) - Ue);
  hn.push(o4);
}
var [Co, ko] = Io(hn, true);
var pn = (e, t, n4) => n4 > 32 ? So(e, t, n4) : Ao(e, t, n4);
var gn = (e, t, n4) => n4 > 32 ? Uo(e, t, n4) : No(e, t, n4);
function Do(e, t = 24) {
  const n4 = new Uint32Array(10);
  for (let r3 = 24 - t; r3 < 24; r3++) {
    for (let i4 = 0; i4 < 10; i4++)
      n4[i4] = e[i4] ^ e[i4 + 10] ^ e[i4 + 20] ^ e[i4 + 30] ^ e[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const c5 = (i4 + 8) % 10, u4 = (i4 + 2) % 10, a5 = n4[u4], l4 = n4[u4 + 1], f5 = pn(a5, l4, 1) ^ n4[c5], d5 = gn(a5, l4, 1) ^ n4[c5 + 1];
      for (let g6 = 0; g6 < 50; g6 += 10)
        e[i4 + g6] ^= f5, e[i4 + g6 + 1] ^= d5;
    }
    let o4 = e[2], s2 = e[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const c5 = dn[i4], u4 = pn(o4, s2, c5), a5 = gn(o4, s2, c5), l4 = ln[i4];
      o4 = e[l4], s2 = e[l4 + 1], e[l4] = u4, e[l4 + 1] = a5;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let c5 = 0; c5 < 10; c5++)
        n4[c5] = e[i4 + c5];
      for (let c5 = 0; c5 < 10; c5++)
        e[i4 + c5] ^= ~n4[(c5 + 2) % 10] & n4[(c5 + 4) % 10];
    }
    e[0] ^= Co[r3], e[1] ^= ko[r3];
  }
  n4.fill(0);
}
var Bt = class _Bt extends it {
  constructor(t, n4, r3, o4 = false, s2 = 24) {
    if (super(), this.blockLen = t, this.suffix = n4, this.outputLen = r3, this.enableXOF = o4, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne(r3), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o(this.state);
  }
  keccak() {
    an || un(this.state32), Do(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    me(this);
    const { blockLen: n4, state: r3 } = this;
    t = we(t);
    const o4 = t.length;
    for (let s2 = 0; s2 < o4; ) {
      const i4 = Math.min(n4 - this.pos, o4 - s2);
      for (let c5 = 0; c5 < i4; c5++)
        r3[this.pos++] ^= t[s2++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: t, suffix: n4, pos: r3, blockLen: o4 } = this;
    t[r3] ^= n4, n4 & 128 && r3 === o4 - 1 && this.keccak(), t[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    me(this, false), je(t), this.finish();
    const n4 = this.state, { blockLen: r3 } = this;
    for (let o4 = 0, s2 = t.length; o4 < s2; ) {
      this.posOut >= r3 && this.keccak();
      const i4 = Math.min(r3 - this.posOut, s2 - o4);
      t.set(n4.subarray(this.posOut, this.posOut + i4), o4), this.posOut += i4, o4 += i4;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ne(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (sn2(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n4, suffix: r3, outputLen: o4, rounds: s2, enableXOF: i4 } = this;
    return t || (t = new _Bt(n4, r3, o4, i4, s2)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s2, t.suffix = r3, t.outputLen = o4, t.enableXOF = i4, t.destroyed = this.destroyed, t;
  }
};
var Mo = (e, t, n4) => fn(() => new Bt(t, e, n4));
var Vo = Mo(1, 136, 256 / 8);
function ht(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error("positive integer expected, got " + e);
}
function Ln(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F(e, ...t) {
  if (!Ln(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Bn(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function ss(e, t) {
  F(e);
  const n4 = t.outputLen;
  if (e.length < n4)
    throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function jn(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
var se = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
var is = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var cs = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs)
  throw new Error("Non little-endian hardware is not supported");
function as(e) {
  if (typeof e != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function pt(e) {
  if (typeof e == "string")
    e = as(e);
  else if (Ln(e))
    e = gt(e);
  else
    throw new Error("Uint8Array expected, got " + typeof e);
  return e;
}
function us(e, t) {
  if (t == null || typeof t != "object")
    throw new Error("options must be defined");
  return Object.assign(e, t);
}
function fs(e, t) {
  if (e.length !== t.length)
    return false;
  let n4 = 0;
  for (let r3 = 0; r3 < e.length; r3++)
    n4 |= e[r3] ^ t[r3];
  return n4 === 0;
}
var ls = (e, t) => {
  function n4(r3, ...o4) {
    if (F(r3), e.nonceLength !== void 0) {
      const l4 = o4[0];
      if (!l4)
        throw new Error("nonce / iv required");
      e.varSizeNonce ? F(l4) : F(l4, e.nonceLength);
    }
    const s2 = e.tagLength;
    s2 && o4[1] !== void 0 && F(o4[1]);
    const i4 = t(r3, ...o4), c5 = (l4, f5) => {
      if (f5 !== void 0) {
        if (l4 !== 2)
          throw new Error("cipher output not supported");
        F(f5);
      }
    };
    let u4 = false;
    return { encrypt(l4, f5) {
      if (u4)
        throw new Error("cannot encrypt() twice with same key + nonce");
      return u4 = true, F(l4), c5(i4.encrypt.length, f5), i4.encrypt(l4, f5);
    }, decrypt(l4, f5) {
      if (F(l4), s2 && l4.length < s2)
        throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c5(i4.decrypt.length, f5), i4.decrypt(l4, f5);
    } };
  }
  return Object.assign(n4, e), n4;
};
function Cn(e, t, n4 = true) {
  if (t === void 0)
    return new Uint8Array(e);
  if (t.length !== e)
    throw new Error("invalid output length, expected " + e + ", got: " + t.length);
  if (n4 && !ds(t))
    throw new Error("invalid output, must be aligned");
  return t;
}
function kn(e, t, n4, r3) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n4, r3);
  const o4 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n4 >> o4 & s2), c5 = Number(n4 & s2), u4 = r3 ? 4 : 0, a5 = r3 ? 0 : 4;
  e.setUint32(t + u4, i4, r3), e.setUint32(t + a5, c5, r3);
}
function ds(e) {
  return e.byteOffset % 4 === 0;
}
function gt(e) {
  return Uint8Array.from(e);
}
function Ee(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
var Dn = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0)));
var hs = Dn("expand 16-byte k");
var ps = Dn("expand 32-byte k");
var gs = se(hs);
var ys = se(ps);
function x2(e, t) {
  return e << t | e >>> 32 - t;
}
function yt(e) {
  return e.byteOffset % 4 === 0;
}
var Ve = 64;
var ms = 16;
var Mn = 2 ** 32 - 1;
var Vn = new Uint32Array();
function bs(e, t, n4, r3, o4, s2, i4, c5) {
  const u4 = o4.length, a5 = new Uint8Array(Ve), l4 = se(a5), f5 = yt(o4) && yt(s2), d5 = f5 ? se(o4) : Vn, g6 = f5 ? se(s2) : Vn;
  for (let y7 = 0; y7 < u4; i4++) {
    if (e(t, n4, r3, l4, i4, c5), i4 >= Mn)
      throw new Error("arx: counter overflow");
    const h6 = Math.min(Ve, u4 - y7);
    if (f5 && h6 === Ve) {
      const m = y7 / 4;
      if (y7 % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let B6 = 0, b6; B6 < ms; B6++)
        b6 = m + B6, g6[b6] = d5[b6] ^ l4[B6];
      y7 += Ve;
      continue;
    }
    for (let m = 0, B6; m < h6; m++)
      B6 = y7 + m, s2[B6] = o4[B6] ^ a5[m];
    y7 += h6;
  }
}
function ws(e, t) {
  const { allowShortKeys: n4, extendNonceFn: r3, counterLength: o4, counterRight: s2, rounds: i4 } = us({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t);
  if (typeof e != "function")
    throw new Error("core must be a function");
  return ht(o4), ht(i4), jn(s2), jn(n4), (c5, u4, a5, l4, f5 = 0) => {
    F(c5), F(u4), F(a5);
    const d5 = a5.length;
    if (l4 === void 0 && (l4 = new Uint8Array(d5)), F(l4), ht(f5), f5 < 0 || f5 >= Mn)
      throw new Error("arx: counter overflow");
    if (l4.length < d5)
      throw new Error(`arx: output (${l4.length}) is shorter than data (${d5})`);
    const g6 = [];
    let y7 = c5.length, h6, m;
    if (y7 === 32)
      g6.push(h6 = gt(c5)), m = ys;
    else if (y7 === 16 && n4)
      h6 = new Uint8Array(32), h6.set(c5), h6.set(c5, 16), m = gs, g6.push(h6);
    else
      throw new Error(`arx: invalid 32-byte key, got length=${y7}`);
    yt(u4) || g6.push(u4 = gt(u4));
    const B6 = se(h6);
    if (r3) {
      if (u4.length !== 24)
        throw new Error("arx: extended nonce must be 24 bytes");
      r3(m, B6, se(u4.subarray(0, 16)), B6), u4 = u4.subarray(16);
    }
    const b6 = 16 - o4;
    if (b6 !== u4.length)
      throw new Error(`arx: nonce must be ${b6} or 16 bytes`);
    if (b6 !== 12) {
      const I5 = new Uint8Array(12);
      I5.set(u4, s2 ? 0 : 12 - u4.length), u4 = I5, g6.push(u4);
    }
    const _4 = se(u4);
    return bs(e, m, B6, _4, a5, l4, f5, i4), Ee(...g6), l4;
  };
}
var M = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var Es = class {
  constructor(t) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t = pt(t), F(t, 32);
    const n4 = M(t, 0), r3 = M(t, 2), o4 = M(t, 4), s2 = M(t, 6), i4 = M(t, 8), c5 = M(t, 10), u4 = M(t, 12), a5 = M(t, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | c5 << 2) & 8191, this.r[7] = (c5 >>> 11 | u4 << 5) & 8065, this.r[8] = (u4 >>> 8 | a5 << 8) & 8191, this.r[9] = a5 >>> 5 & 127;
    for (let l4 = 0; l4 < 8; l4++)
      this.pad[l4] = M(t, 16 + 2 * l4);
  }
  process(t, n4, r3 = false) {
    const o4 = r3 ? 0 : 2048, { h: s2, r: i4 } = this, c5 = i4[0], u4 = i4[1], a5 = i4[2], l4 = i4[3], f5 = i4[4], d5 = i4[5], g6 = i4[6], y7 = i4[7], h6 = i4[8], m = i4[9], B6 = M(t, n4 + 0), b6 = M(t, n4 + 2), _4 = M(t, n4 + 4), I5 = M(t, n4 + 6), k4 = M(t, n4 + 8), E4 = M(t, n4 + 10), L4 = M(t, n4 + 12), j4 = M(t, n4 + 14);
    let v8 = s2[0] + (B6 & 8191), O5 = s2[1] + ((B6 >>> 13 | b6 << 3) & 8191), w5 = s2[2] + ((b6 >>> 10 | _4 << 6) & 8191), R5 = s2[3] + ((_4 >>> 7 | I5 << 9) & 8191), A5 = s2[4] + ((I5 >>> 4 | k4 << 12) & 8191), T4 = s2[5] + (k4 >>> 1 & 8191), N3 = s2[6] + ((k4 >>> 14 | E4 << 2) & 8191), S7 = s2[7] + ((E4 >>> 11 | L4 << 5) & 8191), U6 = s2[8] + ((L4 >>> 8 | j4 << 8) & 8191), $7 = s2[9] + (j4 >>> 5 | o4), p4 = 0, C7 = p4 + v8 * c5 + O5 * (5 * m) + w5 * (5 * h6) + R5 * (5 * y7) + A5 * (5 * g6);
    p4 = C7 >>> 13, C7 &= 8191, C7 += T4 * (5 * d5) + N3 * (5 * f5) + S7 * (5 * l4) + U6 * (5 * a5) + $7 * (5 * u4), p4 += C7 >>> 13, C7 &= 8191;
    let D4 = p4 + v8 * u4 + O5 * c5 + w5 * (5 * m) + R5 * (5 * h6) + A5 * (5 * y7);
    p4 = D4 >>> 13, D4 &= 8191, D4 += T4 * (5 * g6) + N3 * (5 * d5) + S7 * (5 * f5) + U6 * (5 * l4) + $7 * (5 * a5), p4 += D4 >>> 13, D4 &= 8191;
    let P4 = p4 + v8 * a5 + O5 * u4 + w5 * c5 + R5 * (5 * m) + A5 * (5 * h6);
    p4 = P4 >>> 13, P4 &= 8191, P4 += T4 * (5 * y7) + N3 * (5 * g6) + S7 * (5 * d5) + U6 * (5 * f5) + $7 * (5 * l4), p4 += P4 >>> 13, P4 &= 8191;
    let G3 = p4 + v8 * l4 + O5 * a5 + w5 * u4 + R5 * c5 + A5 * (5 * m);
    p4 = G3 >>> 13, G3 &= 8191, G3 += T4 * (5 * h6) + N3 * (5 * y7) + S7 * (5 * g6) + U6 * (5 * d5) + $7 * (5 * f5), p4 += G3 >>> 13, G3 &= 8191;
    let X4 = p4 + v8 * f5 + O5 * l4 + w5 * a5 + R5 * u4 + A5 * c5;
    p4 = X4 >>> 13, X4 &= 8191, X4 += T4 * (5 * m) + N3 * (5 * h6) + S7 * (5 * y7) + U6 * (5 * g6) + $7 * (5 * d5), p4 += X4 >>> 13, X4 &= 8191;
    let Z6 = p4 + v8 * d5 + O5 * f5 + w5 * l4 + R5 * a5 + A5 * u4;
    p4 = Z6 >>> 13, Z6 &= 8191, Z6 += T4 * c5 + N3 * (5 * m) + S7 * (5 * h6) + U6 * (5 * y7) + $7 * (5 * g6), p4 += Z6 >>> 13, Z6 &= 8191;
    let he5 = p4 + v8 * g6 + O5 * d5 + w5 * f5 + R5 * l4 + A5 * a5;
    p4 = he5 >>> 13, he5 &= 8191, he5 += T4 * u4 + N3 * c5 + S7 * (5 * m) + U6 * (5 * h6) + $7 * (5 * y7), p4 += he5 >>> 13, he5 &= 8191;
    let pe3 = p4 + v8 * y7 + O5 * g6 + w5 * d5 + R5 * f5 + A5 * l4;
    p4 = pe3 >>> 13, pe3 &= 8191, pe3 += T4 * a5 + N3 * u4 + S7 * c5 + U6 * (5 * m) + $7 * (5 * h6), p4 += pe3 >>> 13, pe3 &= 8191;
    let ge3 = p4 + v8 * h6 + O5 * y7 + w5 * g6 + R5 * d5 + A5 * f5;
    p4 = ge3 >>> 13, ge3 &= 8191, ge3 += T4 * l4 + N3 * a5 + S7 * u4 + U6 * c5 + $7 * (5 * m), p4 += ge3 >>> 13, ge3 &= 8191;
    let ye6 = p4 + v8 * m + O5 * h6 + w5 * y7 + R5 * g6 + A5 * d5;
    p4 = ye6 >>> 13, ye6 &= 8191, ye6 += T4 * f5 + N3 * l4 + S7 * a5 + U6 * u4 + $7 * c5, p4 += ye6 >>> 13, ye6 &= 8191, p4 = (p4 << 2) + p4 | 0, p4 = p4 + C7 | 0, C7 = p4 & 8191, p4 = p4 >>> 13, D4 += p4, s2[0] = C7, s2[1] = D4, s2[2] = P4, s2[3] = G3, s2[4] = X4, s2[5] = Z6, s2[6] = he5, s2[7] = pe3, s2[8] = ge3, s2[9] = ye6;
  }
  finalize() {
    const { h: t, pad: n4 } = this, r3 = new Uint16Array(10);
    let o4 = t[1] >>> 13;
    t[1] &= 8191;
    for (let c5 = 2; c5 < 10; c5++)
      t[c5] += o4, o4 = t[c5] >>> 13, t[c5] &= 8191;
    t[0] += o4 * 5, o4 = t[0] >>> 13, t[0] &= 8191, t[1] += o4, o4 = t[1] >>> 13, t[1] &= 8191, t[2] += o4, r3[0] = t[0] + 5, o4 = r3[0] >>> 13, r3[0] &= 8191;
    for (let c5 = 1; c5 < 10; c5++)
      r3[c5] = t[c5] + o4, o4 = r3[c5] >>> 13, r3[c5] &= 8191;
    r3[9] -= 8192;
    let s2 = (o4 ^ 1) - 1;
    for (let c5 = 0; c5 < 10; c5++)
      r3[c5] &= s2;
    s2 = ~s2;
    for (let c5 = 0; c5 < 10; c5++)
      t[c5] = t[c5] & s2 | r3[c5];
    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
    let i4 = t[0] + n4[0];
    t[0] = i4 & 65535;
    for (let c5 = 1; c5 < 8; c5++)
      i4 = (t[c5] + n4[c5] | 0) + (i4 >>> 16) | 0, t[c5] = i4 & 65535;
    Ee(r3);
  }
  update(t) {
    Bn(this);
    const { buffer: n4, blockLen: r3 } = this;
    t = pt(t);
    const o4 = t.length;
    for (let s2 = 0; s2 < o4; ) {
      const i4 = Math.min(r3 - this.pos, o4 - s2);
      if (i4 === r3) {
        for (; r3 <= o4 - s2; s2 += r3)
          this.process(t, s2);
        continue;
      }
      n4.set(t.subarray(s2, s2 + i4), this.pos), this.pos += i4, s2 += i4, this.pos === r3 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t) {
    Bn(this), ss(t, this), this.finished = true;
    const { buffer: n4, h: r3 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++)
        n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i4 = 0; i4 < 8; i4++)
      t[s2++] = r3[i4] >>> 0, t[s2++] = r3[i4] >>> 8;
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n4 } = this;
    this.digestInto(t);
    const r3 = t.slice(0, n4);
    return this.destroy(), r3;
  }
};
function vs(e) {
  const t = (r3, o4) => e(o4).update(pt(r3)).digest(), n4 = e(new Uint8Array(32));
  return t.outputLen = n4.outputLen, t.blockLen = n4.blockLen, t.create = (r3) => e(r3), t;
}
var xs = vs((e) => new Es(e));
function Os(e, t, n4, r3, o4, s2 = 20) {
  let i4 = e[0], c5 = e[1], u4 = e[2], a5 = e[3], l4 = t[0], f5 = t[1], d5 = t[2], g6 = t[3], y7 = t[4], h6 = t[5], m = t[6], B6 = t[7], b6 = o4, _4 = n4[0], I5 = n4[1], k4 = n4[2], E4 = i4, L4 = c5, j4 = u4, v8 = a5, O5 = l4, w5 = f5, R5 = d5, A5 = g6, T4 = y7, N3 = h6, S7 = m, U6 = B6, $7 = b6, p4 = _4, C7 = I5, D4 = k4;
  for (let G3 = 0; G3 < s2; G3 += 2)
    E4 = E4 + O5 | 0, $7 = x2($7 ^ E4, 16), T4 = T4 + $7 | 0, O5 = x2(O5 ^ T4, 12), E4 = E4 + O5 | 0, $7 = x2($7 ^ E4, 8), T4 = T4 + $7 | 0, O5 = x2(O5 ^ T4, 7), L4 = L4 + w5 | 0, p4 = x2(p4 ^ L4, 16), N3 = N3 + p4 | 0, w5 = x2(w5 ^ N3, 12), L4 = L4 + w5 | 0, p4 = x2(p4 ^ L4, 8), N3 = N3 + p4 | 0, w5 = x2(w5 ^ N3, 7), j4 = j4 + R5 | 0, C7 = x2(C7 ^ j4, 16), S7 = S7 + C7 | 0, R5 = x2(R5 ^ S7, 12), j4 = j4 + R5 | 0, C7 = x2(C7 ^ j4, 8), S7 = S7 + C7 | 0, R5 = x2(R5 ^ S7, 7), v8 = v8 + A5 | 0, D4 = x2(D4 ^ v8, 16), U6 = U6 + D4 | 0, A5 = x2(A5 ^ U6, 12), v8 = v8 + A5 | 0, D4 = x2(D4 ^ v8, 8), U6 = U6 + D4 | 0, A5 = x2(A5 ^ U6, 7), E4 = E4 + w5 | 0, D4 = x2(D4 ^ E4, 16), S7 = S7 + D4 | 0, w5 = x2(w5 ^ S7, 12), E4 = E4 + w5 | 0, D4 = x2(D4 ^ E4, 8), S7 = S7 + D4 | 0, w5 = x2(w5 ^ S7, 7), L4 = L4 + R5 | 0, $7 = x2($7 ^ L4, 16), U6 = U6 + $7 | 0, R5 = x2(R5 ^ U6, 12), L4 = L4 + R5 | 0, $7 = x2($7 ^ L4, 8), U6 = U6 + $7 | 0, R5 = x2(R5 ^ U6, 7), j4 = j4 + A5 | 0, p4 = x2(p4 ^ j4, 16), T4 = T4 + p4 | 0, A5 = x2(A5 ^ T4, 12), j4 = j4 + A5 | 0, p4 = x2(p4 ^ j4, 8), T4 = T4 + p4 | 0, A5 = x2(A5 ^ T4, 7), v8 = v8 + O5 | 0, C7 = x2(C7 ^ v8, 16), N3 = N3 + C7 | 0, O5 = x2(O5 ^ N3, 12), v8 = v8 + O5 | 0, C7 = x2(C7 ^ v8, 8), N3 = N3 + C7 | 0, O5 = x2(O5 ^ N3, 7);
  let P4 = 0;
  r3[P4++] = i4 + E4 | 0, r3[P4++] = c5 + L4 | 0, r3[P4++] = u4 + j4 | 0, r3[P4++] = a5 + v8 | 0, r3[P4++] = l4 + O5 | 0, r3[P4++] = f5 + w5 | 0, r3[P4++] = d5 + R5 | 0, r3[P4++] = g6 + A5 | 0, r3[P4++] = y7 + T4 | 0, r3[P4++] = h6 + N3 | 0, r3[P4++] = m + S7 | 0, r3[P4++] = B6 + U6 | 0, r3[P4++] = b6 + $7 | 0, r3[P4++] = _4 + p4 | 0, r3[P4++] = I5 + C7 | 0, r3[P4++] = k4 + D4 | 0;
}
var Is = ws(Os, { counterRight: false, counterLength: 4, allowShortKeys: false });
var As = new Uint8Array(16);
var Hn = (e, t) => {
  e.update(t);
  const n4 = t.length % 16;
  n4 && e.update(As.subarray(n4));
};
var Ns = new Uint8Array(32);
function Kn(e, t, n4, r3, o4) {
  const s2 = e(t, n4, Ns), i4 = xs.create(s2);
  o4 && Hn(i4, o4), Hn(i4, r3);
  const c5 = new Uint8Array(16), u4 = is(c5);
  kn(u4, 0, BigInt(o4 ? o4.length : 0), true), kn(u4, 8, BigInt(r3.length), true), i4.update(c5);
  const a5 = i4.digest();
  return Ee(s2, c5), a5;
}
var Ss = (e) => (t, n4, r3) => ({ encrypt(s2, i4) {
  const c5 = s2.length;
  i4 = Cn(c5 + 16, i4, false), i4.set(s2);
  const u4 = i4.subarray(0, -16);
  e(t, n4, u4, u4, 1);
  const a5 = Kn(e, t, n4, u4, r3);
  return i4.set(a5, c5), Ee(a5), i4;
}, decrypt(s2, i4) {
  i4 = Cn(s2.length - 16, i4, false);
  const c5 = s2.subarray(0, -16), u4 = s2.subarray(-16), a5 = Kn(e, t, n4, c5, r3);
  if (!fs(u4, a5))
    throw new Error("invalid tag");
  return i4.set(s2.subarray(0, -16)), e(t, n4, i4, i4, 1), Ee(a5), i4;
} });
var Fn = ls({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss(Is));
var qn = class extends it {
  constructor(t, n4) {
    super(), this.finished = false, this.destroyed = false, ot(t);
    const r3 = we(n4);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s2 = new Uint8Array(o4);
    s2.set(r3.length > o4 ? t.create().update(r3).digest() : r3);
    for (let i4 = 0; i4 < s2.length; i4++)
      s2[i4] ^= 54;
    this.iHash.update(s2), this.oHash = t.create();
    for (let i4 = 0; i4 < s2.length; i4++)
      s2[i4] ^= 106;
    this.oHash.update(s2), s2.fill(0);
  }
  update(t) {
    return me(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    me(this), je(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r3, finished: o4, destroyed: s2, blockLen: i4, outputLen: c5 } = this;
    return t = t, t.finished = o4, t.destroyed = s2, t.blockLen = i4, t.outputLen = c5, t.oHash = n4._cloneInto(t.oHash), t.iHash = r3._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt = (e, t, n4) => new qn(e, t).update(n4).digest();
mt.create = (e, t) => new qn(e, t);
function Us(e, t, n4) {
  return ot(e), n4 === void 0 && (n4 = new Uint8Array(e.outputLen)), mt(e, we(n4), we(t));
}
var bt = new Uint8Array([0]);
var Gn = new Uint8Array();
function _s(e, t, n4, r3 = 32) {
  if (ot(e), Ne(r3), r3 > 255 * e.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const o4 = Math.ceil(r3 / e.outputLen);
  n4 === void 0 && (n4 = Gn);
  const s2 = new Uint8Array(o4 * e.outputLen), i4 = mt.create(e, t), c5 = i4._cloneInto(), u4 = new Uint8Array(i4.outputLen);
  for (let a5 = 0; a5 < o4; a5++)
    bt[0] = a5 + 1, c5.update(a5 === 0 ? Gn : u4).update(n4).update(bt).digestInto(u4), s2.set(u4, e.outputLen * a5), i4._cloneInto(c5);
  return i4.destroy(), c5.destroy(), u4.fill(0), bt.fill(0), s2.slice(0, r3);
}
var Ts = (e, t, n4, r3, o4) => _s(e, Us(e, t, n4), r3, o4);
function $s(e, t, n4, r3) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n4, r3);
  const o4 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n4 >> o4 & s2), c5 = Number(n4 & s2), u4 = r3 ? 4 : 0, a5 = r3 ? 0 : 4;
  e.setUint32(t + u4, i4, r3), e.setUint32(t + a5, c5, r3);
}
function Rs(e, t, n4) {
  return e & t ^ ~e & n4;
}
function Ps(e, t, n4) {
  return e & t ^ e & n4 ^ t & n4;
}
var Ls = class extends it {
  constructor(t, n4, r3, o4) {
    super(), this.blockLen = t, this.outputLen = n4, this.padOffset = r3, this.isLE = o4, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = st(this.buffer);
  }
  update(t) {
    me(this);
    const { view: n4, buffer: r3, blockLen: o4 } = this;
    t = we(t);
    const s2 = t.length;
    for (let i4 = 0; i4 < s2; ) {
      const c5 = Math.min(o4 - this.pos, s2 - i4);
      if (c5 === o4) {
        const u4 = st(t);
        for (; o4 <= s2 - i4; i4 += o4)
          this.process(u4, i4);
        continue;
      }
      r3.set(t.subarray(i4, i4 + c5), this.pos), this.pos += c5, i4 += c5, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    me(this), sn2(t, this), this.finished = true;
    const { buffer: n4, view: r3, blockLen: o4, isLE: s2 } = this;
    let { pos: i4 } = this;
    n4[i4++] = 128, this.buffer.subarray(i4).fill(0), this.padOffset > o4 - i4 && (this.process(r3, 0), i4 = 0);
    for (let f5 = i4; f5 < o4; f5++)
      n4[f5] = 0;
    $s(r3, o4 - 8, BigInt(this.length * 8), s2), this.process(r3, 0);
    const c5 = st(t), u4 = this.outputLen;
    if (u4 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a5 = u4 / 4, l4 = this.get();
    if (a5 > l4.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f5 = 0; f5 < a5; f5++)
      c5.setUint32(4 * f5, l4[f5], s2);
  }
  digest() {
    const { buffer: t, outputLen: n4 } = this;
    this.digestInto(t);
    const r3 = t.slice(0, n4);
    return this.destroy(), r3;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n4, buffer: r3, length: o4, finished: s2, destroyed: i4, pos: c5 } = this;
    return t.length = o4, t.pos = c5, t.finished = s2, t.destroyed = i4, o4 % n4 && t.buffer.set(r3), t;
  }
};
var Bs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce = new Uint32Array(64);
var js = class extends Ls {
  constructor() {
    super(64, 32, 8, false), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;
  }
  get() {
    const { A: t, B: n4, C: r3, D: o4, E: s2, F: i4, G: c5, H: u4 } = this;
    return [t, n4, r3, o4, s2, i4, c5, u4];
  }
  set(t, n4, r3, o4, s2, i4, c5, u4) {
    this.A = t | 0, this.B = n4 | 0, this.C = r3 | 0, this.D = o4 | 0, this.E = s2 | 0, this.F = i4 | 0, this.G = c5 | 0, this.H = u4 | 0;
  }
  process(t, n4) {
    for (let f5 = 0; f5 < 16; f5++, n4 += 4)
      ce[f5] = t.getUint32(n4, false);
    for (let f5 = 16; f5 < 64; f5++) {
      const d5 = ce[f5 - 15], g6 = ce[f5 - 2], y7 = J(d5, 7) ^ J(d5, 18) ^ d5 >>> 3, h6 = J(g6, 17) ^ J(g6, 19) ^ g6 >>> 10;
      ce[f5] = h6 + ce[f5 - 7] + y7 + ce[f5 - 16] | 0;
    }
    let { A: r3, B: o4, C: s2, D: i4, E: c5, F: u4, G: a5, H: l4 } = this;
    for (let f5 = 0; f5 < 64; f5++) {
      const d5 = J(c5, 6) ^ J(c5, 11) ^ J(c5, 25), g6 = l4 + d5 + Rs(c5, u4, a5) + Bs[f5] + ce[f5] | 0, h6 = (J(r3, 2) ^ J(r3, 13) ^ J(r3, 22)) + Ps(r3, o4, s2) | 0;
      l4 = a5, a5 = u4, u4 = c5, c5 = i4 + g6 | 0, i4 = s2, s2 = o4, o4 = r3, r3 = g6 + h6 | 0;
    }
    r3 = r3 + this.A | 0, o4 = o4 + this.B | 0, s2 = s2 + this.C | 0, i4 = i4 + this.D | 0, c5 = c5 + this.E | 0, u4 = u4 + this.F | 0, a5 = a5 + this.G | 0, l4 = l4 + this.H | 0, this.set(r3, o4, s2, i4, c5, u4, a5, l4);
  }
  roundClean() {
    ce.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He = fn(() => new js());
var Wn = BigInt(0);
function wt(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn(e) {
  if (!wt(e))
    throw new Error("Uint8Array expected");
}
var Cs = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ks(e) {
  zn(e);
  let t = "";
  for (let n4 = 0; n4 < e.length; n4++)
    t += Cs[e[n4]];
  return t;
}
function Ds(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Wn : BigInt("0x" + e);
}
var ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn(e) {
  if (e >= ee._0 && e <= ee._9)
    return e - ee._0;
  if (e >= ee.A && e <= ee.F)
    return e - (ee.A - 10);
  if (e >= ee.a && e <= ee.f)
    return e - (ee.a - 10);
}
function Yn(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n4 = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const r3 = new Uint8Array(n4);
  for (let o4 = 0, s2 = 0; o4 < n4; o4++, s2 += 2) {
    const i4 = Jn(e.charCodeAt(s2)), c5 = Jn(e.charCodeAt(s2 + 1));
    if (i4 === void 0 || c5 === void 0) {
      const u4 = e[s2] + e[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + u4 + '" at index ' + s2);
    }
    r3[o4] = i4 * 16 + c5;
  }
  return r3;
}
function Xn(e) {
  return zn(e), Ds(ks(Uint8Array.from(e).reverse()));
}
function Ms(e, t) {
  return Yn(e.toString(16).padStart(t * 2, "0"));
}
function Vs(e, t) {
  return Ms(e, t).reverse();
}
function Zn(e, t, n4) {
  let r3;
  if (typeof t == "string")
    try {
      r3 = Yn(t);
    } catch (s2) {
      throw new Error(e + " must be hex string or Uint8Array, cause: " + s2);
    }
  else if (wt(t))
    r3 = Uint8Array.from(t);
  else
    throw new Error(e + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n4 == "number" && o4 !== n4)
    throw new Error(e + " of length " + n4 + " expected, got " + o4);
  return r3;
}
var Et = (e) => typeof e == "bigint" && Wn <= e;
function Hs(e, t, n4) {
  return Et(e) && Et(t) && Et(n4) && t <= e && e < n4;
}
function Qn(e, t, n4, r3) {
  if (!Hs(t, n4, r3))
    throw new Error("expected valid " + e + ": " + n4 + " <= n < " + r3 + ", got " + t);
}
var Ks = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || wt(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Fs(e, t, n4 = {}) {
  const r3 = (o4, s2, i4) => {
    const c5 = Ks[s2];
    if (typeof c5 != "function")
      throw new Error("invalid validator function");
    const u4 = e[o4];
    if (!(i4 && u4 === void 0) && !c5(u4, e))
      throw new Error("param " + String(o4) + " is invalid. Expected " + s2 + ", got " + u4);
  };
  for (const [o4, s2] of Object.entries(t))
    r3(o4, s2, false);
  for (const [o4, s2] of Object.entries(n4))
    r3(o4, s2, true);
  return e;
}
var ve = BigInt(0);
var Ke = BigInt(1);
function er(e, t) {
  const n4 = e % t;
  return n4 >= ve ? n4 : t + n4;
}
function qs(e, t, n4) {
  if (t < ve)
    throw new Error("invalid exponent, negatives unsupported");
  if (n4 <= ve)
    throw new Error("invalid modulus");
  if (n4 === Ke)
    return ve;
  let r3 = Ke;
  for (; t > ve; )
    t & Ke && (r3 = r3 * e % n4), e = e * e % n4, t >>= Ke;
  return r3;
}
function z(e, t, n4) {
  let r3 = e;
  for (; t-- > ve; )
    r3 *= r3, r3 %= n4;
  return r3;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe = BigInt(0);
var vt = BigInt(1);
function Gs(e) {
  return Fs(e, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e });
}
function Ws(e) {
  const t = Gs(e), { P: n4 } = t, r3 = (b6) => er(b6, n4), o4 = t.montgomeryBits, s2 = Math.ceil(o4 / 8), i4 = t.nByteLength, c5 = t.adjustScalarBytes || ((b6) => b6), u4 = t.powPminus2 || ((b6) => qs(b6, n4 - BigInt(2), n4));
  function a5(b6, _4, I5) {
    const k4 = r3(b6 * (_4 - I5));
    return _4 = r3(_4 - k4), I5 = r3(I5 + k4), [_4, I5];
  }
  const l4 = (t.a - BigInt(2)) / BigInt(4);
  function f5(b6, _4) {
    Qn("u", b6, xe, n4), Qn("scalar", _4, xe, n4);
    const I5 = _4, k4 = b6;
    let E4 = vt, L4 = xe, j4 = b6, v8 = vt, O5 = xe, w5;
    for (let A5 = BigInt(o4 - 1); A5 >= xe; A5--) {
      const T4 = I5 >> A5 & vt;
      O5 ^= T4, w5 = a5(O5, E4, j4), E4 = w5[0], j4 = w5[1], w5 = a5(O5, L4, v8), L4 = w5[0], v8 = w5[1], O5 = T4;
      const N3 = E4 + L4, S7 = r3(N3 * N3), U6 = E4 - L4, $7 = r3(U6 * U6), p4 = S7 - $7, C7 = j4 + v8, D4 = j4 - v8, P4 = r3(D4 * N3), G3 = r3(C7 * U6), X4 = P4 + G3, Z6 = P4 - G3;
      j4 = r3(X4 * X4), v8 = r3(k4 * r3(Z6 * Z6)), E4 = r3(S7 * $7), L4 = r3(p4 * (S7 + r3(l4 * p4)));
    }
    w5 = a5(O5, E4, j4), E4 = w5[0], j4 = w5[1], w5 = a5(O5, L4, v8), L4 = w5[0], v8 = w5[1];
    const R5 = u4(L4);
    return r3(E4 * R5);
  }
  function d5(b6) {
    return Vs(r3(b6), s2);
  }
  function g6(b6) {
    const _4 = Zn("u coordinate", b6, s2);
    return i4 === 32 && (_4[31] &= 127), Xn(_4);
  }
  function y7(b6) {
    const _4 = Zn("scalar", b6), I5 = _4.length;
    if (I5 !== s2 && I5 !== i4) {
      let k4 = "" + s2 + " or " + i4;
      throw new Error("invalid scalar, expected " + k4 + " bytes, got " + I5);
    }
    return Xn(c5(_4));
  }
  function h6(b6, _4) {
    const I5 = g6(_4), k4 = y7(b6), E4 = f5(I5, k4);
    if (E4 === xe)
      throw new Error("invalid private or public key received");
    return d5(E4);
  }
  const m = d5(t.Gu);
  function B6(b6) {
    return h6(b6, m);
  }
  return { scalarMult: h6, scalarMultBase: B6, getSharedSecret: (b6, _4) => h6(b6, _4), getPublicKey: (b6) => B6(b6), utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) }, GuBytes: m };
}
var xt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var zs = BigInt(1);
var tr = BigInt(2);
var Js = BigInt(3);
var Ys = BigInt(5);
BigInt(8);
function Xs(e) {
  const t = BigInt(10), n4 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), s2 = xt, c5 = e * e % s2 * e % s2, u4 = z(c5, tr, s2) * c5 % s2, a5 = z(u4, zs, s2) * e % s2, l4 = z(a5, Ys, s2) * a5 % s2, f5 = z(l4, t, s2) * l4 % s2, d5 = z(f5, n4, s2) * f5 % s2, g6 = z(d5, r3, s2) * d5 % s2, y7 = z(g6, o4, s2) * g6 % s2, h6 = z(y7, o4, s2) * g6 % s2, m = z(h6, t, s2) * l4 % s2;
  return { pow_p_5_8: z(m, tr, s2) * e % s2, b2: c5 };
}
function Zs(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var Ot = (() => Ws({ P: xt, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e) => {
  const t = xt, { pow_p_5_8: n4, b2: r3 } = Xs(e);
  return er(z(n4, Js, t) * r3, t);
}, adjustScalarBytes: Zs, randomBytes: Se }))();
var It = "base10";
var V = "base16";
var At = "base64pad";
var Oe = "utf8";
var Nt = 0;
var Ie = 1;
var _e = 2;
var ei = 0;
var nr = 1;
var Te = 12;
var St = 32;
function ti() {
  const e = Ot.utils.randomPrivateKey(), t = Ot.getPublicKey(e);
  return { privateKey: toString(e, V), publicKey: toString(t, V) };
}
function ni() {
  const e = Se(St);
  return toString(e, V);
}
function ri(e, t) {
  const n4 = Ot.getSharedSecret(fromString(e, V), fromString(t, V)), r3 = Ts(He, n4, void 0, void 0, St);
  return toString(r3, V);
}
function oi(e) {
  const t = He(fromString(e, V));
  return toString(t, V);
}
function si(e) {
  const t = He(fromString(e, Oe));
  return toString(t, V);
}
function Ut(e) {
  return fromString(`${e}`, It);
}
function fe(e) {
  return Number(toString(e, It));
}
function ii(e) {
  const t = Ut(typeof e.type < "u" ? e.type : Nt);
  if (fe(t) === Ie && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const n4 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, V) : Se(Te), o4 = fromString(e.symKey, V), s2 = Fn(o4, r3).encrypt(fromString(e.message, Oe));
  return _t({ type: t, sealed: s2, iv: r3, senderPublicKey: n4, encoding: e.encoding });
}
function ci(e) {
  const t = fromString(e.symKey, V), { sealed: n4, iv: r3 } = Fe(e), o4 = Fn(t, r3).decrypt(n4);
  if (o4 === null)
    throw new Error("Failed to decrypt");
  return toString(o4, Oe);
}
function ai(e, t) {
  const n4 = Ut(_e), r3 = Se(Te), o4 = fromString(e, Oe);
  return _t({ type: n4, sealed: o4, iv: r3, encoding: t });
}
function ui(e, t) {
  const { sealed: n4 } = Fe({ encoded: e, encoding: t });
  return toString(n4, Oe);
}
function _t(e) {
  const { encoding: t = At } = e;
  if (fe(e.type) === _e)
    return toString(concat([e.type, e.sealed]), t);
  if (fe(e.type) === Ie) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
  }
  return toString(concat([e.type, e.iv, e.sealed]), t);
}
function Fe(e) {
  const { encoded: t, encoding: n4 = At } = e, r3 = fromString(t, n4), o4 = r3.slice(ei, nr), s2 = nr;
  if (fe(o4) === Ie) {
    const a5 = s2 + St, l4 = a5 + Te, f5 = r3.slice(s2, a5), d5 = r3.slice(a5, l4), g6 = r3.slice(l4);
    return { type: o4, sealed: g6, iv: d5, senderPublicKey: f5 };
  }
  if (fe(o4) === _e) {
    const a5 = r3.slice(s2), l4 = Se(Te);
    return { type: o4, sealed: a5, iv: l4 };
  }
  const i4 = s2 + Te, c5 = r3.slice(s2, i4), u4 = r3.slice(i4);
  return { type: o4, sealed: u4, iv: c5 };
}
function fi(e, t) {
  const n4 = Fe({ encoded: e, encoding: t == null ? void 0 : t.encoding });
  return rr({ type: fe(n4.type), senderPublicKey: typeof n4.senderPublicKey < "u" ? toString(n4.senderPublicKey, V) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function rr(e) {
  const t = (e == null ? void 0 : e.type) || Nt;
  if (t === Ie) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function li(e) {
  return e.type === Ie && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function di(e) {
  return e.type === _e;
}
function or(e) {
  return new import_elliptic.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function hi(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  const n4 = t.length % 4;
  return n4 > 0 && (t += "=".repeat(4 - n4)), t;
}
function pi(e) {
  return Buffer.from(hi(e), "base64");
}
function gi(e, t) {
  const [n4, r3, o4] = e.split("."), s2 = pi(o4);
  if (s2.length !== 64)
    throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), c5 = s2.slice(32, 64).toString("hex"), u4 = `${n4}.${r3}`, a5 = He(u4), l4 = or(t), f5 = toString(a5, V);
  if (!l4.verify(f5, { r: i4, s: c5 }))
    throw new Error("Invalid signature");
  return sn(e).payload;
}
var sr = "irn";
function yi(e) {
  return (e == null ? void 0 : e.relay) || { protocol: sr };
}
function mi(e) {
  const t = C[e];
  if (typeof t > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
function ir(e, t = "-") {
  const n4 = {}, r3 = "relay" + t;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i4 = e[o4];
      n4[s2] = i4;
    }
  }), n4;
}
function bi(e) {
  if (!e.includes("wc:")) {
    const a5 = rt(e);
    a5 != null && a5.includes("wc:") && (e = a5);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"), n4 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, t), o4 = e.substring(t + 1, n4).split("@"), s2 = typeof n4 < "u" ? e.substring(n4) : "", i4 = new URLSearchParams(s2), c5 = {};
  i4.forEach((a5, l4) => {
    c5[l4] = a5;
  });
  const u4 = typeof c5.methods == "string" ? c5.methods.split(",") : void 0;
  return { protocol: r3, topic: cr(o4[0]), version: parseInt(o4[1], 10), symKey: c5.symKey, relay: ir(c5), methods: u4, expiryTimestamp: c5.expiryTimestamp ? parseInt(c5.expiryTimestamp, 10) : void 0 };
}
function cr(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ar(e, t = "-") {
  const n4 = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = n4 + t + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function wi(e) {
  const t = new URLSearchParams(), n4 = ar(e.relay);
  Object.keys(n4).sort().forEach((o4) => {
    t.set(o4, n4[o4]);
  }), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
  const r3 = t.toString();
  return `${e.protocol}:${e.topic}@${e.version}?${r3}`;
}
var yr = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var mr = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te(e, t) {
  const { message: n4, code: r3 } = mr[e];
  return { message: t ? `${n4} ${t}` : n4, code: r3 };
}
function de(e, t) {
  const { message: n4, code: r3 } = yr[e];
  return { message: t ? `${n4} ${t}` : n4, code: r3 };
}
function ae(e) {
  return typeof e > "u";
}
function q(e, t) {
  return t && ae(e) ? true : typeof e == "string" && !!e.trim().length;
}
function Ge(e, t) {
  return t && ae(e) ? true : typeof e == "number" && !isNaN(e);
}
function Ri(e) {
  function t(n4) {
    try {
      return typeof new URL(n4) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q(e, false)) {
      if (t(e))
        return true;
      const n4 = rt(e);
      return t(n4);
    }
  } catch {
  }
  return false;
}
function Pi(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey;
}
function Li(e) {
  return e == null ? void 0 : e.topic;
}
function Di(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ji(e, t) {
  return Ge(e, false) && e <= t.max && e >= t.min;
}
function Yi() {
  const e = ue();
  return new Promise((t) => {
    switch (e) {
      case H.browser:
        t(Ur());
        break;
      case H.reactNative:
        t(_r());
        break;
      case H.node:
        t(Tr());
        break;
      default:
        t(true);
    }
  });
}
function Ur() {
  return Ae() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r() {
  if (ne() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Tr() {
  return true;
}
function Xi(e) {
  switch (ue()) {
    case H.browser:
      $r(e);
      break;
    case H.reactNative:
      Rr(e);
      break;
    case H.node:
      break;
  }
}
function $r(e) {
  !ne() && Ae() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function Rr(e) {
  ne() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((t) => e(t == null ? void 0 : t.isConnected)));
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var o2 = class extends r {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  async request(t, e) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e);
  }
  async requestStrict(t, e) {
    return new Promise(async (i4, s2) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (n4) {
          s2(n4);
        }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i4(n4.result);
      });
      try {
        await this.connection.send(t, e);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var v2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser2();
var w = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d2 = (r3) => r3.split("?")[0];
var h3 = 10;
var b = v2();
var f = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, s2) => {
        this.events.once("register_error", (o4) => {
          this.resetMaxListeners(), s2(o4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return s2(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const s2 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, o4 = new b(e, [], s2);
      w() ? o4.onerror = (i4) => {
        const a5 = i4;
        n4(this.emitError(a5.error));
      } : o4.on("error", (i4) => {
        n4(this.emitError(i4));
      }), o4.onopen = () => {
        this.onOpen(o4), t(o4);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), s2 = n4.message || n4.toString(), o4 = formatJsonRpcError(e, s2);
    this.events.emit("payload", o4);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, d2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_window_getters2 = __toESM(require_cjs2());
var ye = "wc";
var De = 2;
var J2 = "core";
var A2 = `${ye}@2:${J2}:`;
var Xe = { name: J2, logger: "error" };
var We2 = { database: ":memory:" };
var Ze = "crypto";
var me2 = "client_ed25519_seed";
var Qe2 = import_time3.ONE_DAY;
var et2 = "keychain";
var tt2 = "0.3";
var it2 = "messages";
var st2 = "0.3";
var be2 = import_time3.SIX_HOURS;
var rt2 = "publisher";
var nt = "irn";
var ot2 = "error";
var fe2 = "wss://relay.walletconnect.org";
var at = "relayer";
var v3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ct = "_subscription";
var C3 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht2 = 0.1;
var re = "2.18.0";
var M2 = { link_mode: "link_mode", relay: "relay" };
var lt = "0.3";
var ut = "WALLETCONNECT_CLIENT_ID";
var ve2 = "WALLETCONNECT_LINK_MODE_APPS";
var T = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var dt = "subscription";
var pt2 = "0.3";
var gt2 = import_time3.FIVE_SECONDS * 1e3;
var yt2 = "pairing";
var Dt = "0.3";
var V2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var j = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var mt2 = "history";
var bt2 = "0.3";
var ft = "expirer";
var x3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var vt2 = "0.3";
var _t2 = "verify-api";
var Ss2 = "https://verify.walletconnect.com";
var Et2 = "https://verify.walletconnect.org";
var X = Et2;
var wt2 = `${X}/v3`;
var It2 = [Ss2, Et2];
var Tt = "echo";
var Ct2 = "https://echo.walletconnect.com";
var z2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $ = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Pt = 0.1;
var St2 = "event-client";
var Rt = 86400;
var xt2 = "https://pulse.walletconnect.org/batch";
function zs2(o4, e) {
  if (o4.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++)
    t[s2] = 255;
  for (var i4 = 0; i4 < o4.length; i4++) {
    var r3 = o4.charAt(i4), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255)
      throw new TypeError(r3 + " is ambiguous");
    t[n4] = i4;
  }
  var a5 = o4.length, c5 = o4.charAt(0), h6 = Math.log(a5) / Math.log(256), u4 = Math.log(256) / Math.log(a5);
  function d5(l4) {
    if (l4 instanceof Uint8Array || (ArrayBuffer.isView(l4) ? l4 = new Uint8Array(l4.buffer, l4.byteOffset, l4.byteLength) : Array.isArray(l4) && (l4 = Uint8Array.from(l4))), !(l4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l4.length === 0)
      return "";
    for (var g6 = 0, w5 = 0, b6 = 0, D4 = l4.length; b6 !== D4 && l4[b6] === 0; )
      b6++, g6++;
    for (var P4 = (D4 - b6) * u4 + 1 >>> 0, f5 = new Uint8Array(P4); b6 !== D4; ) {
      for (var N3 = l4[b6], k4 = 0, O5 = P4 - 1; (N3 !== 0 || k4 < w5) && O5 !== -1; O5--, k4++)
        N3 += 256 * f5[O5] >>> 0, f5[O5] = N3 % a5 >>> 0, N3 = N3 / a5 >>> 0;
      if (N3 !== 0)
        throw new Error("Non-zero carry");
      w5 = k4, b6++;
    }
    for (var L4 = P4 - w5; L4 !== P4 && f5[L4] === 0; )
      L4++;
    for (var ee6 = c5.repeat(g6); L4 < P4; ++L4)
      ee6 += o4.charAt(f5[L4]);
    return ee6;
  }
  function y7(l4) {
    if (typeof l4 != "string")
      throw new TypeError("Expected String");
    if (l4.length === 0)
      return new Uint8Array();
    var g6 = 0;
    if (l4[g6] !== " ") {
      for (var w5 = 0, b6 = 0; l4[g6] === c5; )
        w5++, g6++;
      for (var D4 = (l4.length - g6) * h6 + 1 >>> 0, P4 = new Uint8Array(D4); l4[g6]; ) {
        var f5 = t[l4.charCodeAt(g6)];
        if (f5 === 255)
          return;
        for (var N3 = 0, k4 = D4 - 1; (f5 !== 0 || N3 < b6) && k4 !== -1; k4--, N3++)
          f5 += a5 * P4[k4] >>> 0, P4[k4] = f5 % 256 >>> 0, f5 = f5 / 256 >>> 0;
        if (f5 !== 0)
          throw new Error("Non-zero carry");
        b6 = N3, g6++;
      }
      if (l4[g6] !== " ") {
        for (var O5 = D4 - b6; O5 !== D4 && P4[O5] === 0; )
          O5++;
        for (var L4 = new Uint8Array(w5 + (D4 - O5)), ee6 = w5; O5 !== D4; )
          L4[ee6++] = P4[O5++];
        return L4;
      }
    }
  }
  function m(l4) {
    var g6 = y7(l4);
    if (g6)
      return g6;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d5, decodeUnsafe: y7, decode: m };
}
var Ls2 = zs2;
var $s2 = Ls2;
var Ot2 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array")
    return o4;
  if (o4 instanceof ArrayBuffer)
    return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4))
    return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ks2 = (o4) => new TextEncoder().encode(o4);
var Us2 = (o4) => new TextDecoder().decode(o4);
var Fs2 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Ms2 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return At2(this, e);
  }
};
var Ks2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return At2(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2)
      return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var At2 = (o4, e) => new Ks2({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var Bs2 = class {
  constructor(e, t, s2, i4) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Fs2(e, t, s2), this.decoder = new Ms2(e, t, i4);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var ne2 = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new Bs2(o4, e, t, s2);
var W = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i4 } = $s2(t, e);
  return ne2({ prefix: o4, name: e, encode: s2, decode: (r3) => Ot2(i4(r3)) });
};
var Vs2 = (o4, e, t, s2) => {
  const i4 = {};
  for (let u4 = 0; u4 < e.length; ++u4)
    i4[e[u4]] = u4;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; )
    --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, c5 = 0, h6 = 0;
  for (let u4 = 0; u4 < r3; ++u4) {
    const d5 = i4[o4[u4]];
    if (d5 === void 0)
      throw new SyntaxError(`Non-${s2} character`);
    c5 = c5 << t | d5, a5 += t, a5 >= 8 && (a5 -= 8, n4[h6++] = 255 & c5 >> a5);
  }
  if (a5 >= t || 255 & c5 << 8 - a5)
    throw new SyntaxError("Unexpected end of data");
  return n4;
};
var js2 = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i4 = (1 << t) - 1;
  let r3 = "", n4 = 0, a5 = 0;
  for (let c5 = 0; c5 < o4.length; ++c5)
    for (a5 = a5 << 8 | o4[c5], n4 += 8; n4 > t; )
      n4 -= t, r3 += e[i4 & a5 >> n4];
  if (n4 && (r3 += e[i4 & a5 << t - n4]), s2)
    for (; r3.length * t & 7; )
      r3 += "=";
  return r3;
};
var _ = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => ne2({ prefix: e, name: o4, encode(i4) {
  return js2(i4, s2, t);
}, decode(i4) {
  return Vs2(i4, s2, t, o4);
} });
var qs2 = ne2({ prefix: "\0", name: "identity", encode: (o4) => Us2(o4), decode: (o4) => ks2(o4) });
var Gs2 = Object.freeze({ __proto__: null, identity: qs2 });
var Hs2 = _({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ys2 = Object.freeze({ __proto__: null, base2: Hs2 });
var Js2 = _({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Xs2 = Object.freeze({ __proto__: null, base8: Js2 });
var Ws2 = W({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Zs2 = Object.freeze({ __proto__: null, base10: Ws2 });
var Qs = _({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var er2 = _({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var tr2 = Object.freeze({ __proto__: null, base16: Qs, base16upper: er2 });
var ir2 = _({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var sr2 = _({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var rr2 = _({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var nr2 = _({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var or2 = _({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ar2 = _({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var cr2 = _({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var hr = _({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var lr = _({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ur = Object.freeze({ __proto__: null, base32: ir2, base32upper: sr2, base32pad: rr2, base32padupper: nr2, base32hex: or2, base32hexupper: ar2, base32hexpad: cr2, base32hexpadupper: hr, base32z: lr });
var dr = W({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var pr = W({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var gr = Object.freeze({ __proto__: null, base36: dr, base36upper: pr });
var yr2 = W({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Dr = W({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var mr2 = Object.freeze({ __proto__: null, base58btc: yr2, base58flickr: Dr });
var br = _({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var fr = _({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var vr = _({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var _r2 = _({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Er = Object.freeze({ __proto__: null, base64: br, base64pad: fr, base64url: vr, base64urlpad: _r2 });
var Nt2 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var wr = Nt2.reduce((o4, e, t) => (o4[t] = e, o4), []);
var Ir = Nt2.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function Tr2(o4) {
  return o4.reduce((e, t) => (e += wr[t], e), "");
}
function Cr(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = Ir[t.codePointAt(0)];
    if (s2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Pr = ne2({ prefix: "🚀", name: "base256emoji", encode: Tr2, decode: Cr });
var Sr = Object.freeze({ __proto__: null, base256emoji: Pr });
var Rr2 = Lt;
var zt2 = 128;
var xr = 127;
var Or = ~xr;
var Ar = Math.pow(2, 31);
function Lt(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Ar; )
    e[t++] = o4 & 255 | zt2, o4 /= 128;
  for (; o4 & Or; )
    e[t++] = o4 & 255 | zt2, o4 >>>= 7;
  return e[t] = o4 | 0, Lt.bytes = t - s2 + 1, e;
}
var Nr = _e2;
var zr2 = 128;
var $t = 127;
function _e2(o4, s2) {
  var t = 0, s2 = s2 || 0, i4 = 0, r3 = s2, n4, a5 = o4.length;
  do {
    if (r3 >= a5)
      throw _e2.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i4 < 28 ? (n4 & $t) << i4 : (n4 & $t) * Math.pow(2, i4), i4 += 7;
  } while (n4 >= zr2);
  return _e2.bytes = r3 - s2, t;
}
var Lr2 = Math.pow(2, 7);
var $r2 = Math.pow(2, 14);
var kr2 = Math.pow(2, 21);
var Ur2 = Math.pow(2, 28);
var Fr = Math.pow(2, 35);
var Mr = Math.pow(2, 42);
var Kr = Math.pow(2, 49);
var Br2 = Math.pow(2, 56);
var Vr = Math.pow(2, 63);
var jr = function(o4) {
  return o4 < Lr2 ? 1 : o4 < $r2 ? 2 : o4 < kr2 ? 3 : o4 < Ur2 ? 4 : o4 < Fr ? 5 : o4 < Mr ? 6 : o4 < Kr ? 7 : o4 < Br2 ? 8 : o4 < Vr ? 9 : 10;
};
var qr = { encode: Rr2, decode: Nr, encodingLength: jr };
var kt2 = qr;
var Ut2 = (o4, e, t = 0) => (kt2.encode(o4, e, t), e);
var Ft2 = (o4) => kt2.encodingLength(o4);
var Ee2 = (o4, e) => {
  const t = e.byteLength, s2 = Ft2(o4), i4 = s2 + Ft2(t), r3 = new Uint8Array(i4 + t);
  return Ut2(o4, r3, 0), Ut2(t, r3, s2), r3.set(e, i4), new Gr(o4, t, e, r3);
};
var Gr = class {
  constructor(e, t, s2, i4) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i4;
  }
};
var Mt = ({ name: o4, code: e, encode: t }) => new Hr(o4, e, t);
var Hr = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ee2(this.code, t) : t.then((s2) => Ee2(this.code, s2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Kt = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var Yr2 = Mt({ name: "sha2-256", code: 18, encode: Kt("SHA-256") });
var Jr2 = Mt({ name: "sha2-512", code: 19, encode: Kt("SHA-512") });
var Xr = Object.freeze({ __proto__: null, sha256: Yr2, sha512: Jr2 });
var Bt2 = 0;
var Wr2 = "identity";
var Vt = Ot2;
var Zr2 = (o4) => Ee2(Bt2, Vt(o4));
var Qr = { code: Bt2, name: Wr2, encode: Vt, digest: Zr2 };
var en = Object.freeze({ __proto__: null, identity: Qr });
new TextEncoder(), new TextDecoder();
var jt2 = { ...Gs2, ...Ys2, ...Xs2, ...Zs2, ...tr2, ...ur, ...gr, ...mr2, ...Er, ...Sr };
({ ...Xr, ...en });
function tn(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function qt(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var Gt2 = qt("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var we2 = qt("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++)
    e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = tn(o4.length);
  for (let t = 0; t < o4.length; t++)
    e[t] = o4.charCodeAt(t);
  return e;
});
var sn3 = { utf8: Gt2, "utf-8": Gt2, hex: jt2.base16, latin1: we2, ascii: we2, binary: we2, ...jt2 };
function rn(o4, e = "utf8") {
  const t = sn3[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Ht = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = et2, this.version = tt2, this.initialized = false, this.storagePrefix = A2, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = te("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt2 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Ze, this.randomSessionIdentifier = ni(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i4) => (this.isInitialized(), this.keychain.has(i4)), this.getClientId = async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = Po(i4);
      return Qe(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i4 = ti();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }, this.signJWT = async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = Po(r3), a5 = this.randomSessionIdentifier, c5 = Qe2;
      return await Qo(a5, i4, c5, n4);
    }, this.generateSharedKey = (i4, r3, n4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i4), c5 = ri(a5, r3);
      return this.setSymKey(c5, n4);
    }, this.setSymKey = async (i4, r3) => {
      this.isInitialized();
      const n4 = r3 || oi(i4);
      return await this.keychain.set(n4, i4), n4;
    }, this.deleteKeyPair = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.deleteSymKey = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.encode = async (i4, r3, n4) => {
      this.isInitialized();
      const a5 = rr(n4), c5 = safeJsonStringify(r3);
      if (di(a5))
        return ai(c5, n4 == null ? void 0 : n4.encoding);
      if (li(a5)) {
        const y7 = a5.senderPublicKey, m = a5.receiverPublicKey;
        i4 = await this.generateSharedKey(y7, m);
      }
      const h6 = this.getSymKey(i4), { type: u4, senderPublicKey: d5 } = a5;
      return ii({ type: u4, symKey: h6, message: c5, senderPublicKey: d5, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i4, r3, n4) => {
      this.isInitialized();
      const a5 = fi(r3, n4);
      if (di(a5)) {
        const c5 = ui(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(c5);
      }
      if (li(a5)) {
        const c5 = a5.receiverPublicKey, h6 = a5.senderPublicKey;
        i4 = await this.generateSharedKey(c5, h6);
      }
      try {
        const c5 = this.getSymKey(i4), h6 = ci({ symKey: c5, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(h6);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }, this.getPayloadType = (i4, r3 = At) => {
      const n4 = Fe({ encoded: i4, encoding: r3 });
      return fe(n4.type);
    }, this.getPayloadSenderPublicKey = (i4, r3 = At) => {
      const n4 = Fe({ encoded: i4, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, V) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Ht(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me2);
    } catch {
      e = ni(), await this.keychain.set(me2, e);
    }
    return rn(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Jt2 = class extends a2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = it2, this.version = st2, this.initialized = false, this.storagePrefix = A2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i4) => {
      this.isInitialized();
      const r3 = si(i4);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i4, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }, this.has = (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = si(i4);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var nn = Object.defineProperty;
var on = Object.defineProperties;
var an2 = Object.getOwnPropertyDescriptors;
var Xt = Object.getOwnPropertySymbols;
var cn2 = Object.prototype.hasOwnProperty;
var hn2 = Object.prototype.propertyIsEnumerable;
var Wt2 = (o4, e, t) => e in o4 ? nn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Zt = (o4, e) => {
  for (var t in e || (e = {}))
    cn2.call(e, t) && Wt2(o4, t, e[t]);
  if (Xt)
    for (var t of Xt(e))
      hn2.call(e, t) && Wt2(o4, t, e[t]);
  return o4;
};
var Qt = (o4, e) => on(o4, an2(e));
var ln2 = class extends g {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events7.EventEmitter(), this.name = rt2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.initialPublishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15), this.needsTransportRestart = false, this.publish = async (s2, i4, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || be2, c5 = yi(r3), h6 = (r3 == null ? void 0 : r3.prompt) || false, u4 = (r3 == null ? void 0 : r3.tag) || 0, d5 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), y7 = { topic: s2, message: i4, opts: { ttl: a5, relay: c5, prompt: h6, tag: u4, id: d5, attestation: r3 == null ? void 0 : r3.attestation } }, m = `Failed to publish payload, please try again. id:${d5} tag:${u4}`;
      try {
        const l4 = new Promise(async (g6) => {
          const w5 = ({ id: D4 }) => {
            y7.opts.id === D4 && (this.removeRequestFromQueue(D4), this.relayer.events.removeListener(v3.publish, w5), g6(y7));
          };
          this.relayer.events.on(v3.publish, w5);
          const b6 = ao(new Promise((D4, P4) => {
            this.rpcPublish({ topic: s2, message: i4, ttl: a5, prompt: h6, tag: u4, id: d5, attestation: r3 == null ? void 0 : r3.attestation }).then(D4).catch((f5) => {
              this.logger.warn(f5, f5 == null ? void 0 : f5.message), P4(f5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d5} tag:${u4}`);
          try {
            await b6, this.events.removeListener(v3.publish, w5);
          } catch (D4) {
            this.queue.set(d5, Qt(Zt({}, y7), { attempt: 1 })), this.logger.warn(D4, D4 == null ? void 0 : D4.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d5, topic: s2, message: i4, opts: r3 } }), await ao(l4, this.publishTimeout, m);
      } catch (l4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l4), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish)
          throw l4;
      } finally {
        this.queue.delete(d5);
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, s2, i4, r3;
    const { topic: n4, message: a5, ttl: c5 = be2, prompt: h6, tag: u4, id: d5, attestation: y7 } = e, m = { method: mi(yi().protocol).publish, params: { topic: n4, message: a5, ttl: c5, prompt: h6, tag: u4, attestation: y7 }, id: d5 };
    ae((t = m.params) == null ? void 0 : t.prompt) && ((s2 = m.params) == null || delete s2.prompt), ae((i4 = m.params) == null ? void 0 : i4.tag) && ((r3 = m.params) == null || delete r3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m });
    const l4 = await this.relayer.request(m);
    return this.relayer.events.emit(v3.publish, e), this.logger.debug("Successfully Published Payload"), l4;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const s2 = e.attempt + 1;
      this.queue.set(t, Qt(Zt({}, e), { attempt: s2 }));
      const { topic: i4, message: r3, opts: n4, attestation: a5 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s2}`), await this.rpcPublish({ topic: i4, message: r3, ttl: n4.ttl, prompt: n4.prompt, tag: n4.tag, id: n4.id, attestation: a5 }), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var un2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const s2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const i4 = s2.filter((r3) => r3 !== t);
      if (!i4.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i4);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var dn2 = Object.defineProperty;
var pn2 = Object.defineProperties;
var gn2 = Object.getOwnPropertyDescriptors;
var ei2 = Object.getOwnPropertySymbols;
var yn = Object.prototype.hasOwnProperty;
var Dn2 = Object.prototype.propertyIsEnumerable;
var ti2 = (o4, e, t) => e in o4 ? dn2(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Z = (o4, e) => {
  for (var t in e || (e = {}))
    yn.call(e, t) && ti2(o4, t, e[t]);
  if (ei2)
    for (var t of ei2(e))
      Dn2.call(e, t) && ti2(o4, t, e[t]);
  return o4;
};
var Ie2 = (o4, e) => pn2(o4, gn2(e));
var ii2 = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new un2(), this.events = new import_events7.EventEmitter(), this.name = dt, this.version = pt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = A2, this.subscribeTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.initialSubscribeTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15), this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = yi(i4), n4 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, n4);
        const a5 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a5 == "string" && (this.onSubscribe(a5, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i4) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2))
        return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a5 = new import_time3.Watch();
        a5.start(i4);
        const c5 = setInterval(() => {
          (!this.pending.has(s2) && this.topics.includes(s2) || this.cached.some((h6) => h6.topic === s2)) && (clearInterval(c5), a5.stop(i4), r3(true)), a5.elapsed(i4) >= gt2 && (clearInterval(c5), a5.stop(i4), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      await this.restore(), await this.onRestart();
    }, this.checkPending = async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
        return;
      const s2 = [];
      this.pending.forEach((i4) => {
        s2.push(i4);
      }), await this.batchSubscribe(s2);
    }, this.registerEventListeners = () => {
      this.relayer.core.heartbeat.on(r2.pulse, async () => {
        await this.checkPending();
      }), this.events.on(T.created, async (s2) => {
        const i4 = T.created;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      }), this.events.on(T.deleted, async (s2) => {
        const i4 = T.deleted;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      });
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e, i4, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i4 = yi(s2);
      await this.rpcUnsubscribe(e, t, i4);
      const r3 = de("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i4;
    (s2 == null ? void 0 : s2.transportType) === M2.relay && await this.restartToComplete();
    const r3 = { method: mi(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const n4 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a5 = this.getSubscriptionId(e);
      if ((s2 == null ? void 0 : s2.transportType) === M2.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((u4) => this.logger.warn(u4));
        }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a5;
      const c5 = new Promise(async (u4) => {
        const d5 = (y7) => {
          y7.topic === e && (this.events.removeListener(T.created, d5), u4(y7.id));
        };
        this.events.on(T.created, d5);
        try {
          const y7 = await ao(new Promise((m, l4) => {
            this.relayer.request(r3).catch((g6) => {
              this.logger.warn(g6, g6 == null ? void 0 : g6.message), l4(g6);
            }).then(m);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(T.created, d5), u4(y7);
        } catch {
        }
      }), h6 = await ao(c5, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h6 && n4)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return h6 ? a5 : null;
    } catch (a5) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v3.connection_stalled), n4)
        throw a5;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, s2 = { method: mi(t.protocol).batchSubscribe, params: { topics: e.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      await await ao(new Promise((i4) => {
        this.relayer.request(s2).catch((r3) => this.logger.warn(r3)).then(i4);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(v3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length)
      return;
    const t = e[0].relay, s2 = { method: mi(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await ao(new Promise((r3, n4) => {
        this.relayer.request(s2).catch((a5) => {
          this.logger.warn(a5), n4(a5);
        }).then(r3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(v3.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e, t, s2) {
    const i4 = { method: mi(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Ie2(Z({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, Z({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, Z({}, t)), this.topicMap.set(t.topic, e), this.events.emit(T.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(T.deleted, Ie2(Z({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(T.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s2 = 0; s2 < t; s2++) {
        const i4 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i4);
      }
    }
    this.events.emit(T.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(e.map((t) => Ie2(Z({}, t), { id: this.getSubscriptionId(t.topic) }))));
  }
  async batchFetchMessages(e) {
    if (!e.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await vo((0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen();
  }
  getSubscriptionId(e) {
    return si(e + this.clientId);
  }
};
var mn = Object.defineProperty;
var si2 = Object.getOwnPropertySymbols;
var bn = Object.prototype.hasOwnProperty;
var fn2 = Object.prototype.propertyIsEnumerable;
var ri2 = (o4, e, t) => e in o4 ? mn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ni2 = (o4, e) => {
  for (var t in e || (e = {}))
    bn.call(e, t) && ri2(o4, t, e[t]);
  if (si2)
    for (var t of si2(e))
      fn2.call(e, t) && ri2(o4, t, e[t]);
  return o4;
};
var oi2 = class extends u {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events7.EventEmitter(), this.name = at, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false, this.heartBeatTimeout = (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.FIVE_SECONDS), this.requestsInFlight = [], this.connectTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15), this.request = async (t) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - publishing...");
        const n4 = `${r3}:${((i4 = t.params) == null ? void 0 : i4.tag) || ""}`;
        this.requestsInFlight.push(n4);
        const a5 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c5) => c5 !== n4), a5;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      }
    }, this.resetPingTimeout = () => {
      if (et())
        try {
          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var t, s2, i4;
            this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i4 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
          }, this.heartBeatTimeout);
        } catch (t) {
          this.logger.warn(t, t == null ? void 0 : t.message);
        }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(v3.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.fatal(t, `Fatal socket error: ${t == null ? void 0 : t.message}`), this.events.emit(v3.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(C3.payload, this.onPayloadHandler), this.provider.on(C3.connect, this.onConnectHandler), this.provider.on(C3.disconnect, this.onDisconnectHandler), this.provider.on(C3.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || ot2 })), this.messages = new Jt2(this.logger, e.core), this.subscriber = new ii2(this, this.logger), this.publisher = new ln2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || fe2, this.projectId = e.projectId, Wr() ? this.packageName = Jr() : zr() && (this.bundleId = Jr()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0)
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, e == null ? void 0 : e.message);
      }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: M2.relay });
  }
  async subscribe(e, t) {
    var s2, i4, r3;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const n4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a5 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", c5;
    const h6 = (u4) => {
      u4.topic === e && (this.subscriber.off(T.created, h6), c5());
    };
    return await Promise.all([new Promise((u4) => {
      c5 = u4, this.subscriber.on(T.created, h6);
    }), new Promise(async (u4, d5) => {
      a5 = await this.subscriber.subscribe(e, ni2({ internal: { throwOnFailedPublish: n4 } }, t)).catch((y7) => {
        n4 && d5(y7);
      }) || a5, u4();
    })]), a5;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s2) => {
      await this.connect(e).then(t).catch(s2).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected)
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const s2 of t)
      try {
        await this.onMessageEvent(s2);
      } catch (i4) {
        this.logger.warn(i4, "Error while processing batch message event: " + (i4 == null ? void 0 : i4.message));
      }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i4 = ho(import_time3.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(v3.message, e), await this.recordMessageEvent(e);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s2, i4) => {
          const r3 = () => {
            i4(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(C3.disconnect, r3), await ao(new Promise((n4, a5) => {
            this.provider.connect().then(n4).catch(a5);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((n4) => {
            i4(n4);
          }).finally(() => {
            this.provider.off(C3.disconnect, r3), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
          }), await new Promise(async (n4, a5) => {
            const c5 = () => {
              a5(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(C3.disconnect, c5), await this.subscriber.start().then(n4).catch(a5).finally(() => {
              this.provider.off(C3.disconnect, c5);
            });
          }), this.hasExperiencedNetworkDisruption = false, s2();
        });
      } catch (s2) {
        await this.subscriber.stop();
        const i4 = s2;
        this.logger.warn({}, i4.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((s2) => setTimeout(s2, (0, import_time3.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, s2, i4, r3;
    if (et())
      try {
        (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.on("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (n4) {
        this.logger.warn(n4, n4 == null ? void 0 : n4.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f(Zr({ sdkVersion: re, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), true;
    const i4 = this.messages.has(t, s2);
    return i4 && this.logger.warn(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ct))
        return;
      const t = e.params, { topic: s2, message: i4, publishedAt: r3, attestation: n4 } = t.data, a5 = { topic: s2, message: i4, publishedAt: r3, transportType: M2.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ni2({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else
      isJsonRpcResponse(e) && this.events.emit(v3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v3.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(C3.payload, this.onPayloadHandler), this.provider.off(C3.connect, this.onConnectHandler), this.provider.off(C3.disconnect, this.onDisconnectHandler), this.provider.off(C3.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Yi();
    Xi(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((s2) => this.logger.error(s2, s2 == null ? void 0 : s2.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(v3.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {
      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message));
    }, (0, import_time3.toMiliseconds)(ht2))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.transportOpen();
  }
};
var vn = Object.defineProperty;
var ai2 = Object.getOwnPropertySymbols;
var _n = Object.prototype.hasOwnProperty;
var En = Object.prototype.propertyIsEnumerable;
var ci2 = (o4, e, t) => e in o4 ? vn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var hi2 = (o4, e) => {
  for (var t in e || (e = {}))
    _n.call(e, t) && ci2(o4, t, e[t]);
  if (ai2)
    for (var t of ai2(e))
      En.call(e, t) && ci2(o4, t, e[t]);
  return o4;
};
var li2 = class extends p {
  constructor(e, t, s2, i4 = A2, r3 = void 0) {
    super(e, t, s2, i4), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = lt, this.cached = [], this.initialized = false, this.storagePrefix = A2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !ae(n4) ? this.map.set(this.getKey(n4), n4) : Pi(n4) ? this.map.set(n4.id, n4) : Li(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a5 }), this.map.set(n4, a5), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a5) => Object.keys(n4).every((c5) => (0, import_lodash.default)(a5[c5], n4[c5]))) : this.values), this.update = async (n4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a5 });
      const c5 = hi2(hi2({}, this.getData(n4)), a5);
      this.map.set(n4, c5), await this.persist();
    }, this.delete = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a5 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i4 } = te("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ui2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = yt2, this.version = Dt, this.events = new import_events7.default(), this.initialized = false, this.storagePrefix = A2, this.ignoredPayloadTypes = [Ie], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i4 = ni(), r3 = await this.core.crypto.setSymKey(i4), n4 = ho(import_time3.FIVE_MINUTES), a5 = { protocol: nt }, c5 = { topic: r3, expiry: n4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, h6 = wi({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a5, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(j.create, c5), this.core.expirer.set(r3, n4), await this.pairings.set(r3, c5), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h6 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z2.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: n4, relay: a5, expiryTimestamp: c5, methods: h6 } = bi(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(z2.pairing_uri_validation_success), i4.addTrace(z2.pairing_uri_not_expired);
      let u4;
      if (this.pairings.keys.includes(r3)) {
        if (u4 = this.pairings.get(r3), i4.addTrace(z2.existing_pairing), u4.active)
          throw i4.setError($.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(z2.pairing_not_expired);
      }
      const d5 = c5 || ho(import_time3.FIVE_MINUTES), y7 = { topic: r3, relay: a5, expiry: d5, active: false, methods: h6 };
      this.core.expirer.set(r3, d5), await this.pairings.set(r3, y7), i4.addTrace(z2.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(j.create, y7), i4.addTrace(z2.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i4.addTrace(z2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError($.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (m) {
        throw i4.setError($.subscribe_pairing_topic_failure), m;
      }
      return i4.addTrace(z2.subscribe_pairing_topic_success), y7;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = ho(import_time3.FIVE_MINUTES);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: n4, resolve: a5, reject: c5 } = co();
        this.events.once(go("pairing_ping", r3), ({ error: h6 }) => {
          h6 ? c5(h6) : a5();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", de("USER_DISCONNECTED")), await this.deletePairing(i4));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: n4, methods: a5 } = s2, c5 = this.core.crypto.keychain.get(i4);
      return wi({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: c5, relay: r3, expiryTimestamp: n4, methods: a5 });
    }, this.sendRequest = async (s2, i4, r3) => {
      const n4 = formatJsonRpcRequest(i4, r3), a5 = await this.core.crypto.encode(s2, n4), c5 = V2[i4].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a5, c5), n4.id;
    }, this.sendResult = async (s2, i4, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i4, n4), c5 = await this.core.history.get(i4, s2), h6 = V2[c5.request.method].res;
      await this.core.relayer.publish(i4, a5, h6), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i4, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i4, n4), c5 = await this.core.history.get(i4, s2), h6 = V2[c5.request.method] ? V2[c5.request.method].res : V2.unregistered_method.res;
      await this.core.relayer.publish(i4, a5, h6), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, de("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i4) => po(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i4, payload: r3 } = s2, n4 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(j.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(go("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(go("pairing_ping", r3), { error: i4.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(j.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i4) => {
      const { id: r3, method: n4 } = i4;
      try {
        if (this.registeredMethods.includes(n4))
          return;
        const a5 = de("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(de("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i4) => {
      var r3;
      if (!Di(s2)) {
        const { message: a5 } = te("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError($.malformed_pairing_uri), new Error(a5);
      }
      if (!Ri(s2.uri)) {
        const { message: a5 } = te("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError($.malformed_pairing_uri), new Error(a5);
      }
      const n4 = bi(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a5 } = te("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError($.malformed_pairing_uri), new Error(a5);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a5 } = te("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError($.malformed_pairing_uri), new Error(a5);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time3.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i4.setError($.pairing_expired);
        const { message: a5 } = te("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }, this.isValidPing = async (s2) => {
      if (!Di(s2)) {
        const { message: r3 } = te("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidDisconnect = async (s2) => {
      if (!Di(s2)) {
        const { message: r3 } = te("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidPairingTopic = async (s2) => {
      if (!q(s2, false)) {
        const { message: i4 } = te("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = te("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (po(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = te("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new li2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v3.message, async (e) => {
      const { topic: t, message: s2, transportType: i4 } = e;
      if (!this.pairings.keys.includes(t) || i4 === M2.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2)))
        return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(x3.expired, async (e) => {
      const { topic: t } = lo(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(j.expire, { topic: t }));
    });
  }
};
var di2 = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = mt2, this.version = bt2, this.cached = [], this.initialized = false, this.storagePrefix = A2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id))
        return;
      const n4 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: ho(import_time3.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(R.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id))
        return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(R.updated, i4));
    }, this.get = async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4)), this.delete = (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4)
            return;
          this.records.delete(r3.id), this.events.emit(R.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false), this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R.created, (e) => {
      const t = R.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(R.updated, (e) => {
      const t = R.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(R.deleted, (e) => {
      const t = R.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time3.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(R.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var pi2 = class extends x {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = ft, this.version = vt2, this.cached = [], this.initialized = false, this.storagePrefix = A2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i4 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(x3.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(x3.deleted, { target: i4, expiration: r3 });
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return uo(e);
    if (typeof e == "number")
      return fo(e);
    const { message: t } = te("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(x3.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time3.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(x3.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(x3.created, (e) => {
      const t = x3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(x3.expired, (e) => {
      const t = x3.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(x3.deleted, (e) => {
      const t = x3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var gi2 = class extends y2 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = _t2, this.verifyUrlV3 = wt2, this.storagePrefix = A2, this.version = De, this.init = async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i4) => {
      if (!Ae() || this.isDevEnv)
        return;
      const r3 = window.location.origin, { id: n4, decryptedId: a5 } = i4, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a5}`;
      try {
        const h6 = (0, import_window_getters2.getDocument)(), u4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), d5 = await new Promise((y7, m) => {
          const l4 = () => {
            window.removeEventListener("message", w5), h6.body.removeChild(g6), m("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l4);
          const g6 = h6.createElement("iframe");
          g6.src = c5, g6.style.display = "none", g6.addEventListener("error", l4, { signal: this.abortController.signal });
          const w5 = (b6) => {
            if (b6.data && typeof b6.data == "string")
              try {
                const D4 = JSON.parse(b6.data);
                if (D4.type === "verify_attestation") {
                  if (sn(D4.attestation).payload.id !== n4)
                    return;
                  clearInterval(u4), h6.body.removeChild(g6), this.abortController.signal.removeEventListener("abort", l4), window.removeEventListener("message", w5), y7(D4.attestation === null ? "" : D4.attestation);
                }
              } catch (D4) {
                this.logger.warn(D4);
              }
          };
          h6.body.appendChild(g6), window.addEventListener("message", w5, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d5), d5;
      } catch (h6) {
        this.logger.warn(h6);
      }
      return "";
    }, this.resolve = async (i4) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: r3, hash: n4, encryptedId: a5 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (sn(r3).payload.id !== a5)
          return;
        const h6 = await this.isValidJwtAttestation(r3);
        if (h6) {
          if (!h6.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h6;
        }
      }
      if (!n4)
        return;
      const c5 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(n4, c5);
    }, this.fetchAttestation = async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a5.status === 200 ? await a5.json() : void 0;
    }, this.getVerifyUrl = (i4) => {
      let r3 = i4 || X;
      return It2.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${X}`), r3 = X), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(import_time3.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.persistPublicKey = async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3)
          return this.validateAttestation(i4, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4)
          return this.validateAttestation(i4, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }, this.validateAttestation = (i4, r3) => {
      const n4 = gi(i4, r3.publicKey), a5 = { hasExpired: (0, import_time3.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a5.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var yi2 = class extends v {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = Tt, this.registerDeviceToken = async (s2) => {
      const { clientId: i4, token: r3, notificationType: n4, enableEncrypted: a5 = false } = s2, c5 = `${Ct2}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: n4, token: r3, always_raw: a5 }) });
    }, this.logger = E(t, this.context);
  }
};
var wn = Object.defineProperty;
var Di2 = Object.getOwnPropertySymbols;
var In = Object.prototype.hasOwnProperty;
var Tn = Object.prototype.propertyIsEnumerable;
var mi2 = (o4, e, t) => e in o4 ? wn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Q = (o4, e) => {
  for (var t in e || (e = {}))
    In.call(e, t) && mi2(o4, t, e[t]);
  if (Di2)
    for (var t of Di2(e))
      Tn.call(e, t) && mi2(o4, t, e[t]);
  return o4;
};
var bi2 = class extends C2 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = St2, this.storagePrefix = A2, this.storageVersion = Pt, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Eo())
        try {
          const i4 = { eventId: wo(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt(this.core.relayer.protocol, this.core.relayer.version, re) } } };
          await this.sendEvent([i4]);
        } catch (i4) {
          this.logger.warn(i4);
        }
    }, this.createEvent = (i4) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a5, trace: c5 } } = i4, h6 = wo(), u4 = this.core.projectId || "", d5 = Date.now(), y7 = Q({ eventId: h6, timestamp: d5, props: { event: r3, type: n4, properties: { topic: a5, trace: c5 } }, bundleId: u4, domain: this.getAppDomain() }, this.setMethods(h6));
      return this.telemetryEnabled && (this.events.set(h6, y7), this.shouldPersist = true), y7;
    }, this.getEvent = (i4) => {
      const { eventId: r3, topic: n4 } = i4;
      if (r3)
        return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === n4);
      if (a5)
        return Q(Q({}, a5), this.setMethods(a5.eventId));
    }, this.deleteEvent = (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(i4.timestamp) > Rt && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) }), this.addTrace = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.setError = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length)
          return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, Q(Q({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const i4 = [];
      for (const [r3, n4] of this.events)
        n4.props.type && i4.push(n4);
      if (i4.length !== 0)
        try {
          if ((await this.sendEvent(i4)).ok)
            for (const r3 of i4)
              this.events.delete(r3.eventId), this.shouldPersist = true;
        } catch (r3) {
          this.logger.warn(r3);
        }
    }, this.sendEvent = async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${xt2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${re}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }, this.getAppDomain = () => Yr().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Cn2 = Object.defineProperty;
var fi2 = Object.getOwnPropertySymbols;
var Pn = Object.prototype.hasOwnProperty;
var Sn = Object.prototype.propertyIsEnumerable;
var vi = (o4, e, t) => e in o4 ? Cn2(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var _i = (o4, e) => {
  for (var t in e || (e = {}))
    Pn.call(e, t) && vi(o4, t, e[t]);
  if (fi2)
    for (var t of fi2(e))
      Sn.call(e, t) && vi(o4, t, e[t]);
  return o4;
};
var oe = class _oe extends n2 {
  constructor(e) {
    var t;
    super(e), this.protocol = ye, this.version = De, this.name = J2, this.events = new import_events7.EventEmitter(), this.initialized = false, this.on = (n4, a5) => this.events.on(n4, a5), this.once = (n4, a5) => this.events.once(n4, a5), this.off = (n4, a5) => this.events.off(n4, a5), this.removeListener = (n4, a5) => this.events.removeListener(n4, a5), this.dispatchEnvelope = ({ topic: n4, message: a5, sessionExists: c5 }) => {
      if (!n4 || !a5)
        return;
      const h6 = { topic: n4, message: a5, publishedAt: Date.now(), transportType: M2.link_mode };
      this.relayer.onLinkMessageEvent(h6, { sessionExists: c5 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || fe2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Xe.logger, name: J2 }), { logger: i4, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a5;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i4, this.name), this.heartbeat = new i(), this.crypto = new Yt2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new di2(this, this.logger), this.expirer = new pi2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(_i(_i({}, We2), e == null ? void 0 : e.storageOptions)), this.relayer = new oi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ui2(this, this.logger), this.verify = new gi2(this, this.logger, this.storage), this.echoClient = new yi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new bi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _oe(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(ut, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ve2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(ve2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Rn = oe;

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R2 = { wc_authRequest: { req: { ttl: import_time4.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 3001 } } };
var U2 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = "wc";
var Q2 = 1;
var Z2 = "auth";
var B2 = "authClient";
var F3 = `${$2}@${1}:${Z2}:`;
var x4 = `${F3}:PUB_KEY`;
function z3(r3) {
  return r3 == null ? void 0 : r3.split(":");
}
function Ze2(r3) {
  const t = r3 && z3(r3);
  if (t)
    return t[3];
}
function We3(r3) {
  const t = r3 && z3(r3);
  if (t)
    return t[2] + ":" + t[3];
}
function W2(r3) {
  const t = r3 && z3(r3);
  if (t)
    return t.pop();
}
async function et3(r3, t, e, i4, n4) {
  switch (e.t) {
    case "eip191":
      return tt3(r3, t, e.s);
    case "eip1271":
      return await rt3(r3, t, e.s, i4, n4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt3(r3, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r3.toLowerCase();
}
async function rt3(r3, t, e, i4, n4) {
  try {
    const s2 = "0x1626ba7e", o4 = "0000000000000000000000000000000000000000000000000000000000000040", u4 = "0000000000000000000000000000000000000000000000000000000000000041", a5 = e.substring(2), c5 = hashMessage(t).substring(2), h6 = s2 + c5 + o4 + u4 + a5, f5 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i4}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: it3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r3, data: h6 }, "latest"] }) }), { result: p4 } = await f5.json();
    return p4 ? p4.slice(0, s2.length).toLowerCase() === s2.toLowerCase() : false;
  } catch (s2) {
    return console.error("isValidEip1271Signature: ", s2), false;
  }
}
function it3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee2(r3) {
  return r3.getAll().filter((t) => "requester" in t);
}
function te3(r3, t) {
  return ee2(r3).find((e) => e.id === t);
}
function nt2(r3) {
  const t = Ri(r3.aud), e = new RegExp(`${r3.domain}`).test(r3.aud), i4 = !!r3.nonce, n4 = r3.type ? r3.type === "eip4361" : true, s2 = r3.expiry;
  if (s2 && !Ji(s2, U2)) {
    const { message: o4 } = te("MISSING_OR_INVALID", `request() expiry: ${s2}. Expiry must be a number (in seconds) between ${U2.min} and ${U2.max}`);
    throw new Error(o4);
  }
  return !!(t && e && i4 && n4);
}
function st3(r3, t) {
  return !!te3(t, r3.id);
}
function ot3(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r3) : new Uint8Array(r3);
}
function ut2(r3, t) {
  if (r3.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i4 = 0; i4 < e.length; i4++)
    e[i4] = 255;
  for (var n4 = 0; n4 < r3.length; n4++) {
    var s2 = r3.charAt(n4), o4 = s2.charCodeAt(0);
    if (e[o4] !== 255)
      throw new TypeError(s2 + " is ambiguous");
    e[o4] = n4;
  }
  var u4 = r3.length, a5 = r3.charAt(0), c5 = Math.log(u4) / Math.log(256), h6 = Math.log(256) / Math.log(u4);
  function f5(D4) {
    if (D4 instanceof Uint8Array || (ArrayBuffer.isView(D4) ? D4 = new Uint8Array(D4.buffer, D4.byteOffset, D4.byteLength) : Array.isArray(D4) && (D4 = Uint8Array.from(D4))), !(D4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D4.length === 0)
      return "";
    for (var l4 = 0, m = 0, E4 = 0, y7 = D4.length; E4 !== y7 && D4[E4] === 0; )
      E4++, l4++;
    for (var w5 = (y7 - E4) * h6 + 1 >>> 0, g6 = new Uint8Array(w5); E4 !== y7; ) {
      for (var C7 = D4[E4], _4 = 0, b6 = w5 - 1; (C7 !== 0 || _4 < m) && b6 !== -1; b6--, _4++)
        C7 += 256 * g6[b6] >>> 0, g6[b6] = C7 % u4 >>> 0, C7 = C7 / u4 >>> 0;
      if (C7 !== 0)
        throw new Error("Non-zero carry");
      m = _4, E4++;
    }
    for (var v8 = w5 - m; v8 !== w5 && g6[v8] === 0; )
      v8++;
    for (var q5 = a5.repeat(l4); v8 < w5; ++v8)
      q5 += r3.charAt(g6[v8]);
    return q5;
  }
  function p4(D4) {
    if (typeof D4 != "string")
      throw new TypeError("Expected String");
    if (D4.length === 0)
      return new Uint8Array();
    var l4 = 0;
    if (D4[l4] !== " ") {
      for (var m = 0, E4 = 0; D4[l4] === a5; )
        m++, l4++;
      for (var y7 = (D4.length - l4) * c5 + 1 >>> 0, w5 = new Uint8Array(y7); D4[l4]; ) {
        var g6 = e[D4.charCodeAt(l4)];
        if (g6 === 255)
          return;
        for (var C7 = 0, _4 = y7 - 1; (g6 !== 0 || C7 < E4) && _4 !== -1; _4--, C7++)
          g6 += u4 * w5[_4] >>> 0, w5[_4] = g6 % 256 >>> 0, g6 = g6 / 256 >>> 0;
        if (g6 !== 0)
          throw new Error("Non-zero carry");
        E4 = C7, l4++;
      }
      if (D4[l4] !== " ") {
        for (var b6 = y7 - E4; b6 !== y7 && w5[b6] === 0; )
          b6++;
        for (var v8 = new Uint8Array(m + (y7 - b6)), q5 = m; b6 !== y7; )
          v8[q5++] = w5[b6++];
        return v8;
      }
    }
  }
  function A5(D4) {
    var l4 = p4(D4);
    if (l4)
      return l4;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f5, decodeUnsafe: p4, decode: A5 };
}
var at2 = ut2;
var Dt2 = at2;
var re2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array")
    return r3;
  if (r3 instanceof ArrayBuffer)
    return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3))
    return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct2 = (r3) => new TextEncoder().encode(r3);
var ht3 = (r3) => new TextDecoder().decode(r3);
var lt2 = class {
  constructor(t, e, i4) {
    this.name = t, this.prefix = e, this.baseEncode = i4;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt2 = class {
  constructor(t, e, i4) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i4;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie2(this, t);
  }
};
var pt3 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie2(this, t);
  }
  decode(t) {
    const e = t[0], i4 = this.decoders[e];
    if (i4)
      return i4.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie2 = (r3, t) => new pt3({ ...r3.decoders || { [r3.prefix]: r3 }, ...t.decoders || { [t.prefix]: t } });
var ft2 = class {
  constructor(t, e, i4, n4) {
    this.name = t, this.prefix = e, this.baseEncode = i4, this.baseDecode = n4, this.encoder = new lt2(t, e, i4), this.decoder = new dt2(t, e, n4);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O = ({ name: r3, prefix: t, encode: e, decode: i4 }) => new ft2(r3, t, e, i4);
var T2 = ({ prefix: r3, name: t, alphabet: e }) => {
  const { encode: i4, decode: n4 } = Dt2(e, t);
  return O({ prefix: r3, name: t, encode: i4, decode: (s2) => re2(n4(s2)) });
};
var gt3 = (r3, t, e, i4) => {
  const n4 = {};
  for (let h6 = 0; h6 < t.length; ++h6)
    n4[t[h6]] = h6;
  let s2 = r3.length;
  for (; r3[s2 - 1] === "="; )
    --s2;
  const o4 = new Uint8Array(s2 * e / 8 | 0);
  let u4 = 0, a5 = 0, c5 = 0;
  for (let h6 = 0; h6 < s2; ++h6) {
    const f5 = n4[r3[h6]];
    if (f5 === void 0)
      throw new SyntaxError(`Non-${i4} character`);
    a5 = a5 << e | f5, u4 += e, u4 >= 8 && (u4 -= 8, o4[c5++] = 255 & a5 >> u4);
  }
  if (u4 >= e || 255 & a5 << 8 - u4)
    throw new SyntaxError("Unexpected end of data");
  return o4;
};
var Et3 = (r3, t, e) => {
  const i4 = t[t.length - 1] === "=", n4 = (1 << e) - 1;
  let s2 = "", o4 = 0, u4 = 0;
  for (let a5 = 0; a5 < r3.length; ++a5)
    for (u4 = u4 << 8 | r3[a5], o4 += 8; o4 > e; )
      o4 -= e, s2 += t[n4 & u4 >> o4];
  if (o4 && (s2 += t[n4 & u4 << e - o4]), i4)
    for (; s2.length * e & 7; )
      s2 += "=";
  return s2;
};
var d3 = ({ name: r3, prefix: t, bitsPerChar: e, alphabet: i4 }) => O({ prefix: t, name: r3, encode(n4) {
  return Et3(n4, i4, e);
}, decode(n4) {
  return gt3(n4, i4, e, r3);
} });
var bt3 = O({ prefix: "\0", name: "identity", encode: (r3) => ht3(r3), decode: (r3) => ct2(r3) });
var yt3 = Object.freeze({ __proto__: null, identity: bt3 });
var wt3 = d3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct3 = Object.freeze({ __proto__: null, base2: wt3 });
var mt3 = d3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt3 = Object.freeze({ __proto__: null, base8: mt3 });
var At3 = T2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t3 = Object.freeze({ __proto__: null, base10: At3 });
var xt3 = d3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt2 = d3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft3 = Object.freeze({ __proto__: null, base16: xt3, base16upper: Rt2 });
var Tt2 = d3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It3 = d3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt2 = d3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut3 = d3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot3 = d3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St3 = d3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt2 = d3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt3 = d3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t2 = d3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt3 = Object.freeze({ __proto__: null, base32: Tt2, base32upper: It3, base32pad: qt2, base32padupper: Ut3, base32hex: Ot3, base32hexupper: St3, base32hexpad: Pt2, base32hexpadupper: Nt3, base32z: $t2 });
var zt3 = T2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt3 = T2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt2 = Object.freeze({ __proto__: null, base36: zt3, base36upper: jt3 });
var Lt2 = T2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt2 = T2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt2 = Object.freeze({ __proto__: null, base58btc: Lt2, base58flickr: Kt2 });
var kt3 = d3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt3 = d3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt2 = d3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt3 = d3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht2 = Object.freeze({ __proto__: null, base64: kt3, base64pad: Jt3, base64url: Xt2, base64urlpad: Gt3 });
var ne3 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Yt3 = ne3.reduce((r3, t, e) => (r3[e] = t, r3), []);
var Qt2 = ne3.reduce((r3, t, e) => (r3[t.codePointAt(0)] = e, r3), []);
function Zt2(r3) {
  return r3.reduce((t, e) => (t += Yt3[e], t), "");
}
function Wt3(r3) {
  const t = [];
  for (const e of r3) {
    const i4 = Qt2[e.codePointAt(0)];
    if (i4 === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i4);
  }
  return new Uint8Array(t);
}
var er3 = O({ prefix: "🚀", name: "base256emoji", encode: Zt2, decode: Wt3 });
var tr3 = Object.freeze({ __proto__: null, base256emoji: er3 });
var rr3 = oe2;
var se2 = 128;
var ir3 = 127;
var nr3 = ~ir3;
var sr3 = Math.pow(2, 31);
function oe2(r3, t, e) {
  t = t || [], e = e || 0;
  for (var i4 = e; r3 >= sr3; )
    t[e++] = r3 & 255 | se2, r3 /= 128;
  for (; r3 & nr3; )
    t[e++] = r3 & 255 | se2, r3 >>>= 7;
  return t[e] = r3 | 0, oe2.bytes = e - i4 + 1, t;
}
var or3 = j2;
var ur2 = 128;
var ue2 = 127;
function j2(r3, i4) {
  var e = 0, i4 = i4 || 0, n4 = 0, s2 = i4, o4, u4 = r3.length;
  do {
    if (s2 >= u4)
      throw j2.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[s2++], e += n4 < 28 ? (o4 & ue2) << n4 : (o4 & ue2) * Math.pow(2, n4), n4 += 7;
  } while (o4 >= ur2);
  return j2.bytes = s2 - i4, e;
}
var ar3 = Math.pow(2, 7);
var Dr2 = Math.pow(2, 14);
var cr3 = Math.pow(2, 21);
var hr2 = Math.pow(2, 28);
var lr2 = Math.pow(2, 35);
var dr2 = Math.pow(2, 42);
var pr2 = Math.pow(2, 49);
var fr2 = Math.pow(2, 56);
var gr2 = Math.pow(2, 63);
var Er2 = function(r3) {
  return r3 < ar3 ? 1 : r3 < Dr2 ? 2 : r3 < cr3 ? 3 : r3 < hr2 ? 4 : r3 < lr2 ? 5 : r3 < dr2 ? 6 : r3 < pr2 ? 7 : r3 < fr2 ? 8 : r3 < gr2 ? 9 : 10;
};
var br2 = { encode: rr3, decode: or3, encodingLength: Er2 };
var ae3 = br2;
var De2 = (r3, t, e = 0) => (ae3.encode(r3, t, e), t);
var ce3 = (r3) => ae3.encodingLength(r3);
var M3 = (r3, t) => {
  const e = t.byteLength, i4 = ce3(r3), n4 = i4 + ce3(e), s2 = new Uint8Array(n4 + e);
  return De2(r3, s2, 0), De2(e, s2, i4), s2.set(t, n4), new yr3(r3, e, t, s2);
};
var yr3 = class {
  constructor(t, e, i4, n4) {
    this.code = t, this.size = e, this.digest = i4, this.bytes = n4;
  }
};
var he2 = ({ name: r3, code: t, encode: e }) => new wr2(r3, t, e);
var wr2 = class {
  constructor(t, e, i4) {
    this.name = t, this.code = e, this.encode = i4;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M3(this.code, e) : e.then((i4) => M3(this.code, i4));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le = (r3) => async (t) => new Uint8Array(await crypto.subtle.digest(r3, t));
var Cr2 = he2({ name: "sha2-256", code: 18, encode: le("SHA-256") });
var mr3 = he2({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr2 = Object.freeze({ __proto__: null, sha256: Cr2, sha512: mr3 });
var de2 = 0;
var Ar2 = "identity";
var pe = re2;
var _r3 = (r3) => M3(de2, pe(r3));
var xr2 = { code: de2, name: Ar2, encode: pe, digest: _r3 };
var Rr3 = Object.freeze({ __proto__: null, identity: xr2 });
new TextEncoder(), new TextDecoder();
var fe3 = { ...yt3, ...Ct3, ...vt3, ..._t3, ...Ft3, ...Bt3, ...Mt2, ...Vt2, ...Ht2, ...tr3 };
({ ...vr2, ...Rr3 });
function ge(r3, t, e, i4) {
  return { name: r3, prefix: t, encoder: { name: r3, prefix: t, encode: e }, decoder: { decode: i4 } };
}
var Ee3 = ge("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var L = ge("ascii", "a", (r3) => {
  let t = "a";
  for (let e = 0; e < r3.length; e++)
    t += String.fromCharCode(r3[e]);
  return t;
}, (r3) => {
  r3 = r3.substring(1);
  const t = ot3(r3.length);
  for (let e = 0; e < r3.length; e++)
    t[e] = r3.charCodeAt(e);
  return t;
});
var be3 = { utf8: Ee3, "utf-8": Ee3, hex: fe3.base16, latin1: L, ascii: L, binary: L, ...fe3 };
function Fr2(r3, t = "utf8") {
  const e = be3[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3, "utf8") : e.decoder.decode(`${e.prefix}${r3}`);
}
function Tr3(r3, t = "utf8") {
  const e = be3[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3.buffer, r3.byteOffset, r3.byteLength).toString("utf8") : e.encoder.encode(r3).substring(1);
}
var ye2 = "base16";
var we3 = "utf8";
function K2(r3) {
  const t = (0, import_sha256.hash)(Fr2(r3, we3));
  return Tr3(t, ye2);
}
var Or2 = Object.defineProperty;
var Sr2 = Object.defineProperties;
var Pr2 = Object.getOwnPropertyDescriptors;
var Ce3 = Object.getOwnPropertySymbols;
var Nr2 = Object.prototype.hasOwnProperty;
var $r3 = Object.prototype.propertyIsEnumerable;
var me3 = (r3, t, e) => t in r3 ? Or2(r3, t, { enumerable: true, configurable: true, writable: true, value: e }) : r3[t] = e;
var I = (r3, t) => {
  for (var e in t || (t = {}))
    Nr2.call(t, e) && me3(r3, e, t[e]);
  if (Ce3)
    for (var e of Ce3(t))
      $r3.call(t, e) && me3(r3, e, t[e]);
  return r3;
};
var V3 = (r3, t) => Sr2(r3, Pr2(t));
var Br3 = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R2) }), this.initialized = true);
    }, this.request = async (e, i4) => {
      if (this.isInitialized(), !nt2(e))
        throw new Error("Invalid request");
      if (i4 != null && i4.topic)
        return await this.requestOnKnownPairing(i4.topic, e);
      const { chainId: n4, statement: s2, aud: o4, domain: u4, nonce: a5, type: c5, exp: h6, nbf: f5 } = e, { topic: p4, uri: A5 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p4, uri: A5 } });
      const D4 = await this.client.core.crypto.generateKeyPair(), l4 = oi(D4);
      await this.client.authKeys.set(x4, { responseTopic: l4, publicKey: D4 }), await this.client.pairingTopics.set(l4, { topic: l4, pairingTopic: p4 }), await this.client.core.relayer.subscribe(l4), this.client.logger.info(`sending request to new pairing topic: ${p4}`);
      const m = await this.sendRequest(p4, "wc_authRequest", { payloadParams: { type: c5 ?? "eip4361", chainId: n4, statement: s2, aud: o4, domain: u4, version: "1", nonce: a5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h6, nbf: f5 }, requester: { publicKey: D4, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p4}`), { uri: A5, id: m };
    }, this.respond = async (e, i4) => {
      if (this.isInitialized(), !st3(e, this.client.requests))
        throw new Error("Invalid response");
      const n4 = te3(this.client.requests, e.id);
      if (!n4)
        throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s2 = n4.requester.publicKey, o4 = await this.client.core.crypto.generateKeyPair(), u4 = oi(s2), a5 = { type: Ie, receiverPublicKey: s2, senderPublicKey: o4 };
      if ("error" in e) {
        await this.sendError(n4.id, u4, e, a5);
        return;
      }
      const c5 = { h: { t: "eip4361" }, p: V3(I({}, n4.cacaoPayload), { iss: i4 }), s: e.signature };
      await this.sendResult(n4.id, u4, c5, a5), await this.client.core.pairing.activate({ topic: n4.pairingTopic }), await this.client.requests.update(n4.id, I({}, c5));
    }, this.getPendingRequests = () => ee2(this.client.requests), this.formatMessage = (e, i4) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n4 = `${e.domain} wants you to sign in with your Ethereum account:`, s2 = W2(i4), o4 = e.statement, u4 = `URI: ${e.aud}`, a5 = `Version: ${e.version}`, c5 = `Chain ID: ${Ze2(i4)}`, h6 = `Nonce: ${e.nonce}`, f5 = `Issued At: ${e.iat}`, p4 = e.exp ? `Expiry: ${e.exp}` : void 0, A5 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D4) => `- ${D4}`).join(`
`)}` : void 0;
      return [n4, s2, "", o4, "", u4, a5, c5, h6, f5, p4, A5].filter((D4) => D4 != null).join(`
`);
    }, this.setExpiry = async (e, i4) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i4 }), this.client.core.expirer.set(e, i4);
    }, this.sendRequest = async (e, i4, n4, s2, o4) => {
      const u4 = formatJsonRpcRequest(i4, n4), a5 = await this.client.core.crypto.encode(e, u4, s2), c5 = R2[i4].req;
      if (o4 && (c5.ttl = o4), this.client.core.history.set(e, u4), Ae()) {
        const h6 = K2(JSON.stringify(u4));
        this.client.core.verify.register({ attestationId: h6 });
      }
      return await this.client.core.relayer.publish(e, a5, V3(I({}, c5), { internal: { throwOnFailedPublish: true } })), u4.id;
    }, this.sendResult = async (e, i4, n4, s2) => {
      const o4 = formatJsonRpcResult(e, n4), u4 = await this.client.core.crypto.encode(i4, o4, s2), a5 = await this.client.core.history.get(i4, e), c5 = R2[a5.request.method].res;
      return await this.client.core.relayer.publish(i4, u4, V3(I({}, c5), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o4), o4.id;
    }, this.sendError = async (e, i4, n4, s2) => {
      const o4 = formatJsonRpcError(e, n4.error), u4 = await this.client.core.crypto.encode(i4, o4, s2), a5 = await this.client.core.history.get(i4, e), c5 = R2[a5.request.method].res;
      return await this.client.core.relayer.publish(i4, u4, c5), await this.client.core.history.resolve(o4), o4.id;
    }, this.requestOnKnownPairing = async (e, i4) => {
      const n4 = this.client.core.pairing.pairings.getAll({ active: true }).find((A5) => A5.topic === e);
      if (!n4)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s2 } = this.client.authKeys.get(x4), { chainId: o4, statement: u4, aud: a5, domain: c5, nonce: h6, type: f5 } = i4, p4 = await this.sendRequest(n4.topic, "wc_authRequest", { payloadParams: { type: f5 ?? "eip4361", chainId: o4, statement: u4, aud: a5, domain: c5, version: "1", nonce: h6, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s2, metadata: this.client.metadata } }, {}, i4.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n4.topic}`), { id: p4 };
    }, this.onPairingCreated = (e) => {
      const i4 = this.getPendingRequests();
      if (i4) {
        const n4 = Object.values(i4).find((s2) => s2.pairingTopic === e.topic);
        n4 && this.handleAuthRequest(n4);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i4, payload: n4 } = e, s2 = n4.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthRequest(i4, n4);
        default:
          return this.client.logger.info(`Unsupported request method ${s2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i4, payload: n4 } = e, s2 = (await this.client.core.history.get(i4, n4.id)).request.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthResponse(i4, n4);
        default:
          return this.client.logger.info(`Unsupported response method ${s2}`);
      }
    }, this.onAuthRequest = async (e, i4) => {
      const { requester: n4, payloadParams: s2 } = i4.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i4 });
      const o4 = K2(JSON.stringify(i4)), u4 = await this.getVerifyContext(o4, this.client.metadata), a5 = { requester: n4, pairingTopic: e, id: i4.id, cacaoPayload: s2, verifyContext: u4 };
      await this.client.requests.set(i4.id, a5), this.handleAuthRequest(a5);
    }, this.handleAuthRequest = async (e) => {
      const { id: i4, pairingTopic: n4, requester: s2, cacaoPayload: o4, verifyContext: u4 } = e;
      try {
        this.client.emit("auth_request", { id: i4, topic: n4, params: { requester: s2, cacaoPayload: o4 }, verifyContext: u4 });
      } catch (a5) {
        await this.sendError(e.id, e.pairingTopic, a5), this.client.logger.error(a5);
      }
    }, this.onAuthResponse = async (e, i4) => {
      const { id: n4 } = i4;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i4 }), isJsonRpcResult(i4)) {
        const { pairingTopic: s2 } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s2 });
        const { s: o4, p: u4 } = i4.result;
        await this.client.requests.set(n4, I({ id: n4, pairingTopic: s2 }, i4.result));
        const a5 = this.formatMessage(u4, u4.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a5)), this.client.logger.debug("payload.iss:", u4.iss), this.client.logger.debug("signature:", o4);
        const c5 = W2(u4.iss), h6 = We3(u4.iss);
        if (!c5)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h6)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c5), await et3(c5, a5, o4, h6, this.client.projectId) ? this.client.emit("auth_response", { id: n4, topic: e, params: i4 }) : this.client.emit("auth_response", { id: n4, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i4) && this.client.emit("auth_response", { id: n4, topic: e, params: i4 });
    }, this.getVerifyContext = async (e, i4) => {
      const n4 = { verified: { verifyUrl: i4.verifyUrl || "", validation: "UNKNOWN", origin: i4.url || "" } };
      try {
        const s2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i4.verifyUrl });
        s2 && (n4.verified.origin = s2.origin, n4.verified.isScam = s2.isScam, n4.verified.validation = origin === new URL(i4.url).origin ? "VALID" : "INVALID");
      } catch (s2) {
        this.client.logger.error(s2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n4)}`), n4;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = te("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v3.message, async (t) => {
      const { topic: e, message: i4 } = t, { responseTopic: n4, publicKey: s2 } = this.client.authKeys.keys.includes(x4) ? this.client.authKeys.get(x4) : { responseTopic: void 0, publicKey: void 0 };
      if (n4 && e !== n4) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o4 = await this.client.core.crypto.decode(e, i4, { receiverPublicKey: s2 });
      isJsonRpcRequest(o4) ? (this.client.core.history.set(e, o4), this.onRelayEventRequest({ topic: e, payload: o4 })) : isJsonRpcResponse(o4) && (await this.client.core.history.resolve(o4), this.onRelayEventResponse({ topic: e, payload: o4 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(j.create, (t) => this.onPairingCreated(t));
  }
};
var S = class _S extends H2 {
  constructor(t) {
    super(t), this.protocol = $2, this.version = Q2, this.name = B2, this.events = new import_events8.EventEmitter(), this.emit = (i4, n4) => this.events.emit(i4, n4), this.on = (i4, n4) => this.events.on(i4, n4), this.once = (i4, n4) => this.events.once(i4, n4), this.off = (i4, n4) => this.events.off(i4, n4), this.removeListener = (i4, n4) => this.events.removeListener(i4, n4), this.request = async (i4, n4) => {
      try {
        return await this.engine.request(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (i4, n4) => {
      try {
        return await this.engine.respond(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }, this.formatMessage = (i4, n4) => {
      try {
        return this.engine.formatMessage(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Rn(t), this.logger = E(e, this.name), this.authKeys = new li2(this.core, this.logger, "authKeys", F3, () => x4), this.pairingTopics = new li2(this.core, this.logger, "pairingTopics", F3), this.requests = new li2(this.core, this.logger, "requests", F3, (i4) => i4.id), this.engine = new Br3(this);
  }
  static async init(t) {
    const e = new _S(t);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr3 = S;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_events12 = __toESM(require_events());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events10 = __toESM(require_events());
var n3 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g3 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p2 = class {
  constructor(s2, t, e, f5) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x5 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y3 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v4 = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C4 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};
var S2 = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M4 = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time7 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
var ed25519 = __toESM(require_ed25519());
var import_random2 = __toESM(require_random());
var import_time5 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/utils.js
init_concat();
init_to_string();
init_from_string();
function decodeJSON(str) {
  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(val) {
  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString(bytes, JWT_ENCODING);
}
function decodeSig(encoded) {
  return fromString(encoded, JWT_ENCODING);
}
function encodeData(params) {
  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(jwt) {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  const signature = decodeSig(params[2]);
  const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header, payload, signature, data };
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair(seed = (0, import_random2.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time5.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_time6 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());
var q2 = __toESM(require_query_string());
init_lib();
init_lib2();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var _e3 = __toESM(require_x25519());
var import_elliptic2 = __toESM(require_elliptic2());
var H3 = ":";
function re3(e) {
  const [n4, t] = e.split(H3);
  return { namespace: n4, reference: t };
}
function W3(e, n4) {
  return e.includes(":") ? [e] : n4.chains || [];
}
var gt4 = Object.defineProperty;
var Ke3 = Object.getOwnPropertySymbols;
var vt4 = Object.prototype.hasOwnProperty;
var bt4 = Object.prototype.propertyIsEnumerable;
var Le2 = (e, n4, t) => n4 in e ? gt4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var Fe2 = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    vt4.call(n4, t) && Le2(e, t, n4[t]);
  if (Ke3)
    for (var t of Ke3(n4))
      bt4.call(n4, t) && Le2(e, t, n4[t]);
  return e;
};
var qe = "ReactNative";
var y4 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var He2 = "js";
function ce4() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function _2() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === qe;
}
function V4() {
  return !ce4() && !!(0, import_window_getters3.getNavigator)() && !!(0, import_window_getters3.getDocument)();
}
function P() {
  return _2() ? y4.reactNative : ce4() ? y4.node : V4() ? y4.browser : y4.unknown;
}
function Ot4() {
  var e;
  try {
    return _2() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function We4(e, n4) {
  let t = q2.parse(e);
  return t = Fe2(Fe2({}, t), n4), e = q2.stringify(t), e;
}
function Nt4() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Je2() {
  if (P() === y4.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r3 } = global.Platform;
    return [t, r3].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function ze2() {
  var e;
  const n4 = P();
  return n4 === y4.browser ? [n4, ((e = (0, import_window_getters3.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ge2(e, n4, t) {
  const r3 = Je2(), o4 = ze2();
  return [[e, n4].join("-"), [He2, t].join("-"), r3, o4].join("/");
}
function $t3({ protocol: e, version: n4, relayUrl: t, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i4, bundleId: u4 }) {
  const l4 = t.split("?"), c5 = Ge2(e, n4, r3), d5 = { auth: o4, ua: c5, projectId: s2, useOnCloseEvent: i4 || void 0, origin: u4 || void 0 }, a5 = We4(l4[1] || "", d5);
  return l4[0] + "?" + a5;
}
function $3(e, n4) {
  return e.filter((t) => n4.includes(t)).length === e.length;
}
function Tt3(e) {
  return Object.fromEntries(e.entries());
}
function Pt3(e) {
  return new Map(Object.entries(e));
}
function _t4(e = import_time6.FIVE_MINUTES, n4) {
  const t = (0, import_time6.toMiliseconds)(e || import_time6.FIVE_MINUTES);
  let r3, o4, s2;
  return { resolve: (i4) => {
    s2 && r3 && (clearTimeout(s2), r3(i4));
  }, reject: (i4) => {
    s2 && o4 && (clearTimeout(s2), o4(i4));
  }, done: () => new Promise((i4, u4) => {
    s2 = setTimeout(() => {
      u4(new Error(n4));
    }, t), r3 = i4, o4 = u4;
  }) };
}
function kt4(e, n4, t) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(t)), n4);
    try {
      const i4 = await e;
      r3(i4);
    } catch (i4) {
      o4(i4);
    }
    clearTimeout(s2);
  });
}
function ae4(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`))
    return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function Dt3(e) {
  return ae4("topic", e);
}
function xt4(e) {
  return ae4("id", e);
}
function Vt3(e) {
  const [n4, t] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string")
    r3.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t)))
    r3.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r3;
}
function Mt3(e, n4) {
  return (0, import_time6.fromMiliseconds)((n4 || Date.now()) + (0, import_time6.toMiliseconds)(e));
}
function Kt3(e) {
  return Date.now() >= (0, import_time6.toMiliseconds)(e);
}
function Lt3(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
function N2(e = [], n4 = []) {
  return [.../* @__PURE__ */ new Set([...e, ...n4])];
}
async function Ft4({ id: e, topic: n4, wcDeepLink: t }) {
  var r3;
  try {
    if (!t)
      return;
    const o4 = typeof t == "string" ? JSON.parse(t) : t, s2 = o4 == null ? void 0 : o4.href;
    if (typeof s2 != "string")
      return;
    const i4 = Xe3(s2, e, n4), u4 = P();
    if (u4 === y4.browser) {
      if (!((r3 = (0, import_window_getters3.getDocument)()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      i4.startsWith("https://") || i4.startsWith("http://") ? window.open(i4, "_blank", "noreferrer noopener") : window.open(i4, en2() ? "_blank" : "_self", "noreferrer noopener");
    } else
      u4 === y4.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i4);
  } catch (o4) {
    console.error(o4);
  }
}
function Xe3(e, n4, t) {
  const r3 = `requestId=${n4}&sessionTopic=${t}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let o4 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const s2 = e.includes("?") ? "&startapp=" : "?startapp=";
    o4 = `${o4}${s2}${nn2(r3, true)}`;
  } else
    o4 = `${o4}/wc?${r3}`;
  return o4;
}
async function qt3(e, n4) {
  let t = "";
  try {
    if (V4() && (t = localStorage.getItem(n4), t))
      return t;
    t = await e.getItem(n4);
  } catch (r3) {
    console.error(r3);
  }
  return t;
}
function Bt4(e, n4) {
  if (!e.includes(n4))
    return null;
  const t = e.split(/([&,?,=])/), r3 = t.indexOf(n4);
  return t[r3 + 2];
}
function Ht3() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const n4 = Math.random() * 16 | 0;
    return (e === "x" ? n4 : n4 & 3 | 8).toString(16);
  });
}
function Wt4() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function en2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn2(e, n4 = false) {
  const t = Buffer.from(e).toString("base64");
  return n4 ? t.replace(/[=]/g, "") : t;
}
function le2(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
var Jt4 = "https://rpc.walletconnect.org/v1";
async function tn2(e, n4, t, r3, o4, s2) {
  switch (t.t) {
    case "eip191":
      return rn2(e, n4, t.s);
    case "eip1271":
      return await on2(e, n4, t.s, r3, o4, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
  }
}
function rn2(e, n4, t) {
  return recoverAddress(hashMessage(n4), t).toLowerCase() === e.toLowerCase();
}
async function on2(e, n4, t, r3, o4, s2) {
  const i4 = re3(r3);
  if (!i4.namespace || !i4.reference)
    throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const u4 = "0x1626ba7e", l4 = "0000000000000000000000000000000000000000000000000000000000000040", c5 = "0000000000000000000000000000000000000000000000000000000000000041", d5 = t.substring(2), a5 = hashMessage(n4).substring(2), f5 = u4 + a5 + l4 + c5 + d5, h6 = await fetch(`${s2 || Jt4}/?chainId=${r3}&projectId=${o4}`, { method: "POST", body: JSON.stringify({ id: zt4(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: f5 }, "latest"] }) }), { result: p4 } = await h6.json();
    return p4 ? p4.slice(0, u4.length).toLowerCase() === u4.toLowerCase() : false;
  } catch (u4) {
    return console.error("isValidEip1271Signature: ", u4), false;
  }
}
function zt4() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt4 = Object.defineProperty;
var Yt4 = Object.defineProperties;
var Qt3 = Object.getOwnPropertyDescriptors;
var sn4 = Object.getOwnPropertySymbols;
var Zt3 = Object.prototype.hasOwnProperty;
var Xt3 = Object.prototype.propertyIsEnumerable;
var cn3 = (e, n4, t) => n4 in e ? Gt4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var de3 = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    Zt3.call(n4, t) && cn3(e, t, n4[t]);
  if (sn4)
    for (var t of sn4(n4))
      Xt3.call(n4, t) && cn3(e, t, n4[t]);
  return e;
};
var an3 = (e, n4) => Yt4(e, Qt3(n4));
var er4 = "did:pkh:";
var z4 = (e) => e == null ? void 0 : e.split(":");
var un3 = (e) => {
  const n4 = e && z4(e);
  if (n4)
    return e.includes(er4) ? n4[3] : n4[1];
};
var ln3 = (e) => {
  const n4 = e && z4(e);
  if (n4)
    return n4[2] + ":" + n4[3];
};
var fe4 = (e) => {
  const n4 = e && z4(e);
  if (n4)
    return n4.pop();
};
async function nr4(e) {
  const { cacao: n4, projectId: t } = e, { s: r3, p: o4 } = n4, s2 = dn3(o4, o4.iss), i4 = fe4(o4.iss);
  return await tn2(i4, s2, r3, ln3(o4.iss), t);
}
var dn3 = (e, n4) => {
  const t = `${e.domain} wants you to sign in with your Ethereum account:`, r3 = fe4(n4);
  if (!e.aud && !e.uri)
    throw new Error("Either `aud` or `uri` is required to construct the message");
  let o4 = e.statement || void 0;
  const s2 = `URI: ${e.aud || e.uri}`, i4 = `Version: ${e.version}`, u4 = `Chain ID: ${un3(n4)}`, l4 = `Nonce: ${e.nonce}`, c5 = `Issued At: ${e.iat}`, d5 = e.exp ? `Expiration Time: ${e.exp}` : void 0, a5 = e.nbf ? `Not Before: ${e.nbf}` : void 0, f5 = e.requestId ? `Request ID: ${e.requestId}` : void 0, h6 = e.resources ? `Resources:${e.resources.map((m) => `
- ${m}`).join("")}` : void 0, p4 = Y2(e.resources);
  if (p4) {
    const m = R3(p4);
    o4 = he3(o4, m);
  }
  return [t, r3, "", o4, "", s2, i4, u4, l4, c5, d5, a5, f5, h6].filter((m) => m != null).join(`
`);
};
function hn3(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function yn2(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function O2(e) {
  if (!e)
    throw new Error("No recap provided, value is undefined");
  if (!e.att)
    throw new Error("No `att` property found");
  const n4 = Object.keys(e.att);
  if (!(n4 != null && n4.length))
    throw new Error("No resources found in `att` property");
  n4.forEach((t) => {
    const r3 = e.att[t];
    if (Array.isArray(r3))
      throw new Error(`Resource must be an object: ${t}`);
    if (typeof r3 != "object")
      throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(r3).length)
      throw new Error(`Resource object is empty: ${t}`);
    Object.keys(r3).forEach((o4) => {
      const s2 = r3[o4];
      if (!Array.isArray(s2))
        throw new Error(`Ability limits ${o4} must be an array of objects, found: ${s2}`);
      if (!s2.length)
        throw new Error(`Value of ${o4} is empty array, must be an array with objects`);
      s2.forEach((i4) => {
        if (typeof i4 != "object")
          throw new Error(`Ability limits (${o4}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function gn3(e, n4, t, r3 = {}) {
  return t == null ? void 0 : t.sort((o4, s2) => o4.localeCompare(s2)), { att: { [e]: pe2(n4, t, r3) } };
}
function pe2(e, n4, t = {}) {
  n4 = n4 == null ? void 0 : n4.sort((o4, s2) => o4.localeCompare(s2));
  const r3 = n4.map((o4) => ({ [`${e}/${o4}`]: [t] }));
  return Object.assign({}, ...r3);
}
function G2(e) {
  return O2(e), `urn:recap:${hn3(e).replace(/=/g, "")}`;
}
function R3(e) {
  const n4 = yn2(e.replace("urn:recap:", ""));
  return O2(n4), n4;
}
function ir4(e, n4, t) {
  const r3 = gn3(e, n4, t);
  return G2(r3);
}
function me4(e) {
  return e && e.includes("urn:recap:");
}
function cr4(e, n4) {
  const t = R3(e), r3 = R3(n4), o4 = bn2(t, r3);
  return G2(o4);
}
function bn2(e, n4) {
  O2(e), O2(n4);
  const t = Object.keys(e.att).concat(Object.keys(n4.att)).sort((o4, s2) => o4.localeCompare(s2)), r3 = { att: {} };
  return t.forEach((o4) => {
    var s2, i4;
    Object.keys(((s2 = e.att) == null ? void 0 : s2[o4]) || {}).concat(Object.keys(((i4 = n4.att) == null ? void 0 : i4[o4]) || {})).sort((u4, l4) => u4.localeCompare(l4)).forEach((u4) => {
      var l4, c5;
      r3.att[o4] = an3(de3({}, r3.att[o4]), { [u4]: ((l4 = e.att[o4]) == null ? void 0 : l4[u4]) || ((c5 = n4.att[o4]) == null ? void 0 : c5[u4]) });
    });
  }), r3;
}
function he3(e = "", n4) {
  O2(n4);
  const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(t))
    return e;
  const r3 = [];
  let o4 = 0;
  Object.keys(n4.att).forEach((u4) => {
    const l4 = Object.keys(n4.att[u4]).map((a5) => ({ ability: a5.split("/")[0], action: a5.split("/")[1] }));
    l4.sort((a5, f5) => a5.action.localeCompare(f5.action));
    const c5 = {};
    l4.forEach((a5) => {
      c5[a5.ability] || (c5[a5.ability] = []), c5[a5.ability].push(a5.action);
    });
    const d5 = Object.keys(c5).map((a5) => (o4++, `(${o4}) '${a5}': '${c5[a5].join("', '")}' for '${u4}'.`));
    r3.push(d5.join(", ").replace(".,", "."));
  });
  const s2 = r3.join(" "), i4 = `${t}${s2}`;
  return `${e ? e + " " : ""}${i4}`;
}
function ar4(e) {
  var n4;
  const t = R3(e);
  O2(t);
  const r3 = (n4 = t.att) == null ? void 0 : n4.eip155;
  return r3 ? Object.keys(r3).map((o4) => o4.split("/")[1]) : [];
}
function ur3(e) {
  const n4 = R3(e);
  O2(n4);
  const t = [];
  return Object.values(n4.att).forEach((r3) => {
    Object.values(r3).forEach((o4) => {
      var s2;
      (s2 = o4 == null ? void 0 : o4[0]) != null && s2.chains && t.push(o4[0].chains);
    });
  }), [...new Set(t.flat())];
}
function Y2(e) {
  if (!e)
    return;
  const n4 = e == null ? void 0 : e[e.length - 1];
  return me4(n4) ? n4 : void 0;
}
var ye3 = "base10";
var g4 = "base16";
var ge2 = "base64pad";
var lr3 = "base64url";
var k2 = "utf8";
var ve3 = 0;
var D = 1;
var M5 = 2;
var dr3 = 0;
var wn2 = 1;
var K3 = 12;
var be4 = 32;
function fr3() {
  const e = _e3.generateKeyPair();
  return { privateKey: toString(e.secretKey, g4), publicKey: toString(e.publicKey, g4) };
}
function pr3() {
  const e = (0, import_random3.randomBytes)(be4);
  return toString(e, g4);
}
function mr4(e, n4) {
  const t = _e3.sharedKey(fromString(e, g4), fromString(n4, g4), true), r3 = new import_hkdf.HKDF(import_sha2562.SHA256, t).expand(be4);
  return toString(r3, g4);
}
function hr3(e) {
  const n4 = (0, import_sha2562.hash)(fromString(e, g4));
  return toString(n4, g4);
}
function yr4(e) {
  const n4 = (0, import_sha2562.hash)(fromString(e, k2));
  return toString(n4, g4);
}
function Ee4(e) {
  return fromString(`${e}`, ye3);
}
function A3(e) {
  return Number(toString(e, ye3));
}
function gr3(e) {
  const n4 = Ee4(typeof e.type < "u" ? e.type : ve3);
  if (A3(n4) === D && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, g4) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, g4) : (0, import_random3.randomBytes)(K3), o4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g4)).seal(r3, fromString(e.message, k2));
  return we4({ type: n4, sealed: o4, iv: r3, senderPublicKey: t, encoding: e.encoding });
}
function vr3(e, n4) {
  const t = Ee4(M5), r3 = (0, import_random3.randomBytes)(K3), o4 = fromString(e, k2);
  return we4({ type: t, sealed: o4, iv: r3, encoding: n4 });
}
function br3(e) {
  const n4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g4)), { sealed: t, iv: r3 } = Q3({ encoded: e.encoded, encoding: e == null ? void 0 : e.encoding }), o4 = n4.open(r3, t);
  if (o4 === null)
    throw new Error("Failed to decrypt");
  return toString(o4, k2);
}
function Er3(e, n4) {
  const { sealed: t } = Q3({ encoded: e, encoding: n4 });
  return toString(t, k2);
}
function we4(e) {
  const { encoding: n4 = ge2 } = e;
  if (A3(e.type) === M5)
    return toString(concat([e.type, e.sealed]), n4);
  if (A3(e.type) === D) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), n4);
  }
  return toString(concat([e.type, e.iv, e.sealed]), n4);
}
function Q3(e) {
  const { encoded: n4, encoding: t = ge2 } = e, r3 = fromString(n4, t), o4 = r3.slice(dr3, wn2), s2 = wn2;
  if (A3(o4) === D) {
    const c5 = s2 + be4, d5 = c5 + K3, a5 = r3.slice(s2, c5), f5 = r3.slice(c5, d5), h6 = r3.slice(d5);
    return { type: o4, sealed: h6, iv: f5, senderPublicKey: a5 };
  }
  if (A3(o4) === M5) {
    const c5 = r3.slice(s2), d5 = (0, import_random3.randomBytes)(K3);
    return { type: o4, sealed: c5, iv: d5 };
  }
  const i4 = s2 + K3, u4 = r3.slice(s2, i4), l4 = r3.slice(i4);
  return { type: o4, sealed: l4, iv: u4 };
}
function wr3(e, n4) {
  const t = Q3({ encoded: e, encoding: n4 == null ? void 0 : n4.encoding });
  return On({ type: A3(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, g4) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function On(e) {
  const n4 = (e == null ? void 0 : e.type) || ve3;
  if (n4 === D) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Or3(e) {
  return e.type === D && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function Nr3(e) {
  return e.type === M5;
}
function Nn(e) {
  return new import_elliptic2.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function Sr3(e) {
  let n4 = e.replace(/-/g, "+").replace(/_/g, "/");
  const t = n4.length % 4;
  return t > 0 && (n4 += "=".repeat(4 - t)), n4;
}
function $r4(e) {
  return Buffer.from(Sr3(e), "base64");
}
function Rr4(e, n4) {
  const [t, r3, o4] = e.split("."), s2 = $r4(o4);
  if (s2.length !== 64)
    throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), u4 = s2.slice(32, 64).toString("hex"), l4 = `${t}.${r3}`, c5 = new import_sha2562.SHA256().update(Buffer.from(l4)).digest(), d5 = Nn(n4), a5 = Buffer.from(c5).toString("hex");
  if (!d5.verify(a5, { r: i4, s: u4 }))
    throw new Error("Invalid signature");
  return decodeJWT(e).payload;
}
var Sn2 = "irn";
function Ir2(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Sn2 };
}
function jr2(e) {
  const n4 = C[e];
  if (typeof n4 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var Tr4 = Object.defineProperty;
var Pr3 = Object.defineProperties;
var Ar3 = Object.getOwnPropertyDescriptors;
var $n = Object.getOwnPropertySymbols;
var Cr3 = Object.prototype.hasOwnProperty;
var Ur3 = Object.prototype.propertyIsEnumerable;
var Rn2 = (e, n4, t) => n4 in e ? Tr4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var In2 = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    Cr3.call(n4, t) && Rn2(e, t, n4[t]);
  if ($n)
    for (var t of $n(n4))
      Ur3.call(n4, t) && Rn2(e, t, n4[t]);
  return e;
};
var _r4 = (e, n4) => Pr3(e, Ar3(n4));
function jn2(e, n4 = "-") {
  const t = {}, r3 = "relay" + n4;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i4 = e[o4];
      t[s2] = i4;
    }
  }), t;
}
function kr3(e) {
  if (!e.includes("wc:")) {
    const l4 = le2(e);
    l4 != null && l4.includes("wc:") && (e = l4);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, n4), o4 = e.substring(n4 + 1, t).split("@"), s2 = typeof t < "u" ? e.substring(t) : "", i4 = q2.parse(s2), u4 = typeof i4.methods == "string" ? i4.methods.split(",") : void 0;
  return { protocol: r3, topic: Tn2(o4[0]), version: parseInt(o4[1], 10), symKey: i4.symKey, relay: jn2(i4), methods: u4, expiryTimestamp: i4.expiryTimestamp ? parseInt(i4.expiryTimestamp, 10) : void 0 };
}
function Tn2(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function Pn2(e, n4 = "-") {
  const t = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = t + n4 + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function Dr3(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + q2.stringify(In2(_r4(In2({ symKey: e.symKey }, Pn2(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {}));
}
function xr3(e, n4, t) {
  return `${e}?wc_ev=${t}&topic=${n4}`;
}
function C5(e) {
  const n4 = [];
  return e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4.push(`${r3}:${o4}`);
  }), n4;
}
function Un(e) {
  const n4 = [];
  return Object.values(e).forEach((t) => {
    n4.push(...C5(t.accounts));
  }), n4;
}
function _n2(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C5(r3.accounts).includes(n4) && t.push(...r3.methods);
  }), t;
}
function kn2(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C5(r3.accounts).includes(n4) && t.push(...r3.events);
  }), t;
}
function xn(e) {
  const n4 = {};
  return e == null ? void 0 : e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4[r3] || (n4[r3] = { accounts: [], chains: [], events: [] }), n4[r3].accounts.push(t), n4[r3].chains.push(`${r3}:${o4}`);
  }), n4;
}
function Jr3(e, n4) {
  n4 = n4.map((r3) => r3.replace("did:pkh:", ""));
  const t = xn(n4);
  for (const [r3, o4] of Object.entries(t))
    o4.methods ? o4.methods = N2(o4.methods, e) : o4.methods = e, o4.events = ["chainChanged", "accountsChanged"];
  return t;
}
var Vn2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Mn2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S3(e, n4) {
  const { message: t, code: r3 } = Mn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function U3(e, n4) {
  const { message: t, code: r3 } = Vn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function L2(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function Z3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function I2(e) {
  return typeof e > "u";
}
function b2(e, n4) {
  return n4 && I2(e) ? true : typeof e == "string" && !!e.trim().length;
}
function X2(e, n4) {
  return n4 && I2(e) ? true : typeof e == "number" && !isNaN(e);
}
function zr4(e, n4) {
  const { requiredNamespaces: t } = n4, r3 = Object.keys(e.namespaces), o4 = Object.keys(t);
  let s2 = true;
  return $3(o4, r3) ? (r3.forEach((i4) => {
    const { accounts: u4, methods: l4, events: c5 } = e.namespaces[i4], d5 = C5(u4), a5 = t[i4];
    (!$3(W3(i4, a5), d5) || !$3(a5.methods, l4) || !$3(a5.events, c5)) && (s2 = false);
  }), s2) : false;
}
function F4(e) {
  return b2(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Kn2(e) {
  if (b2(e, false) && e.includes(":")) {
    const n4 = e.split(":");
    if (n4.length === 3) {
      const t = n4[0] + ":" + n4[1];
      return !!n4[2] && F4(t);
    }
  }
  return false;
}
function Gr2(e) {
  function n4(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (b2(e, false)) {
      if (n4(e))
        return true;
      const t = le2(e);
      return n4(t);
    }
  } catch {
  }
  return false;
}
function Yr3(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function Qr2(e) {
  return e == null ? void 0 : e.topic;
}
function Zr3(e, n4) {
  let t = null;
  return b2(e == null ? void 0 : e.publicKey, false) || (t = S3("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t;
}
function Se2(e) {
  let n4 = true;
  return L2(e) ? e.length && (n4 = e.every((t) => b2(t, false))) : n4 = false, n4;
}
function Ln2(e, n4, t) {
  let r3 = null;
  return L2(n4) && n4.length ? n4.forEach((o4) => {
    r3 || F4(o4) || (r3 = U3("UNSUPPORTED_CHAINS", `${t}, chain ${o4} should be a string and conform to "namespace:chainId" format`));
  }) : F4(e) || (r3 = U3("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function Fn2(e, n4, t) {
  let r3 = null;
  return Object.entries(e).forEach(([o4, s2]) => {
    if (r3)
      return;
    const i4 = Ln2(o4, W3(o4, s2), `${n4} ${t}`);
    i4 && (r3 = i4);
  }), r3;
}
function qn2(e, n4) {
  let t = null;
  return L2(e) ? e.forEach((r3) => {
    t || Kn2(r3) || (t = U3("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U3("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function Bn2(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t)
      return;
    const o4 = qn2(r3 == null ? void 0 : r3.accounts, `${n4} namespace`);
    o4 && (t = o4);
  }), t;
}
function Hn2(e, n4) {
  let t = null;
  return Se2(e == null ? void 0 : e.methods) ? Se2(e == null ? void 0 : e.events) || (t = U3("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t = U3("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t;
}
function $e(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t)
      return;
    const o4 = Hn2(r3, `${n4}, namespace`);
    o4 && (t = o4);
  }), t;
}
function Xr2(e, n4, t) {
  let r3 = null;
  if (e && Z3(e)) {
    const o4 = $e(e, n4);
    o4 && (r3 = o4);
    const s2 = Fn2(e, n4, t);
    s2 && (r3 = s2);
  } else
    r3 = S3("MISSING_OR_INVALID", `${n4}, ${t} should be an object with data`);
  return r3;
}
function Wn2(e, n4) {
  let t = null;
  if (e && Z3(e)) {
    const r3 = $e(e, n4);
    r3 && (t = r3);
    const o4 = Bn2(e, n4);
    o4 && (t = o4);
  } else
    t = S3("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t;
}
function Jn2(e) {
  return b2(e.protocol, true);
}
function eo(e, n4) {
  let t = false;
  return n4 && !e ? t = true : e && L2(e) && e.length && e.forEach((r3) => {
    t = Jn2(r3);
  }), t;
}
function no2(e) {
  return typeof e == "number";
}
function to(e) {
  return typeof e < "u" && typeof e !== null;
}
function ro2(e) {
  return !(!e || typeof e != "object" || !e.code || !X2(e.code, false) || !e.message || !b2(e.message, false));
}
function oo(e) {
  return !(I2(e) || !b2(e.method, false));
}
function so(e) {
  return !(I2(e) || I2(e.result) && I2(e.error) || !X2(e.id, false) || !b2(e.jsonrpc, false));
}
function io(e) {
  return !(I2(e) || !b2(e.name, false));
}
function co2(e, n4) {
  return !(!F4(n4) || !Un(e).includes(n4));
}
function ao2(e, n4, t) {
  return b2(t, false) ? _n2(e, n4).includes(t) : false;
}
function uo2(e, n4, t) {
  return b2(t, false) ? kn2(e, n4).includes(t) : false;
}
function zn2(e, n4, t) {
  let r3 = null;
  const o4 = lo2(e), s2 = fo2(n4), i4 = Object.keys(o4), u4 = Object.keys(s2), l4 = Gn2(Object.keys(e)), c5 = Gn2(Object.keys(n4)), d5 = l4.filter((a5) => !c5.includes(a5));
  return d5.length && (r3 = S3("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d5.toString()}
      Received: ${Object.keys(n4).toString()}`)), $3(i4, u4) || (r3 = S3("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${u4.toString()}`)), Object.keys(n4).forEach((a5) => {
    if (!a5.includes(":") || r3)
      return;
    const f5 = C5(n4[a5].accounts);
    f5.includes(a5) || (r3 = S3("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a5}
        Required: ${a5}
        Approved: ${f5.toString()}`));
  }), i4.forEach((a5) => {
    r3 || ($3(o4[a5].methods, s2[a5].methods) ? $3(o4[a5].events, s2[a5].events) || (r3 = S3("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a5}`)) : r3 = S3("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a5}`));
  }), r3;
}
function lo2(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    var r3;
    t.includes(":") ? n4[t] = e[t] : (r3 = e[t].chains) == null || r3.forEach((o4) => {
      n4[o4] = { methods: e[t].methods, events: e[t].events };
    });
  }), n4;
}
function Gn2(e) {
  return [...new Set(e.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function fo2(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n4[t] = e[t];
    else {
      const r3 = C5(e[t].accounts);
      r3 == null ? void 0 : r3.forEach((o4) => {
        n4[o4] = { accounts: e[t].accounts.filter((s2) => s2.includes(`${o4}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n4;
}
function po2(e, n4) {
  return X2(e, false) && e <= n4.max && e >= n4.min;
}
function mo() {
  const e = P();
  return new Promise((n4) => {
    switch (e) {
      case y4.browser:
        n4(Yn2());
        break;
      case y4.reactNative:
        n4(Qn2());
        break;
      case y4.node:
        n4(Zn2());
        break;
      default:
        n4(true);
    }
  });
}
function Yn2() {
  return V4() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn2() {
  if (_2() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Zn2() {
  return true;
}
function ho2(e) {
  switch (P()) {
    case y4.browser:
      Xn2(e);
      break;
    case y4.reactNative:
      et4(e);
      break;
    case y4.node:
      break;
  }
}
function Xn2(e) {
  !_2() && V4() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function et4(e) {
  _2() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}
var Re = {};
var yo = class {
  static get(n4) {
    return Re[n4];
  }
  static set(n4, t) {
    Re[n4] = t;
  }
  static delete(n4) {
    delete Re[n4];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events11 = __toESM(require_events());
var w2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var b3 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a4 = (c5) => c5.split("?")[0];
var h5 = 10;
var S4 = w2();
var f2 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events11.EventEmitter(), this.registering = false, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o4) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o4(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return o4(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const o4 = new URLSearchParams(e).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o4 } } : { rejectUnauthorized: !isLocalhostUrl(e) }, i4 = new S4(e, [], s2);
      b3() ? i4.onerror = (r3) => {
        const l4 = r3;
        n4(this.emitError(l4.error));
      } : i4.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i4.onopen = () => {
        this.onOpen(i4), t(i4);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), o4 = n4.message || n4.toString(), s2 = formatJsonRpcError(e, o4);
    this.events.emit("payload", s2);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, a4(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h5 && this.events.setMaxListeners(h5);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${a4(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash2 = __toESM(require_lodash());
var import_window_getters4 = __toESM(require_cjs2());
var ye4 = "wc";
var De3 = 2;
var ie3 = "core";
var x6 = `${ye4}@2:${ie3}:`;
var Ye = { name: ie3, logger: "error" };
var Je3 = { database: ":memory:" };
var Xe4 = "crypto";
var me5 = "client_ed25519_seed";
var We5 = import_time7.ONE_DAY;
var Ze3 = "keychain";
var Qe3 = "0.3";
var et5 = "messages";
var tt4 = "0.3";
var it5 = import_time7.SIX_HOURS;
var st5 = "publisher";
var rt4 = "irn";
var nt3 = "error";
var be5 = "wss://relay.walletconnect.org";
var ot4 = "relayer";
var v5 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var at4 = "_subscription";
var I3 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht4 = 0.1;
var se3 = "2.17.1";
var M6 = { link_mode: "link_mode", relay: "relay" };
var ct3 = "0.3";
var lt3 = "WALLETCONNECT_CLIENT_ID";
var fe5 = "WALLETCONNECT_LINK_MODE_APPS";
var O3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var ut4 = "subscription";
var dt3 = "0.3";
var pt4 = import_time7.FIVE_SECONDS * 1e3;
var gt5 = "pairing";
var yt4 = "0.3";
var B4 = { wc_pairingDelete: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 } } };
var V5 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Dt4 = "history";
var mt4 = "0.3";
var bt5 = "expirer";
var S5 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var ft3 = "0.3";
var _t5 = "verify-api";
var vs2 = "https://verify.walletconnect.com";
var Et4 = "https://verify.walletconnect.org";
var J3 = Et4;
var vt5 = `${J3}/v3`;
var wt4 = [vs2, Et4];
var It4 = "echo";
var Tt4 = "https://echo.walletconnect.com";
var z5 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $4 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Is2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ts2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Cs2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Ps2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Ct4 = 0.1;
var Pt4 = "event-client";
var St4 = 86400;
var Rt3 = "https://pulse.walletconnect.org/batch";
function Ss3(o4, e) {
  if (o4.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++)
    t[s2] = 255;
  for (var i4 = 0; i4 < o4.length; i4++) {
    var r3 = o4.charAt(i4), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255)
      throw new TypeError(r3 + " is ambiguous");
    t[n4] = i4;
  }
  var a5 = o4.length, h6 = o4.charAt(0), c5 = Math.log(a5) / Math.log(256), l4 = Math.log(256) / Math.log(a5);
  function p4(u4) {
    if (u4 instanceof Uint8Array || (ArrayBuffer.isView(u4) ? u4 = new Uint8Array(u4.buffer, u4.byteOffset, u4.byteLength) : Array.isArray(u4) && (u4 = Uint8Array.from(u4))), !(u4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u4.length === 0)
      return "";
    for (var g6 = 0, _4 = 0, y7 = 0, b6 = u4.length; y7 !== b6 && u4[y7] === 0; )
      y7++, g6++;
    for (var A5 = (b6 - y7) * l4 + 1 >>> 0, T4 = new Uint8Array(A5); y7 !== b6; ) {
      for (var N3 = u4[y7], k4 = 0, R5 = A5 - 1; (N3 !== 0 || k4 < _4) && R5 !== -1; R5--, k4++)
        N3 += 256 * T4[R5] >>> 0, T4[R5] = N3 % a5 >>> 0, N3 = N3 / a5 >>> 0;
      if (N3 !== 0)
        throw new Error("Non-zero carry");
      _4 = k4, y7++;
    }
    for (var L4 = A5 - _4; L4 !== A5 && T4[L4] === 0; )
      L4++;
    for (var Q5 = h6.repeat(g6); L4 < A5; ++L4)
      Q5 += o4.charAt(T4[L4]);
    return Q5;
  }
  function D4(u4) {
    if (typeof u4 != "string")
      throw new TypeError("Expected String");
    if (u4.length === 0)
      return new Uint8Array();
    var g6 = 0;
    if (u4[g6] !== " ") {
      for (var _4 = 0, y7 = 0; u4[g6] === h6; )
        _4++, g6++;
      for (var b6 = (u4.length - g6) * c5 + 1 >>> 0, A5 = new Uint8Array(b6); u4[g6]; ) {
        var T4 = t[u4.charCodeAt(g6)];
        if (T4 === 255)
          return;
        for (var N3 = 0, k4 = b6 - 1; (T4 !== 0 || N3 < y7) && k4 !== -1; k4--, N3++)
          T4 += a5 * A5[k4] >>> 0, A5[k4] = T4 % 256 >>> 0, T4 = T4 / 256 >>> 0;
        if (T4 !== 0)
          throw new Error("Non-zero carry");
        y7 = N3, g6++;
      }
      if (u4[g6] !== " ") {
        for (var R5 = b6 - y7; R5 !== b6 && A5[R5] === 0; )
          R5++;
        for (var L4 = new Uint8Array(_4 + (b6 - R5)), Q5 = _4; R5 !== b6; )
          L4[Q5++] = A5[R5++];
        return L4;
      }
    }
  }
  function m(u4) {
    var g6 = D4(u4);
    if (g6)
      return g6;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p4, decodeUnsafe: D4, decode: m };
}
var Rs2 = Ss3;
var xs2 = Rs2;
var xt5 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array")
    return o4;
  if (o4 instanceof ArrayBuffer)
    return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4))
    return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Os2 = (o4) => new TextEncoder().encode(o4);
var As2 = (o4) => new TextDecoder().decode(o4);
var Ns2 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var zs3 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ot5(this, e);
  }
};
var Ls3 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ot5(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2)
      return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ot5 = (o4, e) => new Ls3({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var $s3 = class {
  constructor(e, t, s2, i4) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Ns2(e, t, s2), this.decoder = new zs3(e, t, i4);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var re4 = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new $s3(o4, e, t, s2);
var X3 = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i4 } = xs2(t, e);
  return re4({ prefix: o4, name: e, encode: s2, decode: (r3) => xt5(i4(r3)) });
};
var ks3 = (o4, e, t, s2) => {
  const i4 = {};
  for (let l4 = 0; l4 < e.length; ++l4)
    i4[e[l4]] = l4;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; )
    --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, h6 = 0, c5 = 0;
  for (let l4 = 0; l4 < r3; ++l4) {
    const p4 = i4[o4[l4]];
    if (p4 === void 0)
      throw new SyntaxError(`Non-${s2} character`);
    h6 = h6 << t | p4, a5 += t, a5 >= 8 && (a5 -= 8, n4[c5++] = 255 & h6 >> a5);
  }
  if (a5 >= t || 255 & h6 << 8 - a5)
    throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Ms3 = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i4 = (1 << t) - 1;
  let r3 = "", n4 = 0, a5 = 0;
  for (let h6 = 0; h6 < o4.length; ++h6)
    for (a5 = a5 << 8 | o4[h6], n4 += 8; n4 > t; )
      n4 -= t, r3 += e[i4 & a5 >> n4];
  if (n4 && (r3 += e[i4 & a5 << t - n4]), s2)
    for (; r3.length * t & 7; )
      r3 += "=";
  return r3;
};
var f3 = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => re4({ prefix: e, name: o4, encode(i4) {
  return Ms3(i4, s2, t);
}, decode(i4) {
  return ks3(i4, s2, t, o4);
} });
var Us3 = re4({ prefix: "\0", name: "identity", encode: (o4) => As2(o4), decode: (o4) => Os2(o4) });
var Fs3 = Object.freeze({ __proto__: null, identity: Us3 });
var Ks3 = f3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs3 = Object.freeze({ __proto__: null, base2: Ks3 });
var Vs3 = f3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js3 = Object.freeze({ __proto__: null, base8: Vs3 });
var qs3 = X3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs3 = Object.freeze({ __proto__: null, base10: qs3 });
var Hs3 = f3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ys3 = f3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js3 = Object.freeze({ __proto__: null, base16: Hs3, base16upper: Ys3 });
var Xs3 = f3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ws3 = f3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Zs3 = f3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Qs2 = f3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var er5 = f3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var tr4 = f3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ir5 = f3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var sr4 = f3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var rr4 = f3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr5 = Object.freeze({ __proto__: null, base32: Xs3, base32upper: Ws3, base32pad: Zs3, base32padupper: Qs2, base32hex: er5, base32hexupper: tr4, base32hexpad: ir5, base32hexpadupper: sr4, base32z: rr4 });
var or4 = X3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ar5 = X3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr4 = Object.freeze({ __proto__: null, base36: or4, base36upper: ar5 });
var cr5 = X3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var lr4 = X3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur4 = Object.freeze({ __proto__: null, base58btc: cr5, base58flickr: lr4 });
var dr4 = f3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var pr4 = f3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var gr4 = f3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var yr5 = f3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr4 = Object.freeze({ __proto__: null, base64: dr4, base64pad: pr4, base64url: gr4, base64urlpad: yr5 });
var At4 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var mr5 = At4.reduce((o4, e, t) => (o4[t] = e, o4), []);
var br4 = At4.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function fr4(o4) {
  return o4.reduce((e, t) => (e += mr5[t], e), "");
}
function _r5(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = br4[t.codePointAt(0)];
    if (s2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Er4 = re4({ prefix: "🚀", name: "base256emoji", encode: fr4, decode: _r5 });
var vr4 = Object.freeze({ __proto__: null, base256emoji: Er4 });
var wr4 = zt5;
var Nt5 = 128;
var Ir3 = 127;
var Tr5 = ~Ir3;
var Cr4 = Math.pow(2, 31);
function zt5(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Cr4; )
    e[t++] = o4 & 255 | Nt5, o4 /= 128;
  for (; o4 & Tr5; )
    e[t++] = o4 & 255 | Nt5, o4 >>>= 7;
  return e[t] = o4 | 0, zt5.bytes = t - s2 + 1, e;
}
var Pr4 = _e4;
var Sr4 = 128;
var Lt4 = 127;
function _e4(o4, s2) {
  var t = 0, s2 = s2 || 0, i4 = 0, r3 = s2, n4, a5 = o4.length;
  do {
    if (r3 >= a5)
      throw _e4.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i4 < 28 ? (n4 & Lt4) << i4 : (n4 & Lt4) * Math.pow(2, i4), i4 += 7;
  } while (n4 >= Sr4);
  return _e4.bytes = r3 - s2, t;
}
var Rr5 = Math.pow(2, 7);
var xr4 = Math.pow(2, 14);
var Or4 = Math.pow(2, 21);
var Ar4 = Math.pow(2, 28);
var Nr4 = Math.pow(2, 35);
var zr5 = Math.pow(2, 42);
var Lr3 = Math.pow(2, 49);
var $r5 = Math.pow(2, 56);
var kr4 = Math.pow(2, 63);
var Mr2 = function(o4) {
  return o4 < Rr5 ? 1 : o4 < xr4 ? 2 : o4 < Or4 ? 3 : o4 < Ar4 ? 4 : o4 < Nr4 ? 5 : o4 < zr5 ? 6 : o4 < Lr3 ? 7 : o4 < $r5 ? 8 : o4 < kr4 ? 9 : 10;
};
var Ur4 = { encode: wr4, decode: Pr4, encodingLength: Mr2 };
var $t4 = Ur4;
var kt5 = (o4, e, t = 0) => ($t4.encode(o4, e, t), e);
var Mt4 = (o4) => $t4.encodingLength(o4);
var Ee5 = (o4, e) => {
  const t = e.byteLength, s2 = Mt4(o4), i4 = s2 + Mt4(t), r3 = new Uint8Array(i4 + t);
  return kt5(o4, r3, 0), kt5(t, r3, s2), r3.set(e, i4), new Fr3(o4, t, e, r3);
};
var Fr3 = class {
  constructor(e, t, s2, i4) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i4;
  }
};
var Ut4 = ({ name: o4, code: e, encode: t }) => new Kr2(o4, e, t);
var Kr2 = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ee5(this.code, t) : t.then((s2) => Ee5(this.code, s2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ft5 = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var Br4 = Ut4({ name: "sha2-256", code: 18, encode: Ft5("SHA-256") });
var Vr2 = Ut4({ name: "sha2-512", code: 19, encode: Ft5("SHA-512") });
var jr3 = Object.freeze({ __proto__: null, sha256: Br4, sha512: Vr2 });
var Kt4 = 0;
var qr2 = "identity";
var Bt5 = xt5;
var Gr3 = (o4) => Ee5(Kt4, Bt5(o4));
var Hr2 = { code: Kt4, name: qr2, encode: Bt5, digest: Gr3 };
var Yr4 = Object.freeze({ __proto__: null, identity: Hr2 });
new TextEncoder(), new TextDecoder();
var Vt4 = { ...Fs3, ...Bs3, ...js3, ...Gs3, ...Js3, ...nr5, ...hr4, ...ur4, ...Dr4, ...vr4 };
({ ...jr3, ...Yr4 });
function Jr4(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function jt4(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var qt4 = jt4("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var ve4 = jt4("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++)
    e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = Jr4(o4.length);
  for (let t = 0; t < o4.length; t++)
    e[t] = o4.charCodeAt(t);
  return e;
});
var Xr3 = { utf8: qt4, "utf-8": qt4, hex: Vt4.base16, latin1: ve4, ascii: ve4, binary: ve4, ...Vt4 };
function Wr3(o4, e = "utf8") {
  const t = Xr3[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Gt5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze3, this.version = Qe3, this.initialized = false, this.storagePrefix = x6, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = S3("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Tt3(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt3(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ht4 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Xe4, this.randomSessionIdentifier = pr3(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i4) => (this.isInitialized(), this.keychain.has(i4)), this.getClientId = async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = generateKeyPair(i4);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i4 = fr3();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }, this.signJWT = async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a5 = this.randomSessionIdentifier, h6 = We5;
      return await signJWT(a5, i4, h6, n4);
    }, this.generateSharedKey = (i4, r3, n4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i4), h6 = mr4(a5, r3);
      return this.setSymKey(h6, n4);
    }, this.setSymKey = async (i4, r3) => {
      this.isInitialized();
      const n4 = r3 || hr3(i4);
      return await this.keychain.set(n4, i4), n4;
    }, this.deleteKeyPair = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.deleteSymKey = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.encode = async (i4, r3, n4) => {
      this.isInitialized();
      const a5 = On(n4), h6 = safeJsonStringify(r3);
      if (Nr3(a5))
        return vr3(h6, n4 == null ? void 0 : n4.encoding);
      if (Or3(a5)) {
        const D4 = a5.senderPublicKey, m = a5.receiverPublicKey;
        i4 = await this.generateSharedKey(D4, m);
      }
      const c5 = this.getSymKey(i4), { type: l4, senderPublicKey: p4 } = a5;
      return gr3({ type: l4, symKey: c5, message: h6, senderPublicKey: p4, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i4, r3, n4) => {
      this.isInitialized();
      const a5 = wr3(r3, n4);
      if (Nr3(a5)) {
        const h6 = Er3(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(h6);
      }
      if (Or3(a5)) {
        const h6 = a5.receiverPublicKey, c5 = a5.senderPublicKey;
        i4 = await this.generateSharedKey(h6, c5);
      }
      try {
        const h6 = this.getSymKey(i4), c5 = br3({ symKey: h6, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(c5);
      } catch (h6) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(h6);
      }
    }, this.getPayloadType = (i4, r3 = ge2) => {
      const n4 = Q3({ encoded: i4, encoding: r3 });
      return A3(n4.type);
    }, this.getPayloadSenderPublicKey = (i4, r3 = ge2) => {
      const n4 = Q3({ encoded: i4, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, g4) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Gt5(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me5);
    } catch {
      e = pr3(), await this.keychain.set(me5, e);
    }
    return Wr3(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt5 = class extends a3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = et5, this.version = tt4, this.initialized = false, this.storagePrefix = x6, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i4) => {
      this.isInitialized();
      const r3 = yr4(i4);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i4, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }, this.has = (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = yr4(i4);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Tt3(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt3(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zr4 = class extends g3 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events12.EventEmitter(), this.name = st5, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.failedPublishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i4, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || it5, h6 = Ir2(r3), c5 = (r3 == null ? void 0 : r3.prompt) || false, l4 = (r3 == null ? void 0 : r3.tag) || 0, p4 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D4 = { topic: s2, message: i4, opts: { ttl: a5, relay: h6, prompt: c5, tag: l4, id: p4, attestation: r3 == null ? void 0 : r3.attestation } }, m = `Failed to publish payload, please try again. id:${p4} tag:${l4}`, u4 = Date.now();
      let g6, _4 = 1;
      try {
        for (; g6 === void 0; ) {
          if (Date.now() - u4 > this.publishTimeout)
            throw new Error(m);
          this.logger.trace({ id: p4, attempts: _4 }, `publisher.publish - attempt ${_4}`), g6 = await await kt4(this.rpcPublish(s2, i4, a5, h6, c5, l4, p4, r3 == null ? void 0 : r3.attestation).catch((y7) => this.logger.warn(y7)), this.publishTimeout, m), _4++, g6 || await new Promise((y7) => setTimeout(y7, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v5.publish, D4), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p4, topic: s2, message: i4, opts: r3 } });
      } catch (y7) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(y7), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish)
          throw y7;
        this.queue.set(p4, D4);
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e, t, s2, i4, r3, n4, a5, h6) {
    var c5, l4, p4, D4;
    const m = { method: jr2(i4.protocol).publish, params: { topic: e, message: t, ttl: s2, prompt: r3, tag: n4, attestation: h6 }, id: a5 };
    return I2((c5 = m.params) == null ? void 0 : c5.prompt) && ((l4 = m.params) == null || delete l4.prompt), I2((p4 = m.params) == null ? void 0 : p4.tag) && ((D4 = m.params) == null || delete D4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m }), this.relayer.request(m);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: s2, opts: i4 } = e;
      await this.publish(t, s2, i4);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v5.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v5.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Qr3 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const s2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const i4 = s2.filter((r3) => r3 !== t);
      if (!i4.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i4);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var en3 = Object.defineProperty;
var tn3 = Object.defineProperties;
var sn5 = Object.getOwnPropertyDescriptors;
var Jt5 = Object.getOwnPropertySymbols;
var rn3 = Object.prototype.hasOwnProperty;
var nn3 = Object.prototype.propertyIsEnumerable;
var Xt4 = (o4, e, t) => e in o4 ? en3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var W4 = (o4, e) => {
  for (var t in e || (e = {}))
    rn3.call(e, t) && Xt4(o4, t, e[t]);
  if (Jt5)
    for (var t of Jt5(e))
      nn3.call(e, t) && Xt4(o4, t, e[t]);
  return o4;
};
var we5 = (o4, e) => tn3(o4, sn5(e));
var Wt5 = class extends d4 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr3(), this.events = new import_events12.EventEmitter(), this.name = ut4, this.version = dt3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x6, this.subscribeTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = Ir2(i4), n4 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, n4);
        const a5 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a5 == "string" && (this.onSubscribe(a5, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i4) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2))
        return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a5 = new import_time7.Watch();
        a5.start(i4);
        const h6 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(h6), a5.stop(i4), r3(true)), a5.elapsed(i4) >= pt4 && (clearInterval(h6), a5.stop(i4), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e, i4, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i4 = Ir2(s2);
      await this.rpcUnsubscribe(e, t, i4);
      const r3 = U3("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i4;
    (s2 == null ? void 0 : s2.transportType) === M6.relay && await this.restartToComplete();
    const r3 = { method: jr2(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const n4 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a5 = yr4(e + this.clientId);
      if ((s2 == null ? void 0 : s2.transportType) === M6.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((c5) => this.logger.warn(c5));
        }, (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND)), a5;
      const h6 = await kt4(this.relayer.request(r3).catch((c5) => this.logger.warn(c5)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h6 && n4)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return h6 ? a5 : null;
    } catch (a5) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v5.connection_stalled), n4)
        throw a5;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, s2 = { method: jr2(t.protocol).batchSubscribe, params: { topics: e.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await kt4(this.relayer.request(s2).catch((i4) => this.logger.warn(i4)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v5.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length)
      return;
    const t = e[0].relay, s2 = { method: jr2(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await kt4(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v5.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e, t, s2) {
    const i4 = { method: jr2(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, we5(W4({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, W4({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, W4({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O3.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = S3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(O3.deleted, we5(W4({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O3.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(O3.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = S3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    L2(t) && this.onBatchSubscribe(t.map((s2, i4) => we5(W4({}, e[i4]), { id: s2 })));
  }
  async batchFetchMessages(e) {
    if (!e.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O3.created, async (e) => {
      const t = O3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(O3.deleted, async (e) => {
      const t = O3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var on3 = Object.defineProperty;
var Zt4 = Object.getOwnPropertySymbols;
var an4 = Object.prototype.hasOwnProperty;
var hn4 = Object.prototype.propertyIsEnumerable;
var Qt4 = (o4, e, t) => e in o4 ? on3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ei3 = (o4, e) => {
  for (var t in e || (e = {}))
    an4.call(e, t) && Qt4(o4, t, e[t]);
  if (Zt4)
    for (var t of Zt4(e))
      hn4.call(e, t) && Qt4(o4, t, e[t]);
  return o4;
};
var ti3 = class extends u2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events12.EventEmitter(), this.name = ot4, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time7.toMiliseconds)(import_time7.THIRTY_SECONDS + import_time7.ONE_SECOND), this.request = async (t) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a5 = await new Promise(async (h6, c5) => {
          const l4 = () => {
            c5(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(I3.disconnect, l4);
          const p4 = await n4;
          this.provider.off(I3.disconnect, l4), h6(p4);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - published"), a5;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (ce4())
        try {
          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var t, s2, i4;
            (i4 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
          }, this.heartBeatTimeout);
        } catch (t) {
          this.logger.warn(t);
        }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v5.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(v5.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I3.payload, this.onPayloadHandler), this.provider.on(I3.connect, this.onConnectHandler), this.provider.on(I3.disconnect, this.onDisconnectHandler), this.provider.on(I3.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || nt3 })), this.messages = new Yt5(this.logger, e.core), this.subscriber = new Wt5(this, this.logger), this.publisher = new Zr4(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.projectId = e.projectId, this.bundleId = Ot4(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0)
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e);
      }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: M6.relay });
  }
  async subscribe(e, t) {
    var s2, i4, r3;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    const n4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a5 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", h6;
    const c5 = (l4) => {
      l4.topic === e && (this.subscriber.off(O3.created, c5), h6());
    };
    return await Promise.all([new Promise((l4) => {
      h6 = l4, this.subscriber.on(O3.created, c5);
    }), new Promise(async (l4, p4) => {
      a5 = await this.subscriber.subscribe(e, ei3({ internal: { throwOnFailedPublish: n4 } }, t)).catch((D4) => {
        n4 && p4(D4);
      }) || a5, l4();
    })]), a5;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0)
      try {
        await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
      } catch (e) {
        this.logger.warn(e);
      }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt4(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i4 = () => {
          this.provider.off(I3.disconnect, i4), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I3.disconnect, i4), await kt4(this.provider.connect(), (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message))
        throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t)
      try {
        await this.onMessageEvent(s2);
      } catch (i4) {
        this.logger.warn(i4);
      }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i4 = Mt3(import_time7.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(v5.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, t, s2, i4, r3;
    if (ce4())
      try {
        (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.once("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (n4) {
        this.logger.warn(n4);
      }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f2($t3({ sdkVersion: se3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i4 = this.messages.has(t, s2);
    return i4 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(at4))
        return;
      const t = e.params, { topic: s2, message: i4, publishedAt: r3, attestation: n4 } = t.data, a5 = { topic: s2, message: i4, publishedAt: r3, transportType: M6.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei3({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else
      isJsonRpcResponse(e) && this.events.emit(v5.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v5.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(I3.payload, this.onPayloadHandler), this.provider.off(I3.connect, this.onConnectHandler), this.provider.off(I3.disconnect, this.onDisconnectHandler), this.provider.off(I3.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await mo();
    ho2(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v5.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time7.toMiliseconds)(ht4))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var cn4 = Object.defineProperty;
var ii3 = Object.getOwnPropertySymbols;
var ln4 = Object.prototype.hasOwnProperty;
var un4 = Object.prototype.propertyIsEnumerable;
var si3 = (o4, e, t) => e in o4 ? cn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ri3 = (o4, e) => {
  for (var t in e || (e = {}))
    ln4.call(e, t) && si3(o4, t, e[t]);
  if (ii3)
    for (var t of ii3(e))
      un4.call(e, t) && si3(o4, t, e[t]);
  return o4;
};
var ni3 = class extends p2 {
  constructor(e, t, s2, i4 = x6, r3 = void 0) {
    super(e, t, s2, i4), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = ct3, this.cached = [], this.initialized = false, this.storagePrefix = x6, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !I2(n4) ? this.map.set(this.getKey(n4), n4) : Yr3(n4) ? this.map.set(n4.id, n4) : Qr2(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a5 }), this.map.set(n4, a5), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a5) => Object.keys(n4).every((h6) => (0, import_lodash2.default)(a5[h6], n4[h6]))) : this.values), this.update = async (n4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a5 });
      const h6 = ri3(ri3({}, this.getData(n4)), a5);
      this.map.set(n4, h6), await this.persist();
    }, this.delete = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a5 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i4 } = S3("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = S3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = S3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var oi3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = gt5, this.version = yt4, this.events = new import_events12.default(), this.initialized = false, this.storagePrefix = x6, this.ignoredPayloadTypes = [D], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i4 = pr3(), r3 = await this.core.crypto.setSymKey(i4), n4 = Mt3(import_time7.FIVE_MINUTES), a5 = { protocol: rt4 }, h6 = { topic: r3, expiry: n4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, c5 = Dr3({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a5, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(V5.create, h6), this.core.expirer.set(r3, n4), await this.pairings.set(r3, h6), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: c5 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z5.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: n4, relay: a5, expiryTimestamp: h6, methods: c5 } = kr3(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(z5.pairing_uri_validation_success), i4.addTrace(z5.pairing_uri_not_expired);
      let l4;
      if (this.pairings.keys.includes(r3)) {
        if (l4 = this.pairings.get(r3), i4.addTrace(z5.existing_pairing), l4.active)
          throw i4.setError($4.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(z5.pairing_not_expired);
      }
      const p4 = h6 || Mt3(import_time7.FIVE_MINUTES), D4 = { topic: r3, relay: a5, expiry: p4, active: false, methods: c5 };
      this.core.expirer.set(r3, p4), await this.pairings.set(r3, D4), i4.addTrace(z5.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(V5.create, D4), i4.addTrace(z5.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i4.addTrace(z5.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError($4.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (m) {
        throw i4.setError($4.subscribe_pairing_topic_failure), m;
      }
      return i4.addTrace(z5.subscribe_pairing_topic_success), D4;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = Mt3(import_time7.THIRTY_DAYS);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: n4, resolve: a5, reject: h6 } = _t4();
        this.events.once(Lt3("pairing_ping", r3), ({ error: c5 }) => {
          c5 ? h6(c5) : a5();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", U3("USER_DISCONNECTED")), await this.deletePairing(i4));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: n4, methods: a5 } = s2, h6 = this.core.crypto.keychain.get(i4);
      return Dr3({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: h6, relay: r3, expiryTimestamp: n4, methods: a5 });
    }, this.sendRequest = async (s2, i4, r3) => {
      const n4 = formatJsonRpcRequest(i4, r3), a5 = await this.core.crypto.encode(s2, n4), h6 = B4[i4].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a5, h6), n4.id;
    }, this.sendResult = async (s2, i4, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i4, n4), h6 = await this.core.history.get(i4, s2), c5 = B4[h6.request.method].res;
      await this.core.relayer.publish(i4, a5, c5), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i4, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i4, n4), h6 = await this.core.history.get(i4, s2), c5 = B4[h6.request.method] ? B4[h6.request.method].res : B4.unregistered_method.res;
      await this.core.relayer.publish(i4, a5, c5), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, U3("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i4) => Kt3(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i4, payload: r3 } = s2, n4 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(V5.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(Lt3("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(Lt3("pairing_ping", r3), { error: i4.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(V5.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i4) => {
      const { id: r3, method: n4 } = i4;
      try {
        if (this.registeredMethods.includes(n4))
          return;
        const a5 = U3("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(U3("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i4) => {
      var r3;
      if (!to(s2)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (!Gr2(s2.uri)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError($4.malformed_pairing_uri), new Error(a5);
      }
      const n4 = kr3(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time7.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i4.setError($4.pairing_expired);
        const { message: a5 } = S3("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }, this.isValidPing = async (s2) => {
      if (!to(s2)) {
        const { message: r3 } = S3("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidDisconnect = async (s2) => {
      if (!to(s2)) {
        const { message: r3 } = S3("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidPairingTopic = async (s2) => {
      if (!b2(s2, false)) {
        const { message: i4 } = S3("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = S3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (Kt3(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = S3("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new ni3(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v5.message, async (e) => {
      const { topic: t, message: s2, transportType: i4 } = e;
      if (!this.pairings.keys.includes(t) || i4 === M6.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2)))
        return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S5.expired, async (e) => {
      const { topic: t } = Vt3(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V5.expire, { topic: t }));
    });
  }
};
var ai3 = class extends h4 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = Dt4, this.version = mt4, this.cached = [], this.initialized = false, this.storagePrefix = x6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id))
        return;
      const n4 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: Mt3(import_time7.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P2.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id))
        return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(P2.updated, i4));
    }, this.get = async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4)), this.delete = (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4)
            return;
          this.records.delete(r3.id), this.events.emit(P2.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false), this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = S3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = S3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(P2.created, (e) => {
      const t = P2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P2.updated, (e) => {
      const t = P2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P2.deleted, (e) => {
      const t = P2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time7.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var hi3 = class extends x5 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = bt5, this.version = ft3, this.cached = [], this.initialized = false, this.storagePrefix = x6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i4 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(S5.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(S5.deleted, { target: i4, expiration: r3 });
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return Dt3(e);
    if (typeof e == "number")
      return xt4(e);
    const { message: t } = S3("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S5.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = S3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = S3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time7.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(S5.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(S5.created, (e) => {
      const t = S5.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S5.expired, (e) => {
      const t = S5.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S5.deleted, (e) => {
      const t = S5.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ci3 = class extends y3 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = _t5, this.verifyUrlV3 = vt5, this.storagePrefix = x6, this.version = De3, this.init = async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time7.toMiliseconds)((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i4) => {
      if (!V4() || this.isDevEnv)
        return;
      const r3 = window.location.origin, { id: n4, decryptedId: a5 } = i4, h6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a5}`;
      try {
        const c5 = (0, import_window_getters4.getDocument)(), l4 = this.startAbortTimer(import_time7.ONE_SECOND * 5), p4 = await new Promise((D4, m) => {
          const u4 = () => {
            window.removeEventListener("message", _4), c5.body.removeChild(g6), m("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u4);
          const g6 = c5.createElement("iframe");
          g6.src = h6, g6.style.display = "none", g6.addEventListener("error", u4, { signal: this.abortController.signal });
          const _4 = (y7) => {
            if (y7.data && typeof y7.data == "string")
              try {
                const b6 = JSON.parse(y7.data);
                if (b6.type === "verify_attestation") {
                  if (decodeJWT(b6.attestation).payload.id !== n4)
                    return;
                  clearInterval(l4), c5.body.removeChild(g6), this.abortController.signal.removeEventListener("abort", u4), window.removeEventListener("message", _4), D4(b6.attestation === null ? "" : b6.attestation);
                }
              } catch (b6) {
                this.logger.warn(b6);
              }
          };
          c5.body.appendChild(g6), window.addEventListener("message", _4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p4), p4;
      } catch (c5) {
        this.logger.warn(c5);
      }
      return "";
    }, this.resolve = async (i4) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: r3, hash: n4, encryptedId: a5 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a5)
          return;
        const c5 = await this.isValidJwtAttestation(r3);
        if (c5) {
          if (!c5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return c5;
        }
      }
      if (!n4)
        return;
      const h6 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(n4, h6);
    }, this.fetchAttestation = async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time7.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a5.status === 200 ? await a5.json() : void 0;
    }, this.getVerifyUrl = (i4) => {
      let r3 = i4 || J3;
      return wt4.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${J3}`), r3 = J3), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(import_time7.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.persistPublicKey = async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3)
          return this.validateAttestation(i4, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4)
          return this.validateAttestation(i4, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }, this.validateAttestation = (i4, r3) => {
      const n4 = Rr4(i4, r3.publicKey), a5 = { hasExpired: (0, import_time7.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a5.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt4(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time7.toMiliseconds)(e));
  }
};
var li3 = class extends v4 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = It4, this.registerDeviceToken = async (s2) => {
      const { clientId: i4, token: r3, notificationType: n4, enableEncrypted: a5 = false } = s2, h6 = `${Tt4}/${this.projectId}/clients`;
      await fetch(h6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: n4, token: r3, always_raw: a5 }) });
    }, this.logger = E(t, this.context);
  }
};
var dn4 = Object.defineProperty;
var ui3 = Object.getOwnPropertySymbols;
var pn3 = Object.prototype.hasOwnProperty;
var gn4 = Object.prototype.propertyIsEnumerable;
var di3 = (o4, e, t) => e in o4 ? dn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Z4 = (o4, e) => {
  for (var t in e || (e = {}))
    pn3.call(e, t) && di3(o4, t, e[t]);
  if (ui3)
    for (var t of ui3(e))
      gn4.call(e, t) && di3(o4, t, e[t]);
  return o4;
};
var pi3 = class extends C4 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = Pt4, this.storagePrefix = x6, this.storageVersion = Ct4, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Wt4())
        try {
          const i4 = { eventId: Ht3(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge2(this.core.relayer.protocol, this.core.relayer.version, se3) } } };
          await this.sendEvent([i4]);
        } catch (i4) {
          this.logger.warn(i4);
        }
    }, this.createEvent = (i4) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a5, trace: h6 } } = i4, c5 = Ht3(), l4 = this.core.projectId || "", p4 = Date.now(), D4 = Z4({ eventId: c5, timestamp: p4, props: { event: r3, type: n4, properties: { topic: a5, trace: h6 } }, bundleId: l4, domain: this.getAppDomain() }, this.setMethods(c5));
      return this.telemetryEnabled && (this.events.set(c5, D4), this.shouldPersist = true), D4;
    }, this.getEvent = (i4) => {
      const { eventId: r3, topic: n4 } = i4;
      if (r3)
        return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((h6) => h6.props.properties.topic === n4);
      if (a5)
        return Z4(Z4({}, a5), this.setMethods(a5.eventId));
    }, this.deleteEvent = (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          (0, import_time7.fromMiliseconds)(Date.now()) - (0, import_time7.fromMiliseconds)(i4.timestamp) > St4 && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) }), this.addTrace = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.setError = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length)
          return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, Z4(Z4({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const i4 = [];
      for (const [r3, n4] of this.events)
        n4.props.type && i4.push(n4);
      if (i4.length !== 0)
        try {
          if ((await this.sendEvent(i4)).ok)
            for (const r3 of i4)
              this.events.delete(r3.eventId), this.shouldPersist = true;
        } catch (r3) {
          this.logger.warn(r3);
        }
    }, this.sendEvent = async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se3}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }, this.getAppDomain = () => Nt4().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var yn3 = Object.defineProperty;
var gi3 = Object.getOwnPropertySymbols;
var Dn3 = Object.prototype.hasOwnProperty;
var mn2 = Object.prototype.propertyIsEnumerable;
var yi3 = (o4, e, t) => e in o4 ? yn3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Di3 = (o4, e) => {
  for (var t in e || (e = {}))
    Dn3.call(e, t) && yi3(o4, t, e[t]);
  if (gi3)
    for (var t of gi3(e))
      mn2.call(e, t) && yi3(o4, t, e[t]);
  return o4;
};
var ne5 = class _ne extends n3 {
  constructor(e) {
    var t;
    super(e), this.protocol = ye4, this.version = De3, this.name = ie3, this.events = new import_events12.EventEmitter(), this.initialized = false, this.on = (n4, a5) => this.events.on(n4, a5), this.once = (n4, a5) => this.events.once(n4, a5), this.off = (n4, a5) => this.events.off(n4, a5), this.removeListener = (n4, a5) => this.events.removeListener(n4, a5), this.dispatchEnvelope = ({ topic: n4, message: a5, sessionExists: h6 }) => {
      if (!n4 || !a5)
        return;
      const c5 = { topic: n4, message: a5, publishedAt: Date.now(), transportType: M6.link_mode };
      this.relayer.onLinkMessageEvent(c5, { sessionExists: h6 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Ye.logger }), { logger: i4, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a5;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i4, this.name), this.heartbeat = new i(), this.crypto = new Ht4(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ai3(this, this.logger), this.expirer = new hi3(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Di3(Di3({}, Je3), e == null ? void 0 : e.storageOptions)), this.relayer = new ti3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi3(this, this.logger), this.verify = new ci3(this, this.logger, this.storage), this.echoClient = new li3(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi3(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _ne(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(lt3, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(fe5, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe5) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var bn3 = ne5;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events13 = __toESM(require_events());
var import_time8 = __toESM(require_cjs());
var be6 = "wc";
var Ce6 = 2;
var Le3 = "client";
var ye5 = `${be6}@${Ce6}:${Le3}:`;
var we6 = { name: Le3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var st6 = "proposal";
var it6 = "Proposal expired";
var rt5 = "session";
var z6 = import_time8.SEVEN_DAYS;
var nt4 = "engine";
var v6 = { wc_sessionPropose: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time8.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time8.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me6 = { min: import_time8.FIVE_MINUTES, max: import_time8.SEVEN_DAYS };
var x7 = { idle: "IDLE", active: "ACTIVE" };
var ot5 = "request";
var at5 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct4 = "wc";
var lt4 = "auth";
var pt5 = "authKeys";
var ht5 = "pairingTopics";
var dt4 = "requests";
var oe4 = `${ct4}@${1.5}:${lt4}:`;
var ae6 = `${oe4}:PUB_KEY`;
var ys3 = Object.defineProperty;
var ws2 = Object.defineProperties;
var ms2 = Object.getOwnPropertyDescriptors;
var ut5 = Object.getOwnPropertySymbols;
var _s3 = Object.prototype.hasOwnProperty;
var Es3 = Object.prototype.propertyIsEnumerable;
var gt6 = (q5, o4, e) => o4 in q5 ? ys3(q5, o4, { enumerable: true, configurable: true, writable: true, value: e }) : q5[o4] = e;
var I4 = (q5, o4) => {
  for (var e in o4 || (o4 = {}))
    _s3.call(o4, e) && gt6(q5, e, o4[e]);
  if (ut5)
    for (var e of ut5(o4))
      Es3.call(o4, e) && gt6(q5, e, o4[e]);
  return q5;
};
var D2 = (q5, o4) => ws2(q5, ms2(o4));
var Rs3 = class extends M4 {
  constructor(o4) {
    super(o4), this.name = nt4, this.events = new import_events13.default(), this.initialized = false, this.requestQueue = { state: x7.idle, queue: [] }, this.sessionRequestQueue = { state: x7.idle, queue: [] }, this.requestQueueDelay = import_time8.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v6) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D2(I4({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i4, optionalNamespaces: r3, sessionProperties: n4, relays: a5 } = t;
      let c5 = s2, h6, p4 = false;
      try {
        c5 && (p4 = this.client.core.pairing.pairings.get(c5).active);
      } catch (E4) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E4;
      }
      if (!c5 || !p4) {
        const { topic: E4, uri: S7 } = await this.client.core.pairing.create();
        c5 = E4, h6 = S7;
      }
      if (!c5) {
        const { message: E4 } = S3("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E4);
      }
      const d5 = await this.client.core.crypto.generateKeyPair(), l4 = v6.wc_sessionPropose.req.ttl || import_time8.FIVE_MINUTES, w5 = Mt3(l4), m = I4({ requiredNamespaces: i4, optionalNamespaces: r3, relays: a5 ?? [{ protocol: rt4 }], proposer: { publicKey: d5, metadata: this.client.metadata }, expiryTimestamp: w5, pairingTopic: c5 }, n4 && { sessionProperties: n4 }), { reject: y7, resolve: _4, done: R5 } = _t4(l4, it6);
      this.events.once(Lt3("session_connect"), async ({ error: E4, session: S7 }) => {
        if (E4)
          y7(E4);
        else if (S7) {
          S7.self.publicKey = d5;
          const M7 = D2(I4({}, S7), { pairingTopic: m.pairingTopic, requiredNamespaces: m.requiredNamespaces, optionalNamespaces: m.optionalNamespaces, transportType: M6.relay });
          await this.client.session.set(S7.topic, M7), await this.setExpiry(S7.topic, S7.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S7.peer.metadata }), this.cleanupDuplicatePairings(M7), _4(M7);
        }
      });
      const V7 = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m, throwOnFailedPublish: true });
      return await this.setProposal(V7, I4({ id: V7 }, m)), { uri: h6, approval: R5 };
    }, this.pair = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e) => {
      var t, s2, i4;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [Is2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N3) {
        throw r3.setError(Ts2.no_internet_connection), N3;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (N3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r3.setError(Ts2.proposal_not_found), N3;
      }
      try {
        await this.isValidApprove(e);
      } catch (N3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ts2.session_approve_namespace_validation_failure), N3;
      }
      const { id: n4, relayProtocol: a5, namespaces: c5, sessionProperties: h6, sessionConfig: p4 } = e, d5 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l4, proposer: w5, requiredNamespaces: m, optionalNamespaces: y7 } = d5;
      let _4 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l4 });
      _4 || (_4 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: Is2.session_approve_started, properties: { topic: l4, trace: [Is2.session_approve_started, Is2.session_namespaces_validation_success] } }));
      const R5 = await this.client.core.crypto.generateKeyPair(), V7 = w5.publicKey, E4 = await this.client.core.crypto.generateSharedKey(R5, V7), S7 = I4(I4({ relay: { protocol: a5 ?? "irn" }, namespaces: c5, controller: { publicKey: R5, metadata: this.client.metadata }, expiry: Mt3(z6) }, h6 && { sessionProperties: h6 }), p4 && { sessionConfig: p4 }), M7 = M6.relay;
      _4.addTrace(Is2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E4, { transportType: M7 });
      } catch (N3) {
        throw _4.setError(Ts2.subscribe_session_topic_failure), N3;
      }
      _4.addTrace(Is2.subscribe_session_topic_success);
      const W5 = D2(I4({}, S7), { topic: E4, requiredNamespaces: m, optionalNamespaces: y7, pairingTopic: l4, acknowledged: false, self: S7.controller, peer: { publicKey: w5.publicKey, metadata: w5.metadata }, controller: R5, transportType: M6.relay });
      await this.client.session.set(E4, W5), _4.addTrace(Is2.store_session);
      try {
        _4.addTrace(Is2.publishing_session_settle), await this.sendRequest({ topic: E4, method: "wc_sessionSettle", params: S7, throwOnFailedPublish: true }).catch((N3) => {
          throw _4 == null ? void 0 : _4.setError(Ts2.session_settle_publish_failure), N3;
        }), _4.addTrace(Is2.session_settle_publish_success), _4.addTrace(Is2.publishing_session_approve), await this.sendResult({ id: n4, topic: l4, result: { relay: { protocol: a5 ?? "irn" }, responderPublicKey: R5 }, throwOnFailedPublish: true }).catch((N3) => {
          throw _4 == null ? void 0 : _4.setError(Ts2.session_approve_publish_failure), N3;
        }), _4.addTrace(Is2.session_approve_publish_success);
      } catch (N3) {
        throw this.client.logger.error(N3), this.client.session.delete(E4, U3("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E4), N3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _4.eventId }), await this.client.core.pairing.updateMetadata({ topic: l4, metadata: w5.metadata }), await this.client.proposal.delete(n4, U3("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l4 }), await this.setExpiry(E4, Mt3(z6)), { topic: E4, acknowledged: () => Promise.resolve(this.client.session.get(E4)) };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e;
      let i4;
      try {
        i4 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i4 && (await this.sendError({ id: t, topic: i4, error: s2, rpcOpts: v6.wc_sessionPropose.reject }), await this.client.proposal.delete(t, U3("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (p4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p4;
      }
      const { topic: t, namespaces: s2 } = e, { done: i4, resolve: r3, reject: n4 } = _t4(), a5 = payloadId(), c5 = getBigIntRpcId().toString(), h6 = this.client.session.get(t).namespaces;
      return this.events.once(Lt3("session_update", a5), ({ error: p4 }) => {
        p4 ? n4(p4) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a5, relayRpcId: c5 }).catch((p4) => {
        this.client.logger.error(p4), this.client.session.update(t, { namespaces: h6 }), n4(p4);
      }), { acknowledged: i4 };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a5) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a5;
      }
      const { topic: t } = e, s2 = payloadId(), { done: i4, resolve: r3, reject: n4 } = _t4();
      return this.events.once(Lt3("session_extend", s2), ({ error: a5 }) => {
        a5 ? n4(a5) : r3();
      }), await this.setExpiry(t, Mt3(z6)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a5) => {
        n4(a5);
      }), { acknowledged: i4 };
    }, this.request = async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (w5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w5;
      }
      const { chainId: t, request: s2, topic: i4, expiry: r3 = v6.wc_sessionRequest.req.ttl } = e, n4 = this.client.session.get(i4);
      (n4 == null ? void 0 : n4.transportType) === M6.relay && await this.confirmOnlineStateOrThrow();
      const a5 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h6, resolve: p4, reject: d5 } = _t4(r3, "Request expired. Please try again.");
      this.events.once(Lt3("session_request", a5), ({ error: w5, result: m }) => {
        w5 ? d5(w5) : p4(m);
      });
      const l4 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l4 ? (await this.sendRequest({ clientRpcId: a5, relayRpcId: c5, topic: i4, method: "wc_sessionRequest", params: { request: D2(I4({}, s2), { expiryTimestamp: Mt3(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l4 }).catch((w5) => d5(w5)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t, id: a5 }), await h6()) : await Promise.all([new Promise(async (w5) => {
        await this.sendRequest({ clientRpcId: a5, relayRpcId: c5, topic: i4, method: "wc_sessionRequest", params: { request: D2(I4({}, s2), { expiryTimestamp: Mt3(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m) => d5(m)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t, id: a5 }), w5();
      }), new Promise(async (w5) => {
        var m;
        if (!((m = n4.sessionConfig) != null && m.disableDeepLink)) {
          const y7 = await qt3(this.client.core.storage, xe2);
          await Ft4({ id: a5, topic: i4, wcDeepLink: y7 });
        }
        w5();
      }), h6()]).then((w5) => w5[2]);
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s2 } = e, { id: i4 } = s2, r3 = this.client.session.get(t);
      r3.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i4, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i4, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i4 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a5 } = _t4();
        this.events.once(Lt3("session_ping", s2), ({ error: c5 }) => {
          c5 ? a5(c5) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i4 }), r3()]);
      } else
        this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s2, chainId: i4 } = e, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t))
        await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: U3("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t))
        await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = S3("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => zr4(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i4 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i4 ? M6.link_mode : M6.relay;
      r3 === M6.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a5 = "", uri: c5, domain: h6, nonce: p4, type: d5, exp: l4, nbf: w5, methods: m = [], expiry: y7 } = e, _4 = [...e.resources || []], { topic: R5, uri: V7 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R5, uri: V7 } });
      const E4 = await this.client.core.crypto.generateKeyPair(), S7 = hr3(E4);
      if (await Promise.all([this.client.auth.authKeys.set(ae6, { responseTopic: S7, publicKey: E4 }), this.client.auth.pairingTopics.set(S7, { topic: S7, pairingTopic: R5 })]), await this.client.core.relayer.subscribe(S7, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R5}`), m.length > 0) {
        const { namespace: O5 } = re3(n4[0]);
        let T4 = ir4(O5, "request", m);
        Y2(_4) && (T4 = cr4(T4, _4.pop())), _4.push(T4);
      }
      const M7 = y7 && y7 > v6.wc_sessionAuthenticate.req.ttl ? y7 : v6.wc_sessionAuthenticate.req.ttl, W5 = { authPayload: { type: d5 ?? "caip122", chains: n4, statement: a5, aud: c5, domain: h6, version: "1", nonce: p4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l4, nbf: w5, resources: _4 }, requester: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: Mt3(M7) }, N3 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m])], events: ["chainChanged", "accountsChanged"] } }, De4 = { requiredNamespaces: {}, optionalNamespaces: N3, relays: [{ protocol: "irn" }], pairingTopic: R5, proposer: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: Mt3(v6.wc_sessionPropose.req.ttl) }, { done: wt5, resolve: Ve2, reject: Ee6 } = _t4(M7, "Request expired"), ce5 = async ({ error: O5, session: T4 }) => {
        if (this.events.off(Lt3("session_request", G3), Re2), O5)
          Ee6(O5);
        else if (T4) {
          T4.self.publicKey = E4, await this.client.session.set(T4.topic, T4), await this.setExpiry(T4.topic, T4.expiry), R5 && await this.client.core.pairing.updateMetadata({ topic: R5, metadata: T4.peer.metadata });
          const le3 = this.client.session.get(T4.topic);
          await this.deleteProposal(Z6), Ve2({ session: le3 });
        }
      }, Re2 = async (O5) => {
        var T4, le3, Me;
        if (await this.deletePendingAuthRequest(G3, { message: "fulfilled", code: 0 }), O5.error) {
          const te5 = U3("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O5.error.code === te5.code ? void 0 : (this.events.off(Lt3("session_connect"), ce5), Ee6(O5.error.message));
        }
        await this.deleteProposal(Z6), this.events.off(Lt3("session_connect"), ce5);
        const { cacaos: ke2, responder: j4 } = O5.result, Ie5 = [], $e2 = [];
        for (const te5 of ke2) {
          await nr4({ cacao: te5, projectId: this.client.core.projectId }) || (this.client.logger.error(te5, "Signature verification failed"), Ee6(U3("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe6 } = te5, ve5 = Y2(fe6.resources), Ke4 = [ln3(fe6.iss)], mt5 = fe4(fe6.iss);
          if (ve5) {
            const qe2 = ar4(ve5), _t6 = ur3(ve5);
            Ie5.push(...qe2), Ke4.push(..._t6);
          }
          for (const qe2 of Ke4)
            $e2.push(`${qe2}:${mt5}`);
        }
        const ee6 = await this.client.core.crypto.generateSharedKey(E4, j4.publicKey);
        let pe3;
        Ie5.length > 0 && (pe3 = { topic: ee6, acknowledged: true, self: { publicKey: E4, metadata: this.client.metadata }, peer: j4, controller: j4.publicKey, expiry: Mt3(z6), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R5, namespaces: Jr3([...new Set(Ie5)], [...new Set($e2)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee6, { transportType: r3 }), await this.client.session.set(ee6, pe3), R5 && await this.client.core.pairing.updateMetadata({ topic: R5, metadata: j4.metadata }), pe3 = this.client.session.get(ee6)), (T4 = this.client.metadata.redirect) != null && T4.linkMode && (le3 = j4.metadata.redirect) != null && le3.linkMode && (Me = j4.metadata.redirect) != null && Me.universal && t && (this.client.core.addLinkModeSupportedApp(j4.metadata.redirect.universal), this.client.session.update(ee6, { transportType: M6.link_mode })), Ve2({ auths: ke2, session: pe3 });
      }, G3 = payloadId(), Z6 = payloadId();
      this.events.once(Lt3("session_connect"), ce5), this.events.once(Lt3("session_request", G3), Re2);
      let Se3;
      try {
        if (i4) {
          const O5 = formatJsonRpcRequest("wc_sessionAuthenticate", W5, G3);
          this.client.core.history.set(R5, O5);
          const T4 = await this.client.core.crypto.encode("", O5, { type: M5, encoding: lr3 });
          Se3 = xr3(t, R5, T4);
        } else
          await Promise.all([this.sendRequest({ topic: R5, method: "wc_sessionAuthenticate", params: W5, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: G3 }), this.sendRequest({ topic: R5, method: "wc_sessionPropose", params: De4, expiry: v6.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z6 })]);
      } catch (O5) {
        throw this.events.off(Lt3("session_connect"), ce5), this.events.off(Lt3("session_request", G3), Re2), O5;
      }
      return await this.setProposal(Z6, I4({ id: Z6 }, De4)), await this.setAuthRequest(G3, { request: D2(I4({}, W5), { verifyContext: {} }), pairingTopic: R5, transportType: r3 }), { uri: Se3 ?? V7, response: wt5 };
    }, this.approveSessionAuthenticate = async (e) => {
      const { id: t, auths: s2 } = e, i4 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Cs2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y7) {
        throw i4.setError(Ps2.no_internet_connection), y7;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3)
        throw i4.setError(Ps2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || M6.relay;
      n4 === M6.relay && await this.confirmOnlineStateOrThrow();
      const a5 = r3.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h6 = hr3(a5), p4 = { type: D, receiverPublicKey: a5, senderPublicKey: c5 }, d5 = [], l4 = [];
      for (const y7 of s2) {
        if (!await nr4({ cacao: y7, projectId: this.client.core.projectId })) {
          i4.setError(Ps2.invalid_cacao);
          const S7 = U3("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h6, error: S7, encodeOpts: p4 }), new Error(S7.message);
        }
        i4.addTrace(Cs2.cacaos_verified);
        const { p: _4 } = y7, R5 = Y2(_4.resources), V7 = [ln3(_4.iss)], E4 = fe4(_4.iss);
        if (R5) {
          const S7 = ar4(R5), M7 = ur3(R5);
          d5.push(...S7), V7.push(...M7);
        }
        for (const S7 of V7)
          l4.push(`${S7}:${E4}`);
      }
      const w5 = await this.client.core.crypto.generateSharedKey(c5, a5);
      i4.addTrace(Cs2.create_authenticated_session_topic);
      let m;
      if ((d5 == null ? void 0 : d5.length) > 0) {
        m = { topic: w5, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a5, metadata: r3.requester.metadata }, controller: a5, expiry: Mt3(z6), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: Jr3([...new Set(d5)], [...new Set(l4)]), transportType: n4 }, i4.addTrace(Cs2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w5, { transportType: n4 });
        } catch (y7) {
          throw i4.setError(Ps2.subscribe_authenticated_session_topic_failure), y7;
        }
        i4.addTrace(Cs2.subscribe_authenticated_session_topic_success), await this.client.session.set(w5, m), i4.addTrace(Cs2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i4.addTrace(Cs2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h6, id: t, result: { cacaos: s2, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y7) {
        throw i4.setError(Ps2.authenticated_session_approve_publish_failure), y7;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: m };
    }, this.rejectSessionAuthenticate = async (e) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e, i4 = this.getPendingAuthRequest(t);
      if (!i4)
        throw new Error(`Could not find pending auth request with id ${t}`);
      i4.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i4.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a5 = hr3(r3), c5 = { type: D, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a5, error: s2, encodeOpts: c5, rpcOpts: v6.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, U3("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e;
      return dn3(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0)
          for (; this.relayMessageCache.length > 0; )
            try {
              const e = this.relayMessageCache.shift();
              e && await this.onRelayMessage(e);
            } catch (e) {
              this.client.logger.error(e);
            }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic)
        try {
          const t = this.client.core.pairing.pairings.get(e.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i4) => {
            var r3, n4;
            return ((r3 = i4.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i4.peerMetadata) == null ? void 0 : n4.url) === e.peer.metadata.url && i4.topic && i4.topic !== t.topic;
          });
          if (s2.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (t) {
          this.client.logger.error(t);
        }
    }, this.deleteSession = async (e) => {
      var t;
      const { topic: s2, expirerHasDeleted: i4 = false, emitEvent: r3 = true, id: n4 = 0 } = e, { self: a5 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, U3("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a5.publicKey) && await this.client.core.crypto.deleteKeyPair(a5.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i4 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe2).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s2 && this.deletePendingSessionRequest(c5.id, U3("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x7.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e, t) => {
      if (t)
        try {
          const s2 = this.client.proposal.get(e), i4 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
          i4 == null ? void 0 : i4.setError(Ts2.proposal_expired);
        } catch {
        }
      await Promise.all([this.client.proposal.delete(e, U3("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }, this.deletePendingSessionRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== e), s2 && (this.sessionRequestQueue.state = x7.idle, this.client.events.emit("session_request_expire", { id: e }));
    }, this.deletePendingAuthRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }, this.setProposal = async (e, t) => {
      this.client.core.expirer.set(e, Mt3(v6.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }, this.setAuthRequest = async (e, t) => {
      const { request: s2, pairingTopic: i4, transportType: r3 = M6.relay } = t;
      this.client.core.expirer.set(e, s2.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e, pairingTopic: i4, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e) => {
      const { id: t, topic: s2, params: i4, verifyContext: r3 } = e, n4 = i4.request.expiryTimestamp || Mt3(v6.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i4, verifyContext: r3 });
    }, this.sendRequest = async (e) => {
      const { topic: t, method: s2, params: i4, expiry: r3, relayRpcId: n4, clientRpcId: a5, throwOnFailedPublish: c5, appLink: h6 } = e, p4 = formatJsonRpcRequest(s2, i4, a5);
      let d5;
      const l4 = !!h6;
      try {
        const y7 = l4 ? lr3 : ge2;
        d5 = await this.client.core.crypto.encode(t, p4, { encoding: y7 });
      } catch (y7) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y7;
      }
      let w5;
      if (at5.includes(s2)) {
        const y7 = yr4(JSON.stringify(p4)), _4 = yr4(d5);
        w5 = await this.client.core.verify.register({ id: _4, decryptedId: y7 });
      }
      const m = v6[s2].req;
      if (m.attestation = w5, r3 && (m.ttl = r3), n4 && (m.id = n4), this.client.core.history.set(t, p4), l4) {
        const y7 = xr3(h6, t, d5);
        await global.Linking.openURL(y7, this.client.name);
      } else {
        const y7 = v6[s2].req;
        r3 && (y7.ttl = r3), n4 && (y7.id = n4), c5 ? (y7.internal = D2(I4({}, y7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d5, y7)) : this.client.core.relayer.publish(t, d5, y7).catch((_4) => this.client.logger.error(_4));
      }
      return p4.id;
    }, this.sendResult = async (e) => {
      const { id: t, topic: s2, result: i4, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a5 } = e, c5 = formatJsonRpcResult(t, i4);
      let h6;
      const p4 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p4 ? lr3 : ge2;
        h6 = await this.client.core.crypto.encode(s2, c5, D2(I4({}, n4 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d5;
      try {
        d5 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p4) {
        const l4 = xr3(a5, s2, h6);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = v6[d5.request.method].res;
        r3 ? (l4.internal = D2(I4({}, l4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h6, l4)) : this.client.core.relayer.publish(s2, h6, l4).catch((w5) => this.client.logger.error(w5));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e) => {
      const { id: t, topic: s2, error: i4, encodeOpts: r3, rpcOpts: n4, appLink: a5 } = e, c5 = formatJsonRpcError(t, i4);
      let h6;
      const p4 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p4 ? lr3 : ge2;
        h6 = await this.client.core.crypto.encode(s2, c5, D2(I4({}, r3 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d5;
      try {
        d5 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p4) {
        const l4 = xr3(a5, s2, h6);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = n4 || v6[d5.request.method].res;
        this.client.core.relayer.publish(s2, h6, l4);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i4 = false;
        Kt3(s2.expiry) && (i4 = true), this.client.core.crypto.keychain.has(s2.topic) || (i4 = true), i4 && e.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        Kt3(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x7.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x7.active;
        const e = this.requestQueue.queue.shift();
        if (e)
          try {
            await this.processRequest(e);
          } catch (t) {
            this.client.logger.warn(t);
          }
      }
      this.requestQueue.state = x7.idle;
    }, this.processRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i4, transportType: r3, encryptedId: n4 } = e, a5 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a5 }))
        switch (a5) {
          case "wc_sessionPropose":
            return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4 });
          case "wc_sessionSettle":
            return await this.onSessionSettleRequest(t, s2);
          case "wc_sessionUpdate":
            return await this.onSessionUpdateRequest(t, s2);
          case "wc_sessionExtend":
            return await this.onSessionExtendRequest(t, s2);
          case "wc_sessionPing":
            return await this.onSessionPingRequest(t, s2);
          case "wc_sessionDelete":
            return await this.onSessionDeleteRequest(t, s2);
          case "wc_sessionRequest":
            return await this.onSessionRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4, transportType: r3 });
          case "wc_sessionEvent":
            return await this.onSessionEventRequest(t, s2);
          case "wc_sessionAuthenticate":
            return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4, transportType: r3 });
          default:
            return this.client.logger.info(`Unsupported request method ${a5}`);
        }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: t, payload: s2, transportType: i4 } = e, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: t } = e, { message: s2 } = S3("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e) => {
      const { topic: t, requestMethod: s2 } = e, i4 = this.expectedPairingMethodMap.get(t);
      return !i4 || i4.includes(s2) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i4, encryptedId: r3 } = e, { params: n4, id: a5 } = s2;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I4({}, s2.params));
        const h6 = n4.expiryTimestamp || Mt3(v6.wc_sessionPropose.req.ttl), p4 = I4({ id: a5, pairingTopic: t, expiryTimestamp: h6 }, n4);
        await this.setProposal(a5, p4);
        const d5 = await this.getVerifyContext({ attestationId: i4, hash: yr4(JSON.stringify(s2)), encryptedId: r3, metadata: p4.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5 == null ? void 0 : c5.setError($4.proposal_listener_not_found)), c5 == null ? void 0 : c5.addTrace(z5.emit_session_proposal), this.client.events.emit("session_proposal", { id: a5, params: p4, verifyContext: d5 });
      } catch (c5) {
        await this.sendError({ id: a5, topic: t, error: c5, rpcOpts: v6.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e, t, s2) => {
      const { id: i4 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a5 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a5 });
        const c5 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h6 = await this.client.core.crypto.generateSharedKey(a5, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h6 });
        const p4 = await this.client.core.relayer.subscribe(h6, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p4 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i4, U3("USER_DISCONNECTED"));
        const r3 = Lt3("session_connect");
        if (this.events.listenerCount(r3) === 0)
          throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Lt3("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e, t) => {
      const { id: s2, params: i4 } = t;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: r3, controller: n4, expiry: a5, namespaces: c5, sessionProperties: h6, sessionConfig: p4 } = t.params, d5 = D2(I4(I4({ topic: e, relay: r3, expiry: a5, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h6 && { sessionProperties: h6 }), p4 && { sessionConfig: p4 }), { transportType: M6.relay }), l4 = Lt3("session_connect");
        if (this.events.listenerCount(l4) === 0)
          throw new Error(`emitting ${l4} without any listeners 997`);
        this.events.emit(Lt3("session_connect"), { session: d5 }), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(Lt3("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, U3("USER_DISCONNECTED")), this.events.emit(Lt3("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e, t) => {
      const { params: s2, id: i4 } = t;
      try {
        const r3 = `${e}_session_update`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i4)) {
          this.client.logger.info(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: e, error: U3("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I4({ topic: e }, s2));
        try {
          yo.set(r3, i4), await this.client.session.update(e, { namespaces: s2.namespaces }), await this.sendResult({ id: i4, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a5) {
          throw yo.delete(r3), a5;
        }
        this.client.events.emit("session_update", { id: i4, topic: e, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i4, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt3("session_update", s2);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Mt3(z6)), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e, error: i4 }), this.client.logger.error(i4);
      }
    }, this.onSessionExtendResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt3("session_extend", s2);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e, error: i4 }), this.client.logger.error(i4);
      }
    }, this.onSessionPingResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt3("session_ping", s2);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Lt3("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(v5.publish, async () => {
            i4(await this.deleteSession({ topic: e, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: U3("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }, this.onSessionRequest = async (e) => {
      var t, s2, i4;
      const { topic: r3, payload: n4, attestation: a5, encryptedId: c5, transportType: h6 } = e, { id: p4, params: d5 } = n4;
      try {
        await this.isValidRequest(I4({ topic: r3 }, d5));
        const l4 = this.client.session.get(r3), w5 = await this.getVerifyContext({ attestationId: a5, hash: yr4(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d5, p4))), encryptedId: c5, metadata: l4.peer.metadata, transportType: h6 }), m = { id: p4, topic: r3, params: d5, verifyContext: w5 };
        await this.setPendingSessionRequest(m), h6 === M6.link_mode && (t = l4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l4.peer.metadata.redirect) == null ? void 0 : s2.universal), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());
      } catch (l4) {
        await this.sendError({ id: p4, topic: r3, error: l4 }), this.client.logger.error(l4);
      }
    }, this.onSessionRequestResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt3("session_request", s2);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt3("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e, t) => {
      const { id: s2, params: i4 } = t;
      try {
        const r3 = `${e}_session_event_${i4.event.name}`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I4({ topic: e }, i4)), this.client.events.emit("session_event", { id: s2, topic: e, params: i4 }), yo.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(Lt3("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt3("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e) => {
      var t;
      const { topic: s2, payload: i4, attestation: r3, encryptedId: n4, transportType: a5 } = e;
      try {
        const { requester: c5, authPayload: h6, expiryTimestamp: p4 } = i4.params, d5 = await this.getVerifyContext({ attestationId: r3, hash: yr4(JSON.stringify(i4)), encryptedId: n4, metadata: c5.metadata, transportType: a5 }), l4 = { requester: c5, pairingTopic: s2, id: i4.id, authPayload: h6, verifyContext: d5, expiryTimestamp: p4 };
        await this.setAuthRequest(i4.id, { request: l4, pairingTopic: s2, transportType: a5 }), a5 === M6.link_mode && (t = c5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i4.params, id: i4.id, verifyContext: d5 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h6 = i4.params.requester.publicKey, p4 = await this.client.core.crypto.generateKeyPair(), d5 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a5), l4 = { type: D, receiverPublicKey: h6, senderPublicKey: p4 };
        await this.sendError({ id: i4.id, topic: s2, error: c5, encodeOpts: l4, rpcOpts: v6.wc_sessionAuthenticate.autoReject, appLink: d5 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x7.idle, this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i4) => i4.topic === e && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const r3 = i4.request.id, n4 = Lt3("session_request", r3);
        if (this.events.listenerCount(n4) === 0)
          throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Lt3("session_request", i4.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x7.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x7.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onPairingCreated = (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active)
        return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e) => {
      if (!to(e)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a5);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i4, sessionProperties: r3, relays: n4 } = e;
      if (I2(t) || await this.isValidPairingTopic(t), !eo(n4, true)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a5);
      }
      !I2(s2) && Z3(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !I2(i4) && Z3(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), I2(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e, t) => {
      const s2 = Xr2(e, "connect()", t);
      if (s2)
        throw new Error(s2.message);
    }, this.isValidApprove = async (e) => {
      if (!to(e))
        throw new Error(S3("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s2, relayProtocol: i4, sessionProperties: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a5 = Wn2(s2, "approve()");
      if (a5)
        throw new Error(a5.message);
      const c5 = zn2(n4.requiredNamespaces, s2, "approve()");
      if (c5)
        throw new Error(c5.message);
      if (!b2(i4, true)) {
        const { message: h6 } = S3("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h6);
      }
      I2(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!to(e)) {
        const { message: i4 } = S3("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i4);
      }
      const { id: t, reason: s2 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !ro2(s2)) {
        const { message: i4 } = S3("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i4);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!to(e)) {
        const { message: c5 } = S3("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c5);
      }
      const { relay: t, controller: s2, namespaces: i4, expiry: r3 } = e;
      if (!Jn2(t)) {
        const { message: c5 } = S3("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n4 = Zr3(s2, "onSessionSettleRequest()");
      if (n4)
        throw new Error(n4.message);
      const a5 = Wn2(i4, "onSessionSettleRequest()");
      if (a5)
        throw new Error(a5.message);
      if (Kt3(r3)) {
        const { message: c5 } = S3("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e) => {
      if (!to(e)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, namespaces: s2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i4 = this.client.session.get(t), r3 = Wn2(s2, "update()");
      if (r3)
        throw new Error(r3.message);
      const n4 = zn2(i4.requiredNamespaces, s2, "update()");
      if (n4)
        throw new Error(n4.message);
    }, this.isValidExtend = async (e) => {
      if (!to(e)) {
        const { message: s2 } = S3("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e) => {
      if (!to(e)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, request: s2, chainId: i4, expiry: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!co2(n4, i4)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a5);
      }
      if (!oo(s2)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a5);
      }
      if (!ao2(n4, i4, s2.method)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a5);
      }
      if (r3 && !po2(r3, me6)) {
        const { message: a5 } = S3("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me6.min} and ${me6.max}`);
        throw new Error(a5);
      }
    }, this.isValidRespond = async (e) => {
      var t;
      if (!to(e)) {
        const { message: r3 } = S3("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i4 } = e;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r3;
      }
      if (!so(i4)) {
        const { message: r3 } = S3("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e) => {
      if (!to(e)) {
        const { message: s2 } = S3("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e) => {
      if (!to(e)) {
        const { message: n4 } = S3("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i4 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!co2(r3, i4)) {
        const { message: n4 } = S3("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(n4);
      }
      if (!io(s2)) {
        const { message: n4 } = S3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!uo2(r3, i4, s2.name)) {
        const { message: n4 } = S3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!to(e)) {
        const { message: s2 } = S3("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e) => {
      const { chains: t, uri: s2, domain: i4, nonce: r3 } = e;
      if (!Array.isArray(t) || t.length === 0)
        throw new Error("chains is required and must be a non-empty array");
      if (!b2(s2, false))
        throw new Error("uri is required parameter");
      if (!b2(i4, false))
        throw new Error("domain is required parameter");
      if (!b2(r3, false))
        throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a5) => re3(a5).namespace))].length > 1)
        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = re3(t[0]);
      if (n4 !== "eip155")
        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e) => {
      const { attestationId: t, hash: s2, encryptedId: i4, metadata: r3, transportType: n4 } = e, a5 = { verified: { verifyUrl: r3.verifyUrl || J3, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === M6.link_mode) {
          const h6 = this.getAppLinkIfEnabled(r3, n4);
          return a5.verified.validation = h6 && new URL(h6).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a5;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i4, verifyUrl: r3.verifyUrl });
        c5 && (a5.verified.origin = c5.origin, a5.verified.isScam = c5.isScam, a5.verified.validation = c5.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a5)}`), a5;
    }, this.validateSessionProps = (e, t) => {
      Object.values(e).forEach((s2) => {
        if (!b2(s2, false)) {
          const { message: i4 } = S3("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i4);
        }
      });
    }, this.getPendingAuthRequest = (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i4)
            break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s2 } = S3("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e, t) => {
      var s2, i4, r3, n4, a5, c5, h6, p4, d5;
      return !e || t !== M6.link_mode ? false : ((i4 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i4.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c5 = (a5 = this.client.metadata) == null ? void 0 : a5.redirect) == null ? void 0 : c5.universal) !== "" && ((h6 = e == null ? void 0 : e.redirect) == null ? void 0 : h6.universal) !== void 0 && ((p4 = e == null ? void 0 : e.redirect) == null ? void 0 : p4.universal) !== "" && ((d5 = e == null ? void 0 : e.redirect) == null ? void 0 : d5.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e, t) => {
      var s2;
      return this.isLinkModeEnabled(e, t) ? (s2 = e == null ? void 0 : e.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic"))
        return;
      const t = Bt4(e, "topic") || "", s2 = decodeURIComponent(Bt4(e, "wc_ev") || ""), i4 = this.client.session.keys.includes(t);
      i4 && this.client.session.update(t, { transportType: M6.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i4 });
    }, this.registerLinkModeListeners = async () => {
      var e;
      if (Wt4() || _2() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = S3("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v5.message, (o4) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o4) : this.onRelayMessage(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: e, message: t, attestation: s2, transportType: i4 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae6) ? this.client.auth.authKeys.get(ae6) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r3, encoding: i4 === M6.link_mode ? lr3 : ge2 });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e, n4), this.onRelayEventRequest({ topic: e, payload: n4, attestation: s2, transportType: i4, encryptedId: yr4(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e, payload: n4, transportType: i4 }), this.client.core.history.delete(e, n4.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: n4, transportType: i4 });
    } catch (a5) {
      this.client.logger.error(a5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S5.expired, async (o4) => {
      const { topic: e, id: t } = Vt3(o4.target);
      if (t && this.client.pendingRequest.keys.includes(t))
        return await this.deletePendingSessionRequest(t, S3("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t))
        return await this.deletePendingAuthRequest(t, S3("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V5.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(V5.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!b2(o4, false)) {
      const { message: e } = S3("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: e } = S3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: e } = S3("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(o4) {
    if (!b2(o4, false)) {
      const { message: e } = S3("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: e } = S3("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: e } = S3("EXPIRED", `session topic: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: e } = S3("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4))
      await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4))
      this.isValidPairingTopic(o4);
    else if (b2(o4, false)) {
      const { message: e } = S3("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    } else {
      const { message: e } = S3("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(o4) {
    if (!no2(o4)) {
      const { message: e } = S3("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: e } = S3("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: e } = S3("EXPIRED", `proposal id: ${o4}`);
      throw new Error(e);
    }
  }
};
var Ss4 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, st6, ye5), this.core = o4, this.logger = e;
  }
};
var yt5 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, rt5, ye5), this.core = o4, this.logger = e;
  }
};
var Is3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, ot5, ye5, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var fs2 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, pt5, oe4, () => ae6), this.core = o4, this.logger = e;
  }
};
var vs3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, ht5, oe4), this.core = o4, this.logger = e;
  }
};
var qs4 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, dt4, oe4, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var Ts3 = class {
  constructor(o4, e) {
    this.core = o4, this.logger = e, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs3(this.core, this.logger), this.requests = new qs4(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e5 = class __e extends S2 {
  constructor(o4) {
    super(o4), this.protocol = be6, this.version = Ce6, this.name = we6.name, this.events = new import_events13.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o4 == null ? void 0 : o4.name) || we6.name, this.metadata = (o4 == null ? void 0 : o4.metadata) || Nt4(), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const e = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino.default)(k({ level: (o4 == null ? void 0 : o4.logger) || we6.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new bn3(o4), this.logger = E(e, this.name), this.session = new yt5(this.core, this.logger), this.proposal = new Ss4(this.core, this.logger), this.pendingRequest = new Is3(this.core, this.logger), this.engine = new Rs3(this), this.auth = new Ts3(this.core, this.logger);
  }
  static async init(o4) {
    const e = new __e(o4);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};
var Ns3 = yt5;
var Ps3 = _e5;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l3 = { exports: {} };
var c4 = typeof Reflect == "object" ? Reflect : null;
var y6 = c4 && typeof c4.apply == "function" ? c4.apply : function(t, e, n4) {
  return Function.prototype.apply.call(t, e, n4);
};
var f4;
c4 && typeof c4.ownKeys == "function" ? f4 = c4.ownKeys : Object.getOwnPropertySymbols ? f4 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f4 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function k3(s2) {
  console && console.warn && console.warn(s2);
}
var w4 = Number.isNaN || function(t) {
  return t !== t;
};
function o3() {
  o3.init.call(this);
}
l3.exports = o3, l3.exports.once = K4, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
var L3 = 10;
function g5(s2) {
  if (typeof s2 != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s2);
}
Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
  return L3;
}, set: function(s2) {
  if (typeof s2 != "number" || s2 < 0 || w4(s2))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s2 + ".");
  L3 = s2;
} }), o3.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o3.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w4(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _3(s2) {
  return s2._maxListeners === void 0 ? o3.defaultMaxListeners : s2._maxListeners;
}
o3.prototype.getMaxListeners = function() {
  return _3(this);
}, o3.prototype.emit = function(t) {
  for (var e = [], n4 = 1; n4 < arguments.length; n4++)
    e.push(arguments[n4]);
  var i4 = t === "error", a5 = this._events;
  if (a5 !== void 0)
    i4 = i4 && a5.error === void 0;
  else if (!i4)
    return false;
  if (i4) {
    var r3;
    if (e.length > 0 && (r3 = e[0]), r3 instanceof Error)
      throw r3;
    var h6 = new Error("Unhandled error." + (r3 ? " (" + r3.message + ")" : ""));
    throw h6.context = r3, h6;
  }
  var u4 = a5[t];
  if (u4 === void 0)
    return false;
  if (typeof u4 == "function")
    y6(u4, this, e);
  else
    for (var d5 = u4.length, M7 = O4(u4, d5), n4 = 0; n4 < d5; ++n4)
      y6(M7[n4], this, e);
  return true;
};
function S6(s2, t, e, n4) {
  var i4, a5, r3;
  if (g5(e), a5 = s2._events, a5 === void 0 ? (a5 = s2._events = /* @__PURE__ */ Object.create(null), s2._eventsCount = 0) : (a5.newListener !== void 0 && (s2.emit("newListener", t, e.listener ? e.listener : e), a5 = s2._events), r3 = a5[t]), r3 === void 0)
    r3 = a5[t] = e, ++s2._eventsCount;
  else if (typeof r3 == "function" ? r3 = a5[t] = n4 ? [e, r3] : [r3, e] : n4 ? r3.unshift(e) : r3.push(e), i4 = _3(s2), i4 > 0 && r3.length > i4 && !r3.warned) {
    r3.warned = true;
    var h6 = new Error("Possible EventEmitter memory leak detected. " + r3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h6.name = "MaxListenersExceededWarning", h6.emitter = s2, h6.type = t, h6.count = r3.length, k3(h6);
  }
  return s2;
}
o3.prototype.addListener = function(t, e) {
  return S6(this, t, e, false);
}, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(t, e) {
  return S6(this, t, e, true);
};
function D3() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C6(s2, t, e) {
  var n4 = { fired: false, wrapFn: void 0, target: s2, type: t, listener: e }, i4 = D3.bind(n4);
  return i4.listener = e, n4.wrapFn = i4, i4;
}
o3.prototype.once = function(t, e) {
  return g5(e), this.on(t, C6(this, t, e)), this;
}, o3.prototype.prependOnceListener = function(t, e) {
  return g5(e), this.prependListener(t, C6(this, t, e)), this;
}, o3.prototype.removeListener = function(t, e) {
  var n4, i4, a5, r3, h6;
  if (g5(e), i4 = this._events, i4 === void 0)
    return this;
  if (n4 = i4[t], n4 === void 0)
    return this;
  if (n4 === e || n4.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i4[t], i4.removeListener && this.emit("removeListener", t, n4.listener || e));
  else if (typeof n4 != "function") {
    for (a5 = -1, r3 = n4.length - 1; r3 >= 0; r3--)
      if (n4[r3] === e || n4[r3].listener === e) {
        h6 = n4[r3].listener, a5 = r3;
        break;
      }
    if (a5 < 0)
      return this;
    a5 === 0 ? n4.shift() : F6(n4, a5), n4.length === 1 && (i4[t] = n4[0]), i4.removeListener !== void 0 && this.emit("removeListener", t, h6 || e);
  }
  return this;
}, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(t) {
  var e, n4, i4;
  if (n4 = this._events, n4 === void 0)
    return this;
  if (n4.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n4[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[t]), this;
  if (arguments.length === 0) {
    var a5 = Object.keys(n4), r3;
    for (i4 = 0; i4 < a5.length; ++i4)
      r3 = a5[i4], r3 !== "removeListener" && this.removeAllListeners(r3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n4[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i4 = e.length - 1; i4 >= 0; i4--)
      this.removeListener(t, e[i4]);
  return this;
};
function b5(s2, t, e) {
  var n4 = s2._events;
  if (n4 === void 0)
    return [];
  var i4 = n4[t];
  return i4 === void 0 ? [] : typeof i4 == "function" ? e ? [i4.listener || i4] : [i4] : e ? z7(i4) : O4(i4, i4.length);
}
o3.prototype.listeners = function(t) {
  return b5(this, t, true);
}, o3.prototype.rawListeners = function(t) {
  return b5(this, t, false);
}, o3.listenerCount = function(s2, t) {
  return typeof s2.listenerCount == "function" ? s2.listenerCount(t) : E3.call(s2, t);
}, o3.prototype.listenerCount = E3;
function E3(s2) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s2];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f4(this._events) : [];
};
function O4(s2, t) {
  for (var e = new Array(t), n4 = 0; n4 < t; ++n4)
    e[n4] = s2[n4];
  return e;
}
function F6(s2, t) {
  for (; t + 1 < s2.length; t++)
    s2[t] = s2[t + 1];
  s2.pop();
}
function z7(s2) {
  for (var t = new Array(s2.length), e = 0; e < t.length; ++e)
    t[e] = s2[e].listener || s2[e];
  return t;
}
function K4(s2, t) {
  return new Promise(function(e, n4) {
    function i4(r3) {
      s2.removeListener(t, a5), n4(r3);
    }
    function a5() {
      typeof s2.removeListener == "function" && s2.removeListener("error", i4), e([].slice.call(arguments));
    }
    R4(s2, t, a5, { once: true }), t !== "error" && U5(s2, i4, { once: true });
  });
}
function U5(s2, t, e) {
  typeof s2.on == "function" && R4(s2, "error", t, e);
}
function R4(s2, t, e, n4) {
  if (typeof s2.on == "function")
    n4.once ? s2.once(t, e) : s2.on(t, e);
  else if (typeof s2.addEventListener == "function")
    s2.addEventListener(t, function i4(a5) {
      n4.once && s2.removeEventListener(t, i4), e(a5);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s2);
}
var A4 = "wc";
var p3 = "Web3Wallet";
var $6 = `${A4}@2:${p3}:`;
var Q4 = class extends l3.exports {
  constructor() {
    super();
  }
};
var x8 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P3 = class {
  constructor(t) {
    this.client = t;
  }
};
var V6 = Object.defineProperty;
var B5 = Object.defineProperties;
var J4 = Object.getOwnPropertyDescriptors;
var q4 = Object.getOwnPropertySymbols;
var Y3 = Object.prototype.hasOwnProperty;
var Z5 = Object.prototype.propertyIsEnumerable;
var j3 = (s2, t, e) => t in s2 ? V6(s2, t, { enumerable: true, configurable: true, writable: true, value: e }) : s2[t] = e;
var ee5 = (s2, t) => {
  for (var e in t || (t = {}))
    Y3.call(t, e) && j3(s2, e, t[e]);
  if (q4)
    for (var e of q4(t))
      Z5.call(t, e) && j3(s2, e, t[e]);
  return s2;
};
var te4 = (s2, t) => B5(s2, J4(t));
var se4 = class extends P3 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps3.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr3.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n4, acknowledged: i4 } = await this.signClient.approve(te4(ee5({}, e), { id: e.id, namespaces: e.namespaces, sessionProperties: e.sessionProperties, sessionConfig: e.sessionConfig }));
      return await i4(), this.signClient.session.get(n4);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await this.signClient.update(e), this.extendSession = async (e) => await this.signClient.extend(e), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n4) => (e[n4.topic] = n4, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n4) => await this.authClient.respond(e, n4), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n4) => this.authClient.formatMessage(e, n4), this.approveSessionAuthenticate = async (e) => await this.signClient.approveSessionAuthenticate(e), this.rejectSessionAuthenticate = async (e) => await this.signClient.rejectSessionAuthenticate(e), this.formatAuthMessage = (e) => this.signClient.formatAuthMessage(e), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.on = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "on"), this.client.events.on(e, n4)), this.once = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "once"), this.client.events.once(e, n4)), this.off = (e, n4) => (this.setEvent(e, "off"), this.client.events.off(e, n4)), this.removeListener = (e, n4) => (this.setEvent(e, "removeListener"), this.client.events.removeListener(e, n4)), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.onSessionRequestAuthenticate = (e) => {
      this.client.events.emit("session_authenticate", e);
    }, this.setEvent = (e, n4) => {
      switch (e) {
        case "session_request":
          this.signClient.events[n4]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[n4]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[n4]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[n4]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[n4]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[n4]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[n4]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
};
var ne6 = { decryptMessage: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(s2.topic, s2.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }), sessionStore: null };
  t.sessionStore = new Ns3(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(s2.topic), n4 = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, n4;
} };
var T3 = class extends x8 {
  constructor(s2) {
    super(s2), this.events = new l3.exports(), this.on = (t, e) => this.engine.on(t, e), this.once = (t, e) => this.engine.once(t, e), this.off = (t, e) => this.engine.off(t, e), this.removeListener = (t, e) => this.engine.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = s2.metadata, this.name = s2.name || p3, this.signConfig = s2.signConfig, this.core = s2.core, this.logger = this.core.logger, this.engine = new se4(this);
  }
  static async init(s2) {
    const t = new T3(s2);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (s2) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(s2.message), s2;
    }
  }
};
var v7 = T3;
v7.notifications = ne6;
var ie4 = v7;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-fbb7ab15.browser.esm.js
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-a72d5b10.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId,
      ...getAnalyticsHeaders()
    },
    body: JSON.stringify(body)
  });
}
var AbstractClientWallet = class extends AbstractWallet {
  /**
   * @internal
   */
  /**
   * @internal
   */
  getMeta() {
    return this.constructor.meta;
  }
  /**
   * Creates an returns instance of `AbstractClientWallet`
   *
   * @param walletId - A Unique identifier for the wallet ( name of the wallet )
   * @param options - Options for creating wallet instance
   */
  constructor(walletId, options) {
    super();
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c5) => updateChainRPCs(c5, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * Returns the Wallet Connector used by the wallet
   */
  /**
   * auto-connect the wallet if possible
   * @returns
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return this._connect(true, options);
  }
  /**
   * Connect wallet
   * @param connectOptions - Options for connecting to the wallet
   * @returns
   */
  async connect(connectOptions) {
    this._connectParams = connectOptions;
    const address = await this._connect(false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  /**
   * @internal
   * Get the options used for connecting to the wallet
   * @returns
   */
  getConnectParams() {
    return this._connectParams;
  }
  /**
   * @internal
   * Get the options used for creating the wallet instance
   */
  getOptions() {
    return this.options;
  }
  async _connect(isAutoConnect, connectOptions) {
    const connector = await this.getConnector();
    this._subscribeToEvents(connector);
    const isConnected = await connector.isConnected();
    if (isConnected) {
      const address = await connector.getAddress();
      connector.setupListeners();
      if (connectOptions == null ? void 0 : connectOptions.chainId) {
        await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
      }
      this.emit("connect", {
        address,
        chainId: await this.getChainId()
      });
      this._trackConnection(address);
      return address;
    }
    if (isAutoConnect) {
      throw new Error("Failed to auto connect to the wallet.");
    }
    try {
      const address = await connector.connect(connectOptions);
      this._trackConnection(address);
      return address;
    } catch (error) {
      throw new Error(error.message);
    }
  }
  _trackConnection(address) {
    var _a;
    track({
      clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
      source: "connectWallet",
      action: "connect",
      walletType: this.walletId,
      walletAddress: address
    });
  }
  async _subscribeToEvents(connector) {
    connector.on("connect", (data) => {
      var _a;
      this.emit("connect", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("change", (data) => {
      var _a;
      this.emit("change", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("message", (data) => {
      this.emit("message", data);
    });
    connector.on("disconnect", async () => {
      this.emit("disconnect");
    });
    connector.on("error", (error) => this.emit("error", error));
  }
  /**
   * Get [ethers Signer](https://docs.ethers.org/v5/api/signer/) object of the connected wallet
   */
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  /**
   * Switch to different Network/Blockchain in the connected wallet
   * @param chainId - The chainId of the network to switch to
   */
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  /**
   * Update the chains supported by the wallet. This is useful if wallet was initialized with some chains and this needs to be updated without re-initializing the wallet
   */
  async updateChains(chains) {
    this.chains = chains.map((c5) => {
      var _a;
      return updateChainRPCs(c5, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses another "personal wallet" under the hood, return it
   *
   * This is only useful for wallets like Safe or Smart Wallet uses a "personal wallet" under the hood to sign transactions. This method returns that wallet
   */
  getPersonalWallet() {
    return void 0;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  /**
   * Create a `BloctoWallet` instance
   * @param options - The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### appId (recommended)
   * To get advanced features and support from Blocto, you can create an appId from [blocto dashboard](https://docs.blocto.app/blocto-sdk/register-app-id)
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { BloctoWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new BloctoWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### chain (optional)
   * The Network to connect the wallet to. Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  /**
   * @internal
   */
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-IPPKC72U.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
var EmbeddedWallet = class _EmbeddedWallet extends AbstractClientWallet {
  /**
   * Sends a verification email to the provided email address.
   *
   * @param email - The email address to which the verification email will be sent.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * EmbeddedWallet.sendVerificationEmail({ email: 'test@example.com', clientId: 'yourClientId' })
   *   .then(() => console.log('Verification email sent successfully.'))
   *   .catch(error => console.error('Failed to send verification email:', error));
   * ```
   */
  static async sendVerificationEmail(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  /**
   * Sends a verification sms to the provider phone number.
   *
   * @param phoneNumber - The phone number to which the verification sms will be sent. The phone number must contain the country code.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  phoneNumber: '+1234567890',
   *  clientId: 'yourClientId'
   * });
   * ```
   */
  static async sendVerificationSms(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationSms({
      phoneNumber: options.phoneNumber
    });
  }
  /**
   * @internal
   */
  get walletName() {
    return "Embedded Wallet";
  }
  /**
   * @internal
   */
  /**
   * The options for instantiating an `EmbeddedWallet`
   *
   * @param options -
   * The options object contains the following properties:
   *
   * ### clientId (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### chain (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-XDKCB5EP.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a = this.options) == null ? void 0 : _a.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_b = this.options) == null ? void 0 : _b.onAuthSuccess
      });
    }
    return this.connector;
  }
  /**
   * auto connect the wallet if the wallet was previously connected and session is still valid
   */
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  /**
   * @internal
   */
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  /**
   * Get the email associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getEmail();
   * ```
   */
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  /**
   * Get the phone number associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getPhoneNumber();
   * ```
   */
  async getPhoneNumber() {
    const connector = await this.getConnector();
    return connector.getPhoneNumber();
  }
  /**
   * Get the instance of `EmbeddedWalletSdk` used by the wallet.
   */
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  // TODO move to connect/auth callback
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  /**
   * Send a verification code to the user's email for verification.
   * Use this as a prestep before calling `authenticate` with the `email_verification` strategy.
   *
   * ```javascript
   * const result = await wallet.sendVerificationEmail({
   *   email: "alice@example.com",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  email: "alice@example.com",
   * })
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### email (required)
   * The email address to send verification email to.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   *
   */
  async sendVerificationEmail(options) {
    const {
      email
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  /**
   * Send a verification code to the user's phone number for verification. The phone number must contain the country code.
   * Use this as a pre-step before calling `authenticate` with the `phone_number_verification` strategy.
   *
   * ```js
   * const result = await wallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### phoneNumber (required)
   * The phone number to send verification SMS to. The phone number must contain the country code.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   */
  async sendVerificationSms(options) {
    const {
      phoneNumber
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationSms({
      phoneNumber
    });
  }
  /**
   * Authenticate the user with any of the available auth strategies.
   *
   * @example
   * ```javascript
   * const authResult = await wallet.authenticate({
   *   strategy: "google",
   * });
   * ```
   *
   * @param params -
   * Choose one of the available auth strategy, which comes with different required arguments.
   * ```ts
   * // email verification
   * type EmailVerificationAuthParams = {
   *   strategy: "email_verification";
   *   email: string;
   *   verificationCode: string;
   *   recoveryCode?: string;
   * };
   *
   * export type EmbeddedWalletOauthStrategy = "google" | "apple" | "facebook";
   *
   * type OauthAuthParams = {
   *   strategy: EmbeddedWalletOauthStrategy;
   *   openedWindow?: Window;
   *   closeOpenedWindow?: (window: Window) => void;
   * };
   *
   * // bring your own authentication
   * type JwtAuthParams = {
   *   strategy: "jwt";
   *   jwt: string;
   *   encryptionKey?: string;
   * };
   *
   * // open iframe to send and input the verification code only
   * type IframeOtpAuthParams = {
   *   strategy: "iframe_email_verification";
   *   email: string;
   * };
   *
   * // open iframe to enter email and verification code
   * type IframeAuthParams = {
   *   strategy: "iframe";
   * };
   * ```
   *
   * @returns
   * The `authResult` object - which you can pass to the `connect` method to connect to the wallet.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   * await wallet.connect({ authResult });
   * ```
   */
  async authenticate(params) {
    const connector = await this.getConnector();
    const authResult = connector.authenticate(params);
    try {
      await this.walletStorage.setItem(LAST_USED_AUTH_STRATEGY, params.strategy);
    } catch {
    }
    return authResult;
  }
  /**
   * @internal
   */
  async getLastUsedAuthStrategy() {
    try {
      return await this.walletStorage.getItem(LAST_USED_AUTH_STRATEGY);
    } catch {
      return null;
    }
  }
  /**
   * After authenticating, you can connect to the wallet by passing the `authResult` to the `connect` method.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   *
   * await wallet.connect({ authResult });
   * ```
   *
   * @param connectOptions - The `connectOptions` object contains the following properties:
   *
   * ### authResult (required)
   *
   * The `authResult` object is returned from the `authenticate` method.
   *
   * @returns The address of the connected wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});
var LAST_USED_AUTH_STRATEGY = "lastUsedAuthStrategy";

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "MetaMask";
  }
  /**
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   * Provide clientId to use the thirdweb RPCs for given chains
   * You can create a client ID for your application from thirdweb dashboard.
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to MetaMask mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to `defaultChains` ( `import { defaultChains } from "@thirdweb-dev/chains"` )
   *
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MetaMaskWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new MetaMaskWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal for connecting to MetaMask on mobile if MetaMask is not injected.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * options to customize the Wallet Connect QR Code Modal ( only relevant when qrcode is true )
   */
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-KGPRVG2N.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the MetaMask wallet using a QR code if the user does not have the Metamask extension installed.
   *
   * You can use this method to display a QR code. User can scan the QR code from the MetaMask mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, MetaMask will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * MetaMask extension on desktop supports switching accounts.
   * This method will trigger the MetaMask extension to show the account switcher Modal
   */
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_lib3();
var OKXWallet = class _OKXWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OKX";
  }
  /**
   * Create instance of `OKXWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-MHE32DHD.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OKX Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
init_lib3();
var CoreWallet = class _CoreWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Core wallet";
  }
  /**
   * Create instance of `CoreWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-FGK4MLNE.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Core Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.browser.esm.js
init_lib3();
var OneKeyWallet = class _OneKeyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OneKey wallet";
  }
  /**
   * Create instance of `OneKeyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OneKeyWallet.id, options);
    this.isInjected = !!getInjectedOneKeyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OneKeyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-onekey.browser.esm-4QEQCJZF.js");
        this.OneKeyConnector = new OneKeyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OneKeyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OneKey Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OneKeyWallet, "id", walletIds.oneKey);

// node_modules/@thirdweb-dev/wallets/evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.browser.esm.js
init_lib3();
var CryptoDefiWallet = class _CryptoDefiWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Crypto Defi wallet";
  }
  /**
   * Create instance of `CryptoDefiWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CryptoDefiWallet.id, options);
    this.isInjected = !!getInjectedCryptoDefiWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CryptoDefiWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-crypto-defi-wallet.browser.esm-62FZSXAW.js");
        this.CryptoDefiWalletConnector = new CryptoDefiWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CryptoDefiWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Defi Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CryptoDefiWallet, "id", walletIds.cryptoDefiWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.browser.esm.js
init_lib3();
var RabbyWallet = class _RabbyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Rabby wallet";
  }
  /**
   * Create instance of `RabbyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_RabbyWallet.id, options);
    this.isInjected = !!getInjectedRabbyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RabbyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rabby.browser.esm-24QZJOQ6.js");
        this.RabbyConnector = new RabbyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.RabbyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Rabby Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RabbyWallet, "id", walletIds.rabby);

// node_modules/@thirdweb-dev/wallets/evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.browser.esm.js
init_lib3();
var Coin98Wallet = class _Coin98Wallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coin98 wallet";
  }
  /**
   * Create instance of `Coin98Wallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_Coin98Wallet.id, options);
    this.isInjected = !!getInjectedCoin98Provider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          Coin98Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-coin98.browser.esm-RCM6AUVB.js");
        this.Coin98Connector = new Coin98Connector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.Coin98Connector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Coin98 Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(Coin98Wallet, "id", walletIds.coin98);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-b24ac791.browser.esm.js
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/dist/engine-09701abe.browser.esm.js
init_lib3();
var EngineSigner = class _EngineSigner extends ethers_exports.Signer {
  constructor(config, provider) {
    super();
    this.config = {
      ...config,
      engineUrl: config.engineUrl.replace(/\/$/, "")
    };
    ethers_exports.utils.defineReadOnly(this, "provider", provider || null);
  }
  async getAddress() {
    return this.config.backendWalletAddress;
  }
  async signMessage(message) {
    const res = await this.fetch({
      path: "/backend-wallet/sign-message",
      method: "POST",
      body: {
        message
      }
    });
    return res.result;
  }
  async signTransaction(transaction) {
    var _a, _b, _c, _d, _e6, _f;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: "/backend-wallet/sign-transaction",
      method: "POST",
      body: {
        ...tx,
        nonce: (_a = tx.nonce) == null ? void 0 : _a.toString(),
        gasLimit: (_b = tx.gasLimit) == null ? void 0 : _b.toString(),
        gasPrice: (_c = tx.gasPrice) == null ? void 0 : _c.toString(),
        value: (_d = tx.value) == null ? void 0 : _d.toString(),
        maxPriorityFeePerGas: (_e6 = tx.maxPriorityFeePerGas) == null ? void 0 : _e6.toString(),
        maxFeePerGas: (_f = tx.maxFeePerGas) == null ? void 0 : _f.toString()
      }
    });
    return res.result;
  }
  async sendTransaction(transaction) {
    if (!this.provider) {
      throw new Error("Sending transactions requires a provider!");
    }
    const chainId = (await this.provider.getNetwork()).chainId;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: `/backend-wallet/${chainId}/send-transaction`,
      method: "POST",
      body: {
        toAddress: tx.to,
        data: tx.data,
        value: tx.value || "0"
      }
    });
    const queueId = res.result.queueId;
    return {
      hash: queueId,
      confirmations: 0,
      from: this.config.backendWalletAddress,
      nonce: 0,
      gasLimit: BigNumber.from(0),
      value: BigNumber.from(0),
      data: "",
      chainId,
      wait: async (confirmations) => {
        if (!this.provider) {
          throw new Error("Sending transactions requires a provider!");
        }
        while (true) {
          const {
            result: txRes
          } = await this.fetch({
            path: `/transaction/status/${queueId}`,
            method: "GET"
          });
          switch (txRes.status) {
            case "errored":
              throw new Error(`Transaction errored with reason: ${txRes.errorMessage}`);
            case "cancelled":
              throw new Error(`Transaction execution cancelled.`);
            case "mined":
              const receipt = await this.provider.getTransactionReceipt(txRes.transactionHash);
              return receipt;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
    };
  }
  connect(provider) {
    return new _EngineSigner(this.config, provider);
  }
  async fetch(_ref) {
    let {
      path,
      method,
      body
    } = _ref;
    const res = await fetch(`${this.config.engineUrl}${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.accessToken}`,
        "x-backend-wallet-address": this.config.backendWalletAddress
      },
      ...body ? {
        body: JSON.stringify(body)
      } : {}
    });
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res.json();
  }
};
var EngineWallet = class extends AbstractWallet {
  constructor(config) {
    super();
    this._signer = new EngineSigner(config);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a;
    super(_PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-KIMECZQU.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
var import_buffer = __toESM(require_buffer2());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coinbase Wallet";
  }
  /**
   * @internal
   */
  /**
   * @internal
   */
  /**
   *
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { CoinbaseWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new CoinbaseWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   * ### headlessMode (optional)
   * This is only relevant applies when coinbase extension wallet is NOT installed on user's browser.
   *
   * By default `headlessMode` is set to `false` - which means that when user does not have coinbase wallet extension installed, a QR Code scan modal will open when calling the `connect` method to allow the user to connect to their coinbase mobile app by scanning the QR code.
   *
   * If headlessMode is set to `true` and coinbase wallet extension is not installed, the wallet will NOT open a QR Code scan modal - This is useful if you want to create a custom QR Code modal.
   *
   * you can use the `getQrUrl` method to get the QR Code url and create your own QR Code Modal
   *
   * Must be a `boolean`.
   */
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-SJRWSUKE.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  /**
   * Get the QR Code url to render a custom QR Code Modal for connecting to Coinbase Wallet.
   *
   * This method is only relevant when coinbase extension wallet is NOT installed on user's browser and `headlessMode` is set to `true`.
   *
   * @example
   * ```ts
   * const wallet = new CoinbaseWallet({ headlessMode: true });
   *
   * const qrUrl = await wallet.getQrUrl();
   * // render a QR Code Modal with the qrUrl
   *
   * const walletAddress = await wallet.connect(); // this is resolved when user scans the QR Code and wallet is connected
   *
   * console.log('connected to', walletAddress);
   * ```
   *
   * @returns
   */
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_lib3();
var EthersWallet = class extends AbstractWallet {
  /**
   * Create instance of `EthersWallet`
   * @param signer - ethers.js signer object
   */
  constructor(signer) {
    super();
    this._signer = signer;
  }
  /**
   * Returns [ethers signer](https://docs.ethers.org/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Frame Wallet";
  }
  /**
   * Create a `FrameWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { FrameWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new FrameWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-EBTRNKS6.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/imtoken/dist/thirdweb-dev-wallets-evm-wallets-imtoken.browser.esm.js
init_lib3();
var ImTokenWallet = class _ImTokenWallet extends AbstractClientWallet {
  get walletName() {
    return "imToken";
  }
  constructor(options) {
    var _a;
    super(_ImTokenWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isImToken);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ImTokenConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-imtoken.browser.esm-4GAR4RUH.js");
        const imtokenConnector = new ImTokenConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.imtokenConnector = imtokenConnector;
        this.connector = new WagmiAdapter(imtokenConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ImTokenWallet, "meta", {
  name: "imToken",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMl80NzgzKSI+CjxtYXNrIGlkPSJtYXNrMF8yMjJfNDc4MyIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCI+CjxwYXRoIGQ9Ik03OS44OTQ4IDBIMC4wNTA3ODEyVjgwSDc5Ljg5NDhWMFoiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF8yMjJfNDc4MykiPgo8cGF0aCBkPSJNNjIuMDI3NSAwSDE4LjA1MDlDOC4xNDYzOSAwIDAuMTE3MTg4IDguMDQ0ODggMC4xMTcxODggMTcuOTY4OFY2Mi4wMzEyQzAuMTE3MTg4IDcxLjk1NTEgOC4xNDYzOSA4MCAxOC4wNTA5IDgwSDYyLjAyNzVDNzEuOTMyIDgwIDc5Ljk2MTIgNzEuOTU1MSA3OS45NjEyIDYyLjAzMTJWMTcuOTY4OEM3OS45NjEyIDguMDQ0ODggNzEuOTMyIDAgNjIuMDI3NSAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIyMl80NzgzKSIvPgo8cGF0aCBkPSJNNjUuMDk4MSAyNC43MzNDNjYuNzU4NiA0Ny4yNjY3IDUyLjMwMjEgNTcuOTE3MiAzOS4zNDIzIDU5LjA1M0MyNy4yOTM1IDYwLjEwODcgMTUuOTUyIDUyLjY5MDggMTQuOTU3MSA0MS4yOTM2QzE0LjEzNjMgMzEuODc3NiAxOS45NDQ1IDI3Ljg2ODkgMjQuNTA4IDI3LjQ2OTRDMjkuMjAxNSAyNy4wNTcgMzMuMTQ1OCAzMC4zMDAxIDMzLjQ4NzkgMzQuMjI2OUMzMy44MTc1IDM4LjAwMiAzMS40NjY0IDM5LjcyMDUgMjkuODMxMyAzOS44NjM0QzI4LjUzODIgMzkuOTc3IDI2LjkxMTQgMzkuMTkwNSAyNi43NjQ1IDM3LjUwMTZDMjYuNjM4NSAzNi4wNTAzIDI3LjE4ODUgMzUuODUyNiAyNy4wNTQxIDM0LjMxMDlDMjYuODE0OSAzMS41NjYyIDI0LjQyNjEgMzEuMjQ2NiAyMy4xMTgzIDMxLjM2MDFDMjEuNTM1NyAzMS40OTkxIDE4LjY2NDEgMzMuMzQ5OCAxOS4wNjcgMzcuOTZDMTkuNDcyMiA0Mi42MTAxIDIzLjkyMjIgNDYuMjg0NSAyOS43NTU3IDQ1Ljc3MzRDMzYuMDUwOSA0NS4yMjIzIDQwLjQzMzcgNDAuMzExNCA0MC43NjM0IDMzLjQyMzRDNDAuNzYwMyAzMy4wNTg2IDQwLjgzNyAzMi42OTc1IDQwLjk4OCAzMi4zNjU1TDQwLjk5IDMyLjM1NzJDNDEuMDU3OCAzMi4yMTI4IDQxLjEzNzIgMzIuMDc0MiA0MS4yMjcyIDMxLjk0MjhDNDEuMzYxNiAzMS43NDA5IDQxLjUzMzggMzEuNTE4IDQxLjc1NjIgMzEuMjczOUM0MS43NTgzIDMxLjI2NzYgNDEuNzU4MyAzMS4yNjc2IDQxLjc2MjYgMzEuMjY3NkM0MS45MjQxIDMxLjA4NDcgNDIuMTE5NCAzMC44ODcgNDIuMzM5NyAzMC42NzQ1QzQ1LjA4OTcgMjguMDc1IDU0Ljk5MzEgMjEuOTQ0MiA2NC4zNTkyIDIzLjg4NTVDNjQuNTU3MyAyMy45MjggNjQuNzM2MSAyNC4wMzM0IDY0Ljg2OTMgMjQuMTg2MkM2NS4wMDI1IDI0LjMzOTEgNjUuMDgyNiAyNC41MzA4IDY1LjA5ODEgMjQuNzMzWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzQ3ODMiIHgxPSI3My41MDA5IiB5MT0iNS4zMTI1IiB4Mj0iMi44NzI0MSIgeTI9Ijc3LjY3NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzExQzREMSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDYyQUQiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMjJfNDc4MyI+CjxyZWN0IHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4=",
  urls: {
    ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940",
    android: "https://play.google.com/store/apps/details?id=im.token.app"
  }
});
_defineProperty(ImTokenWallet, "id", walletIds.imtoken);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-OOIVPGTQ.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Local Wallet";
  }
  /**
   * Initialize the `LocalWallet` with the given `options`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId or secretKey (recommended)
   * Provide `clientId` or `secretKey` to use the thirdweb RPCs for given `chains`
   *
   * If you are using the `LocalWallet` in a in frontend - provide a `clientId`, If you are using the `LocalWallet` in backend - you can provide a `secretKey`.
   *
   * You can create a `clientId` / `secretKey` from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chain (optional)
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   * Defaults to `Ethereum`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### storage (optional)
   * This is the default storage for storing the private key, mnemonic or encrypted JSON. This can be implemented in any way you want, as long as it conforms to the `AsyncStorage` interface:
   *
   * If omitted, defaults to browser local storage.
   *
   *
   * ```javascript
   * import { LocalWallet } from "@thirdweb-dev/wallets";
   *
   * const customStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * };
   *
   * const walletWithOptions = new LocalWallet({
   *   storage: customStorage,
   * });
   * ```
   *
   */
  constructor(options) {
    super(_LocalWallet.id, options);
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-OJHRCJWR.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c5) => updateChainRPCs(c5, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * Load the saved wallet data from storage, if it exists, or generate a new one and save it.
   *
   * @example
   * ```js
   * wallet.loadOrCreate({
   *   strategy: "encryptedJson",
   *   password: password,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOrCreateOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Load the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Load the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the saved private key is encrypted.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * Creates a new random wallet and returns the wallet address.
   *
   * @example
   * ```ts
   * const address = await wallet.generate();
   * ```
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * Create local wallet by importing a private key, mnemonic or encrypted JSON.
   * @example
   * ```javascript
   * const address = await localWallet.import({
   *   privateKey: "...",
   *   encryption: false,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletImportOptions` which can have either `privateKey`, `mnemonic` or `encryptedJson` as a property.
   * They all can be encrypted or un-encrypted. If encrypted, the `encryption` property must be provided with `password` property to decrypt the data.
   *
   * ### privateKey
   * The Private Key of the wallet.
   *
   * ### mnemonic
   * The mnemonic (seed phrase) of the wallet.
   *
   * ### encryptedJson
   * The encrypted JSON of the wallet.
   *
   * ### encryption
   * This is only required if the given `privateKey`, `mnemonic` or `encryptedJson` is encrypted.
   * The `encryption` object of type `DecryptOptions` can be provided to decrypt the data. It is an object with the following properties:
   *
   * #### password
   * The password to decrypt the data.
   *
   * #### decrypt
   * A custom decrypt function that takes the encrypted data and password as arguments and returns the decrypted data.
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * Initialize the wallet from saved data on storage
   *
   * ```js
   * await wallet.load({
   *   strategy: "encryptedJson",
   *   password: "your-password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOptions` which contains a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Initialize the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Initialize the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the private key is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Initialize the wallet from a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the mnemonic. This is only required if the mnemonic is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   *
   * @example
   * ```javascript
   * wallet.save({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletSaveOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Save the wallet data as encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Save the wallet data as a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the private key. This is only required if you want to encrypt the private key.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Save the wallet data as a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the mnemonic. This is only required if you want to encrypt the mnemonic.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await this._saveData({
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await this._saveData({
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await this._saveData({
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * Check if the wallet data is saved in storage.
   *
   * @returns `true` if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  /**
   * Delete the saved wallet from storage. This action is irreversible, use with caution.
   *
   * @example
   * ```ts
   * await wallet.deleteSaved();
   * ```
   */
  async deleteSaved() {
    await this._storage.removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * Encrypts the wallet with a password in various formats and return it.
   *
   * @example
   * ```javascript
   * const data = await wallet.export({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletExportOptions`. It takes a `strategy` and other properties depending on the strategy.
   *
   * ### strategy - "encryptedJson"
   * Export wallet in encryptedJson format. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   *
   * ### strategy - "privateKey"
   * Encrypt the private key of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the private key. It takes a `password` property to encrypt the private key and an optional `encrypt` function to encrypt the private key. If `encrypt` function is not provided, it uses the default encryption.
   *
   * ### strategy - "mnemonic"
   * Encrypt the mnemonic (seed phrase) of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the mnemonic. It takes a `password` property to encrypt the mnemonic and an optional `encrypt` function to encrypt the mnemonic. If `encrypt` function is not provided, it uses the default encryption.
   *
   * @returns Promise that resolves to a `string` that contains encrypted wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   * @param storage - storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @example
   * ```javascript
   * const someStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * }
   *
   * wallet.getSaved(someStorage);
   * ```
   *
   * @returns `Promise` which resolves to a `WalletData` object containing the wallet data. It returns `null` if no wallet data is found in storage.
   * ```ts
   * {
   *     address: string;
   *     strategy: "mnemonic" | "privateKey" | "encryptedJson";
   *     data: string;
   *     isEncrypted: boolean;
   * }
   * ```
   */
  async getSavedData(storage) {
    const _storage = storage || this._storage;
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  /**
   * store the wallet data to storage
   */
  async _saveData(data, storage) {
    const _storage = storage || this._storage;
    await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function noop(msg) {
  return msg;
}
function getDecryptor(encryption) {
  return encryption ? (msg) => (
    // we're using aesDecryptCompat here because we want to support legacy crypto-js ciphertext for the moment
    (encryption.decrypt || aesDecryptCompat)(msg, encryption.password)
  ) : noop;
}
function getEncryptor(encryption) {
  return encryption ? (msg) => (encryption.encrypt || aesEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_lib3();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-JAATQHB4.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c5) => updateChainRPCs(c5, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Link";
  }
  /**
   * @internal
   */
  /**
   * Create an instance of the `MagicLink` wallet
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### apiKey (required)
   * Your Magic Link apiKey. You can get an API key by signing up for an account on [Magic Link's website](https://magic.link/).
   *
   * Must be a `string`.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### type (optional)
   * Whether to use [Magic Auth](https://magic.link/docs/auth/overview) or [Magic Connect](https://magic.link/docs/connect/overview) to connect to the wallet.
   *
   * Default is `"auth"`.
   *
   * ```ts
   * type: "auth" | "connect";
   * ```
   *
   * ### magicSdkConfiguration (optional)
   * Configuration for [Magic Auth](https://magic.link/docs/auth/overview) SDK.
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * ```ts
   * {
   *   locale?: string;
   *   endpoint?: string;
   *   testMode?: boolean;
   * }
   * ```
   *
   * * locale (optional) - Customize the language of Magic's modal, email and confirmation screen. See [Localization](https://magic.link/docs/auth/more/customization/localization) for more.
   *
   * * endpoint (optional) - A URL pointing to the Magic iframe application.
   *
   * * testMode (optional) - Enable [testMode](https://magic.link/docs/auth/introduction/test-mode) to assert the desired behavior through the email address so that you don't have to go through the auth flow.
   *
   *
   * ### smsLogin
   * Specify whether you want to allow users to log in with their phone number or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   * ### emailLogin (optional)
   * Specify whether you want to allow users to log in with their email or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   *
   * ### oauthOptions (optional)
   * Specify which oauth providers you support in `providers` array. This is only relevant if you are using `type: 'auth'`.
   *
   * Specify which URI to redirect to after the oauth flow is complete in `redirectURI` option. If no `redirectURI` is specified, the user will be redirected to the current page.
   *
   * You must pass full URL and not just a relative path. For example, `"https://example.com/foo"` is valid but `"/foo"` is not.
   * You can use `new URL("/foo", window.location.origin).href` to get the full URL from a relative path based on the current origin.
   *
   * You also need to enable the oauth providers for your apiKey from [Magic dashboard](https://dashboard.magic.link/).
   *
   * ```ts
   * type OauthOptions = {
   *   redirectURI?: string;
   *   providers: OauthProvider[];
   * };
   *
   * type OauthProvider =
   *   | "google"
   *   | "facebook"
   *   | "apple"
   *   | "github"
   *   | "bitbucket"
   *   | "gitlab"
   *   | "linkedin"
   *   | "twitter"
   *   | "discord"
   *   | "twitch"
   *   | "microsoft";
   * ```
   *
   * ```ts
   * const wallet = new MagicLink({
   *   apiKey: "YOUR_API_KEY",
   *   type: "auth",
   *   // specify which Oauth providers to enable
   *   oauthOptions: {
   *     redirectURI: new URL("/foo", window.location.origin).href,
   *     providers: ["google", "facebook", "github", "bitbucket"],
   *   },
   * });
   * ```
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   */
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  /**
   * @internal
   */
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-RY6SBKHC.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  /**
   * Get Magic Auth SDK instance. Learn more about [Magic Auth SDK](https://magic.link/docs/auth/overview)
   *
   * you use all methods available in the Magic Auth SDK from the SDK instance. Refer to [Magic Auth API](https://magic.link/docs/auth/api-reference/client-side-sdks/web) for more details.
   *
   * ```javascript
   * const magicSDK = await wallet.getMagic();
   * ```
   */
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  /**
   * Auto connect wallet if the user is already logged in.
   * @returns
   */
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  /**
   * Disconnect wallet
   */
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  /**
   * Connect Wallet using Magic Auth or Magic Connect
   *
   * ### Magic Auth
   * There are three ways to call the `connect` function - `email` or `phoneNumber` or `oauthProvider`
   *
   * #### email
   * This opens the Magic Link's Modal and prompts the user to click on the link sent to their email.
   *
   * ```ts
   * await wallet.connect({
   *   email: "user@example.com",
   * });
   * ```
   *
   * #### phoneNumber
   * This opens the Magic Link's Modal and prompts the user to enter the OTP sent to their phone via SMS.
   *
   * ```ts
   * await wallet.connect({
   *   phoneNumber: "+123456789",
   * });
   * ```
   *
   * #### oauthProvider
   * This redirects the user to given provider's sign-in page and once the user is authenticated, it redirects the user back to the `redirectURI` provided in `MagicLink` constructor.
   *
   * ```ts
   * await magic.connect({
   *   oauthProvider: "google",
   * });
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * ### Magic Connect
   * You can call the `connect` function without any arguments. Calling `connect` opens the Magic Link's Modal and prompts the user to login via Google or email.
   *
   * ```ts
   * await wallet.connect();
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * @param options - The `options` object can include the following properties:
   * ### Magic Auth
   * If you are using `type: 'auth'`, you can pass any one of the following properties
   * - `email` - The email address of the user
   * - `phoneNumber` - The phone number of the user
   * - `oauthProvider` - The oauth provider to use for login
   *
   * ### Magic Connect
   * If you are using `type: 'connect'`, you don't need to pass any arguments to `connect` function.
   *
   * @returns
   */
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.browser.esm.js
init_lib3();
var XDEFIWallet = class _XDEFIWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "XDEFI";
  }
  /**
   * Create instance of `XDEFIWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { XDEFIWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new XDEFIWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_XDEFIWallet.id, options);
    this.isInjected = !!getInjectedXDEFIProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        XDEFIConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-xdefi.browser.esm-N6XOC4VC.js");
      const connector = new XDEFIConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(XDEFIWallet, "id", walletIds.xdefi);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Phantom";
  }
  /**
   * Create a `PhantomWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { PhantomWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new PhantomWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-RWXFK6AW.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_lib3();
var PrivateKeyWallet = class extends AbstractWallet {
  /**
   * Create instance of `PrivateKeyWallet`
   *
   * @param privateKey - The private key to use for signing transactions.
   *
   * @param chain - The chain or rpc url to connect to when querying the blockchain directly through this wallet.
   *
   * @param secretKey -
   * Provide `secretKey` to use the thirdweb RPCs for given `chain`
   *
   * You can create a secret key from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   */
  constructor(privateKey, chain, secretKey) {
    super();
    this._signer = new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0);
  }
  /**
   * Get the [ethers.js signer](https://docs.ethers.io/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-W7RXJ7VD.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_lib3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Safe Wallet";
  }
  /**
   * Create a `SafeWallet` instance.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SafeWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new SafeWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   }
   * });
   * ```
   *
   */
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-D2QFKNYE.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Safe wallet.
   * @returns
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Auto connect the wallet if it was previously connected.
   */
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect Safe wallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * @example
   * ```javascript
   * import { CoinbaseWallet, SafeWallet } from "@thirdweb-dev/wallets";
   * import { Ethereum } from "@thirdweb-dev/chains";
   *
   * // First, connect the personal wallet
   * const personalWallet = new CoinbaseWallet();
   * await personalWallet.connect();
   *
   * // Then, connect the Safe wallet
   * const wallet = new SafeWallet();
   * await wallet.connect({
   *   personalWallet: personalWallet, // Wallet that can sign transactions on the Safe
   *   chain: Ethereum, // Chain that the Safe is on
   *   safeAddress: "{{contract_address}}", // Smart contract address of the Safe
   * });
   * ```
   *
   * ### personalWallet
   *
   * The instance of a personal wallet that can sign transactions on the Safe.
   *
   * Must be of type `EVMWallet` such as [`CoinbaseWallet`](/wallet/coinbase-wallet) or [`MetamaskWallet`](/wallet/metamask).
   *
   * ### chain
   *
   * The chain that the Safe smart contract is deployed to.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### safeAddress
   *
   * Smart contract address of the Safe wallet.
   *
   * Must be a `string`.
   *
   * @returns A Promise that resolves to the Safe address.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
init_lib3();
var import_contracts = __toESM(require_dist());
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Smart Wallet";
  }
  /**
   *
   * @param options - The `options` object includes the following properties:
   * ### Required Properties
   *
   * #### chain
   * The chain that the Smart Wallet contract is deployed to.
   *
   * Either a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package, a chain name, or an RPC URL.
   *
   *
   * #### factoryAddress
   * The address of the Smart Wallet Factory contract.
   *
   * Must be a `string`.
   *
   *
   * #### gasless
   * Whether to turn on or off gasless transactions.
   *
   * - If set to `true`, all gas fees will be paid by a paymaster.
   * - If set to `false`, all gas fees will be paid by the Smart Wallet itself (needs to be funded).
   *
   * Must be a `boolean`.
   *
   *
   * ### Optional properties
   *
   * #### clientId or secretKey (recommended)
   * Your API key can be obtained from the [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * If you're using your own bundler and paymaster, you can set this to an empty string.
   *
   * You can use either the `clientId` or the `secretKey` depending on whether your application is client or server side.
   *
   * Must be a `string`.
   *
   * #### factoryInfo
   * Customize how the Smart Wallet Factory contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `createAccount` - a function that returns the transaction object to create a new Smart Wallet.
   * - `getAccountAddress` - a function that returns the address of the Smart Wallet contract given the owner address.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       factoryInfo: {
   *         createAccount: async (factory, owner) => {
   *           return factory.prepare("customCreateAccount", [
   *             owner,
   *             getExtraData(),
   *           ]);
   *         },
   *         getAccountAddress: async (factory, owner) => {
   *           return factory.call("getAccountAddress", [owner]);
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   *
   * #### accountInfo
   * Customize how the Smart Wallet Account contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `execute` - a function that returns the transaction object to execute an arbitrary transaction.
   * - `getNonce` - a function that returns the current nonce of the account.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       accountInfo: {
   *         execute: async (account, target, value, data) => {
   *           return account.prepare("customExecute", [
   *             target, value, data
   *           ]);
   *         },
   *         getNonce: async (account) => {
   *           return account.call("getNonce");
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   * #### bundlerUrl
   * Your own bundler URL to send user operations to. Uses thirdweb's bundler by default.
   *
   * Must be a `string`.
   *
   * #### paymasterUrl
   * Your own paymaster URL to send user operations to for gasless transactions. Uses thirdweb's paymaster by default.
   *
   * Must be a `string`.
   *
   * #### paymasterAPI
   * Fully customize how the paymaster data is computed.
   *
   * Must be a `PaymasterAPI` class.
   *
   * ```javascript
   * class MyPaymaster extends PaymasterAPI {
   *   async getPaymasterAndData(
   *     userOp: Partial<UserOperationStruct>,
   *   ): Promise<string> {
   *     // your implementation, must return the signed paymaster data
   *   }
   * }
   *
   * const config: SmartWalletConfig = {
   *   chain,
   *   gasless,
   *   factoryAddress,
   *   clientId,
   *   // highlight-start
   *   paymasterAPI: new MyPaymaster(),
   *   // highlight-end
   * };
   * ```
   *
   *
   * #### entryPointAddress
   * The entrypoint contract address. Uses v0.6 by default.
   *
   * Must be a `string`.
   *
   * #### deployOnSign
   * Whether to deploy the smart wallet when the user signs a message. Defaults to true.
   *
   * Must be a `boolean`.
   *
   * #### chains
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to thirdweb's [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * #### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SmartWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new SmartWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   */
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(_SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      if (this.options && await isZkSyncChain(this.options.chain, this.options.clientId, this.options.secretKey)) {
        const {
          ZkSyncConnector
        } = await import("./zk-connector-fada2157.browser.esm-AZ3BFCXV.js");
        this.connector = new ZkSyncConnector(this.options);
      } else {
        const {
          SmartWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-XMYBJL4Q.js");
        this.connector = new SmartWalletConnector(this.options);
      }
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Smart Wallet.
   * @example
   * ```ts
   * const personalWallet = wallet.getPersonalWallet();
   * ```
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction - The transaction to execute using the smart wallet.
   * @returns `Promise<true>` if connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Send a single transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async send(transaction, options) {
    const connector = await this.getConnector();
    return connector.send(transaction, options);
  }
  /**
   * Execute a single transaction and wait for confirmations
   *
   * @example
   * ```javascript
   * const transaction = prepareTransaction();
   * await wallet.execute(transaction);
   * ```
   *
   * @param transaction -
   * The transaction to execute. Must be of type `Transaction` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](https://portal.thirdweb.com/typescript/v4/interact#prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async execute(transaction, options) {
    const connector = await this.getConnector();
    return connector.execute(transaction, options);
  }
  /**
   * Send a multiple transaction in a batch without waiting for confirmations
   * @param transactions -
   * An array of transactions to send. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async sendBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions, options);
  }
  /**
   * Execute multiple transactions in a single batch and wait for confirmations, only requiring one signature from the personal wallet.
   *
   * ```javascript
   * // Then you can execute multiple transactions at once
   * const transactions = [
   *   prepareTransaction1(),
   *   prepareTransaction2(),
   *   prepareTransaction3(),
   * ];
   * await wallet.executeBatch(transactions);
   * ```
   *
   * @param transactions -
   * An array of transactions to execute. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   *
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async executeBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions, options);
  }
  /**
   * Send a single raw transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction, options);
  }
  /**
   * Execute a single raw transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction, options);
  }
  /**
   * Estimate the gas cost of a single transaction
   * @param transaction - the transaction to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimate(transaction, options) {
    const connector = await this.getConnector();
    return connector.estimate(transaction, options);
  }
  /**
   * Estimate the gas cost of a batch of transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions, options);
  }
  /**
   * Estimate the gas cost of a single raw transaction
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions, options);
  }
  /**
   * Estimate the gas cost of a batch of raw transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions, options);
  }
  /**
   * Send multiple raw transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions, options);
  }
  /**
   * Execute multiple raw transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions, options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   *
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * const tx = await wallet.deploy();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deploy(options) {
    const connector = await this.getConnector();
    return connector.deploy(options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * await wallet.deployIfNeeded();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deployIfNeeded(options) {
    const connector = await this.getConnector();
    return connector.deployIfNeeded(options);
  }
  /**
   * Check if the smart wallet contract is deployed
   * @example
   * ```ts
   * const isDeployed = await wallet.isDeployed();
   * ```
   *
   * @returns `true` if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    if (connector.chainId && await isZkSyncChain(connector.chainId)) {
      return true;
    }
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the Smart Wallet with specific permissions.
   * @example
   * ```javascript
   * // Then you can add session keys with permissions
   * await wallet.createSessionKey(
   *   "0x...", // the session key address
   *   {
   *       approvedCallTargets: ["0x..."], // the addresses of contracts that the session key can call
   *       nativeTokenLimitPerTransaction: 0.1, // the maximum amount of native token (in ETH) that the session key can spend per transaction
   *       startDate: new Date(), // the date when the session key becomes active
   *       expirationDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // the date when the session key expires
   *   }
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to add to the Smart Wallet.
   *
   * @param permissions -
   * The specific permissions to give to the session key.
   * Must be of type `SignerPermissionsInput` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * ```typescript
   * {
   *   startDate: Date;
   *   expirationDate: Date;
   *   nativeTokenLimitPerTransaction: number;
   *   approvedCallTargets: string[];
   * }
   * ```
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Revoke a session key from the Smart Wallet.
   * @example
   * ```javascript
   * await wallet.revokeSessionKey(
   *   "0x...", // the session key address
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to revoke.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress - The address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress - The address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns The account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns The account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  async verifySignature(message, signature, address, chainId) {
    var _a, _b;
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        return await checkContractWalletSignature(message, signature, address, chainId || 1, (_a = this.options) == null ? void 0 : _a.clientId, (_b = this.options) == null ? void 0 : _b.secretKey);
      } catch {
      }
    }
    return false;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect the SmartWallet with given personalWallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * #### personalWallet
   * The instance of a personal wallet that can sign transactions on the Smart Wallet.
   * Must be of type `EVMWallet` instance such as `CoinbaseWallet` or `MetamaskWallet`.
   *
   * @returns A Promise that resolves to the address of the Smart Wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Trust Wallet";
  }
  /**
   * Create instance of `TrustWallet`
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    var _a;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-MJHPAUMB.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_lib3();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  /**
   *
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### projectId (recommended)
   * Your project's unique identifier. It can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * It enables the following functionalities within WalletConnect's web3modal:
   *
   * - wallet and chain logos
   * - optional WalletConnect RPC
   * - support for all wallets from our Explorer and WalletConnect v2 support
   *
   * Defaults to thirdweb's common project id.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { WalletConnect } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new WalletConnect({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _defineProperty(this, "_maybeThrowError", (error) => {
      if (error) {
        throw error;
      }
    });
    _defineProperty(this, "_onConnect", (data) => {
      this._provider = data.provider;
      if (!this._provider) {
        throw new Error("WalletConnect provider not found after connecting.");
      }
    });
    _defineProperty(this, "_onDisconnect", () => {
      this._removeListeners();
    });
    _defineProperty(this, "_onChange", async (payload) => {
      if (payload.chain)
        ;
      else if (payload.account)
        ;
    });
    _defineProperty(this, "_onMessage", (payload) => {
      switch (payload.type) {
        case "display_uri":
          this.emit("display_uri", payload.data);
          break;
      }
    });
    _defineProperty(this, "_onSessionRequestSent", () => {
      this.emit("wc_session_request_sent");
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
      this._walletConnectConnector = new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      });
      this.connector = new WagmiAdapter(this._walletConnectConnector);
      this._provider = await this._walletConnectConnector.getProvider();
      this._setupListeners();
    }
    return this.connector;
  }
  _setupListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._removeListeners();
    this._walletConnectConnector.on("connect", this._onConnect);
    this._walletConnectConnector.on("disconnect", this._onDisconnect);
    this._walletConnectConnector.on("change", this._onChange);
    this._walletConnectConnector.on("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.on("session_request_sent", this._onSessionRequestSent);
  }
  _removeListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._walletConnectConnector.removeListener("connect", this._onConnect);
    this._walletConnectConnector.removeListener("disconnect", this._onDisconnect);
    this._walletConnectConnector.removeListener("change", this._onChange);
    this._walletConnectConnector.removeListener("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", this._onSessionRequestSent);
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. User can scan this QR code from the Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = false;
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * @internal
   */
  async connectWithModal(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = true;
    await wcConnector.initProvider();
    await this.connect({
      chainId: options == null ? void 0 : options.chainId
    });
  }
};
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Zerion Wallet";
  }
  /**
   * Create an instance of `ZerionWallet`.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### qrcode
   * Whether to open the default Wallet Connect QR code Modal for connecting to Zerion Wallet on mobile
   * (if Zerion is not injected when calling `connect()`).
   *
   * Must be a `boolean`. Defaults to `false`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   * ```javascript
   * import { ZerionWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new ZerionWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   */
  constructor(options) {
    var _a;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-T3EDIYXX.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-HD4QIIG2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Zerion Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_lib3();
var import_contracts2 = __toESM(require_dist());
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-TA3Q72AD.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic-eden/dist/thirdweb-dev-wallets-evm-wallets-magic-eden.browser.esm.js
init_lib3();
var MagicEdenWallet = class _MagicEdenWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Eden";
  }
  /**
   * Create instance of `MagicEdenWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MagicEdenWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new MagicEdenWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_MagicEdenWallet.id, options);
    this.isInjected = !!getInjectedMagicEdenProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        MagicEdenConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-magic-eden.browser.esm-ZC6DGCI4.js");
      const connector = new MagicEdenConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(MagicEdenWallet, "id", walletIds.magicEden);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_contracts3 = __toESM(require_dist());
var import_buffer2 = __toESM(require_buffer2());
var import_utils6 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "thirdweb Smart Account",
        description: "thirdweb Smart Account",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    this._wcMetadata = defaultWCReceiverConfig.walletConnectWalletMetadata;
    this._core = new Rn({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    });
  }
  async init() {
    this._wcWallet = await ie4.init({
      core: this._core,
      metadata: this._wcMetadata
    });
    const sessions = this._wcWallet.getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      this._session = sessions[keys[0]];
    }
    this._setupWalletConnectEventsListeners();
  }
  async connectApp(wcUri) {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await this._wcWallet.core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = this._activeProposal;
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    this._session = await this._wcWallet.approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    });
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = this._activeProposal;
    await this._wcWallet.rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a, _b;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      params,
      id
    } = this._activeRequestEvent;
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = this._getSignParamsMessage(request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = this._wcWallet) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      id
    } = this._activeRequestEvent;
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = this._wcWallet.getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!this._session) {
      return Promise.resolve();
    }
    const params = {
      topic: this._session.topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.disconnectSession(params);
  }
  _setupWalletConnectEventsListeners() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this._wcWallet.on("session_proposal", (proposal) => {
      this._activeProposal = proposal;
      this.emit("session_proposal", {
        proposer: {
          metadata: proposal.params.proposer.metadata
        }
      });
    });
    this._wcWallet.on("session_delete", (session) => {
      this._session = void 0;
      this._activeProposal = void 0;
      this.emit("session_delete", {
        topic: session.topic
      });
    });
    this._wcWallet.on("session_request", async (requestEvent) => {
      if (!this._session) {
        return;
      }
      const {
        params: requestParams
      } = requestEvent;
      const {
        request
      } = requestParams;
      const {
        params
      } = request;
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          this._activeRequestEvent = requestEvent;
          const message = params[0];
          const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
          const paramsCopy = [...params];
          paramsCopy[0] = decodedMessage;
          this.emit("session_request", {
            topic: this._session.topic,
            params: paramsCopy,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          this._activeRequestEvent = requestEvent;
          this.emit("session_request", {
            topic: this._session.topic,
            params: requestEvent.params.request.params,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        default:
          throw new Error(`WCV2.Method not supported: ${request.method}`);
      }
    });
  }
  /**
   * Gets message from various signing request methods by filtering out
   * a value that is not an address (thus is a message).
   * If it is a hex string, it gets converted to utf8 string
   */
  _getSignParamsMessage(params) {
    const message = params.filter((p4) => !utils_exports.isAddress(p4))[0] || "";
    if (utils_exports.isHexString(message)) {
      return utils_exports.toUtf8String(message);
    }
    return message;
  }
};

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  BloctoWallet,
  EmbeddedWallet,
  MetaMaskWallet,
  OKXWallet,
  CoreWallet,
  OneKeyWallet,
  CryptoDefiWallet,
  RabbyWallet,
  Coin98Wallet,
  getInjectedCoinbaseProvider,
  EngineSigner,
  EngineWallet,
  PaperWallet,
  CoinbaseWallet,
  EthersWallet,
  FrameWallet,
  ImTokenWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  XDEFIWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  MagicEdenWallet,
  LocalStorage,
  createLocalStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-AO5WOBG4.js.map
